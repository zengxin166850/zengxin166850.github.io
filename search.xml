<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的live2d配置]]></title>
    <url>%2F2019%2F04%2F27%2F%E6%88%91%E7%9A%84live2d%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[给hexo加上live2d只能说是自己作为死宅的本能反应吧= =，在别人的网站上看过之后总是觉得羨ましい（羡慕的起码要死三次），然后到处找文章想给自己也加上，本来很简单的事情还用了大半天(I very vegetables) orz，这次把步骤写上来。也算做个备份吧，指不定那天忘了呢。 hexo的官方插件hexo的官方有提供名为hexo-helper-live2d的插件使用如下安装命令就可以安装 npm install –save hexo-helper-live2d 随后在Hexo的_config.yml文件中添加如下配置(据说是可以配在主题的_config.yml中的，但是我没试过呢orz).示例: 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko //启用的模型目录 display: position: right width: 150 height: 300 mobile: show: true 这样一个默认的模型就配好了，默认是这样的: 添加互动：默认的模型只有很简单的动画，在别人网站里看到的都是能互动对话的(再次羡慕的要死)，经过查阅找到了大佬的教程把萌萌哒的看板娘抱回家。 (到这里需要把之前配置文件中的live2d.enable修改为false)根据步骤来，jquery在主题中是已经存在的直接跳过，将项目下载下来，将autoload.js、 live2d.min.js、waifu-tips.js、waifu-tips.json、waifu.css这几个文件放入到next主题中/source/js/src目录下，也可以将json和css文件放到对于的目录下，但是需要改动下autoload中的路径，我这里偷懒直接放到一起了orz &lt;script src=&quot;/js/src/autoload.js&quot;&gt;&lt;/script&gt; 将上面这句放入到主题的/layout/_layout.swing中body标签的末尾，autoload.js的内容如下：123456789101112131415161718192021222324252627282930//开始加斜杠和不加是完全不同的路径,这里改为了我放置的相对路径const live2d_path = "/js/src/";//const live2d_path = "./";$("&lt;link&gt;").attr(&#123;href: live2d_path + "waifu.css", rel: "stylesheet", type: "text/css"&#125;).appendTo("head");//waifu.css的绝对路径$.ajax(&#123; url: live2d_path + "live2d.min.js", dataType: "script", cache: true, async: false&#125;);//live2d.min.js的绝对路径$.ajax(&#123; url: live2d_path + "waifu-tips.js", dataType: "script", cache: true, async: false&#125;);//waifu-tips.js的绝对路径//初始化看板娘，会自动加载指定目录下的waifu-tips.json$(window).on("load", function() &#123; initWidget(live2d_path + "waifu-tips.json", "https://live2d.fghrsh.net/api");&#125;);//initWidget第一个参数为waifu-tips.json的绝对路径//第二个参数为api地址（无需修改）//api后端可自行搭建，参考https://github.com/fghrsh/live2d_api 然后打开waifu-tips.js，在方法initWidget中将下面这句话移到方法的最前面，这样可以在关闭live2d后，刷新时重新加载。 localStorage.removeItem(&quot;waifu-display&quot;); 添加拖动上述操作完成之后确发现一个问题，模型不能拖动？？？了解到模型是在canvas中绘制的，于是编写了如下的拖动方法(放在了waifu-tips.js中)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 绘制图片坐标 var X=0; var Y=0;// js部分 var divObj=document.getElementById("waifu"); var moveFlag=false;//区别moueseup与click的标志 var clickFlag=false;// 拖拽函数 divObj.onmousedown=function(e)&#123; moveFlag=true; clickFlag=true; var clickEvent=window.event||e; var mwidth=clickEvent.clientX-divObj.offsetLeft; var mheight=clickEvent.clientY-divObj.offsetTop; document.onmousemove=function(e)&#123; clickFlag=false; var moveEvent=window.event||e; if(moveFlag)&#123; divObj.style.left=moveEvent.clientX-mwidth+"px"; divObj.style.top=moveEvent.clientY-mheight+"px";//// 将鼠标坐标传给Canvas中的图像 X=moveEvent.clientX-mwidth; Y=moveEvent.clientY-mheight;//// 下面四个条件为限制div以及图像的活动边界 if(moveEvent.clientX&lt;=mwidth)&#123; divObj.style.left=0+"px"; X=0; &#125; if(parseInt(divObj.style.left)+divObj.offsetWidth &gt;=innerWidth)&#123; divObj.style.left=innerWidth - divObj.offsetWidth+"px"; X=innerWidth - divObj.offsetWidth; &#125; if(moveEvent.clientY&lt;=mheight)&#123; divObj.style.top=0+"px"; Y=0; &#125; if(parseInt(divObj.style.top)+divObj.offsetHeight&gt;=innerHeight)&#123; divObj.style.top=innerHeight-divObj.offsetHeight+"px"; Y=innerHeight-divObj.offsetHeight; &#125; divObj.onmouseup=function()&#123; moveFlag=false; &#125; &#125; &#125; &#125;; tips： 在waifu-tips.js中waifu-tool里有几个写好的模块，可以自定义添加或删除，每个span对应一个功能initmodel方法里有默认的加载模型，可以将随机更换注释掉，选择喜欢的固定模型waifu-tips.json中包含了触发条件（选择器的事件）和触发时显示的文字，也可以自定义 我巴美如画]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>另一个次元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2019%2F04%2F22%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[为什么要使用线程池线程池是并发场景中比较常见的运用，几乎所有的异步或并发执行任务的程序都可以使用线程池。在开发中使用线程池能带来以下好处。 降低资源消耗。重复利用已创建的线程，降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不用等待线程的创建，直接执行。 提高线程的可管理性。线程是稀缺资源，不会无限制地创建。不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 线程池的工作原理线程池的创建依赖于ThreadPoolExecutor，它的构造函数如下所示：1234567891011public ThreadPoolExecutor(int corePoolSize, //核心线程数量 int maximumPoolSize, //最大线程数 long keepAliveTime, //超时时间,超出核心线程数量以外的线程空余存活时间 TimeUnit unit, //存活时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //保存执行任务的队列 ThreadFactory threadFactory,//创建新线程使用的工厂RejectedExecutionHandler handler //当任务无法执行的时候的处理方式) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);&#125; 创建线程池所需要的参数: corePoolSize(核心线程数量): 当提交一个任务到线程池中，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行任务也会创建新的线程，直到池中的线程数达到corePoolSize的大小就不再创建。 workQueue(工作/任务队列)：用于保存等待执行的任务的阻塞队列。 maximumPoolSize(最大线程数): 线程池所允许创建的最大线程数量，如果工作队列满了，并且已创建的的线程数小于最大线程数，此时线程池会临时创建新的线程执行任务。 keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间，超过时间会被回收。 unit: 线程保持活动时间的单位。 threadFactory: 用于设置创建线程的工厂。 handler(饱和处理器)：当工作队列为有界队列，并且池中的线程数量已经达到了最大线程数，此时新提交的任务就会由handler进行饱和处理，抛出异常。 当提交一个新任务到线程池中，线程池的处理流程如下： 判断线程是否已经达到核心线程数，如果当前池中线程数少于核心线程数，创建一个新线程，否则进入下一个流程。 判断工作队列是否已满，如果未满，则将任务放入队列中，如果队列已满，则进行下一个流程。 判断当前池中线程数是否已达到最大线程数，如果未达到，则创建新的线程并执行任务，如果已达到最大线程数，则任务会被拒绝。 当其他的线程执行完任务时，会进入空闲状态，如果队列中有任务，会取出来执行，当队列为空之后，超过空闲存活时间的队列会被回收。流程图： execute方法流程分析1234567891011121314151617181920public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123;//1.当前池中线程比核心数少，新建一个线程执行任务 if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;//2.核心池已满，但任务队列未满，添加到队列中 int recheck = ctl.get(); //任务成功添加到队列以后，再次检查是否需要添加新的线程，因为已存在的线程可能被销毁了 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //如果线程池处于非运行状态，并且把当前的任务从任务队列中移除成功，则拒绝该任务 else if (workerCountOf(recheck) == 0) addWorker(null, false);//如果之前的线程已被销毁完，新建一个线程 &#125; else if (!addWorker(command, false)) //3.核心池已满，队列已满，试着创建一个新线程 reject(command); //如果创建新线程失败了，说明线程池被关闭或者线程池完全满了，拒绝任务&#125; submit和execute的区别向一个线程池提交任务，可以使用submit和execute，这两者有什么区别呢？ execute只能接受Runnable类型的任务，execute没有返回值 submit不管是Runnable还是Callable类型的任务都可以接受，但是Runnable返回值均为void，所以使用Future的get()获得的还是null 不得不说- -，记录这篇文章的时候。满脑子都是当初在滴p科技面试时没答上来的尴尬(2333),也算是巩固了一遍知识吧~~放上我的老婆= =]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql下获取某月的每一天]]></title>
    <url>%2F2019%2F04%2F22%2Fmysql%E4%B8%8B%E8%8E%B7%E5%8F%96%E6%9F%90%E6%9C%88%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[记得以前自己写数据统计接口时，遇到一个根据选择的月份，查询出每天的数据的要求，由于每个月份的天数不同，不能按照固定天数来查。经过查阅之后找到了如下的方式： 使用union和日期函数构造一个左表12345678910111213SELECT ADDDATE(y.first, x.d - 1) as dd FROM (SELECT 1 AS d UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9 UNION ALL SELECT 10 UNION ALL SELECT 11 UNION ALL SELECT 12 UNION ALL SELECT 13 UNION ALL SELECT 14 UNION ALL SELECT 15 UNION ALL SELECT 16 UNION ALL SELECT 17 UNION ALL SELECT 18 UNION ALL SELECT 19 UNION ALL SELECT 20 UNION ALL SELECT 21 UNION ALL SELECT 22 UNION ALL SELECT 23 UNION ALL SELECT 24 UNION ALL SELECT 25 UNION ALL SELECT 26 UNION ALL SELECT 27 UNION ALL SELECT 28 UNION ALL SELECT 29 UNION ALL SELECT 30 UNION ALL SELECT 31 ) x, (SELECT CONCAT("2019-02",'-01') as FIRST, DAY(LAST_DAY(STR_TO_DATE("2019-02",'%Y-%m'))) AS last) y WHERE x.d &lt;= y.last 结果如下:之后只需将上面的结果集与需要的结果左连接，进行聚合就拿到结果啦~近期准备慢慢的把有道云里的笔记搬上来占个位= =]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最终我还是将fate游戏玩了一遍]]></title>
    <url>%2F2019%2F04%2F21%2Ffate%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[占个坑，慢慢填]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>另一个次元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式---单例模式]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式简单介绍单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类成为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 模式结构图 单例模式需要注意事项1.单例类的构造函数私有2.提供一个自身的静态私有成员变量3.提供一个公有的静态工厂方法 单例模式实例这里模拟实现一个居民身份证唯一的单例场景。123456789101112131415161718192021222324// 单例类如下public class IdCardNo &#123; private static IdCardNo instance = null; private String no; private IdCardNo() &#123; &#125; public static IdCardNo getInstance() &#123; if (instance == null) &#123; instance = new IdCardNo(); instance.setNo("No5000011113333"); &#125; return instance; &#125; public String getNo() &#123; return no; &#125; private void setNo(String no) &#123; this.no = no; &#125; 单例的多种写法上述场景中使用的是懒汉式写法，单例模式还有如下的几种写法饿汉式：1234567891011public class EagerSingleton &#123; private static EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123; &#125; public static EagerSingleton getInstance() &#123; return instance; &#125; &#125; 饿汉式的写法可以保证线程安全，但从资源利用率角度来考虑，比懒汉式写法稍差。但懒汉式存在线程安全问题，所以接下来考虑多个线程同时首次引用单例的访问限制问题。双重检测的单例：123456789101112131415161718public class Singleton &#123; //volatile禁止指令重排序，保证可见性 private static volatile Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 双重检测虽然解决了多线程的访问限制问题，但这个写法看起来着实不美观。那么我们还有没有别的写法呢？答案是有的。基于枚举的方式：12345678910111213public enum SingletonEnum &#123; INSTANCE; private Singleton instance = null; private SingletonEnum() &#123; instance = new Singleton(); &#125; public Singleton getInstance() &#123; return instance; &#125; &#125; 单元素的枚举类可以保证单例的线程安全、序列化，除单元素枚举外，还有使用java内部类实现的方式。基于内部类实现单例：1234567891011121314151617181920212223242526272829303132public class Singleton implements Serializable &#123; private Singleton() &#123; &#125; private static class SingletonHandler &#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonHandler.instance; &#125; private Object readResolve()&#123; System.out.println("read resolve"); return SingletonHandler.instance; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; Singleton instance = Singleton.getInstance(); File file = new File("ser.out"); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(instance); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); Singleton oIstance = (Singleton)ois.readObject(); ois.close(); System.out.println(oIstance == instance); &#125; &#125; 使用静态内部类的优点是：外部类加载时并不需要立即加载内部类，即当Singletonle被加载时，并不需要去加载SingletonHandler，只有当getInstance()方法第一次被调用时，才会去初始化SingletonHandler,同时初始化该类的静态变量instance,在确保线程安全的同时也延迟了单例的实例化. 总结一个类模板，在整个系统中只允许产生一个实例叫做单例。单例有多种写法：懒汉式、饿汉式、双重检查、枚举、内部类。 饿汉式不管用不用先创建出来，保证线程安全。 懒汉式延迟加载，有效利用资源不保证线程安全。 双重检测方式保证了懒汉式的线程安全问题。 单元素枚举可以同时保证线程安全和序列化。 内部类使用了jvm的类加载机制来保证线程安全和懒加载。 序列化和反序列化保证单例需要重写类的readResolve()方法]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我来了，我的博客]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%88%91%E6%9D%A5%E4%BA%86%EF%BC%8C%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[很久之前，在学习github的使用时就有了搭建这个个人博客的想法，虽说按照教程，早早地就已经搭建好了这个博客， 但是随着毕业季、入职工作等一系列的事情，也没有好好的静下心来整理。现如今工作也稳定下来了，一年多的时间不长不短，也是时候总结一下自己了。从小到大没有写日志习惯的我，估计写出来的东西，也只有自己能看看吧（笑），权当做给自己做个笔记，记录些工作中和生活中的小事吧。现在，第一步，先给我的hexo换个主题吧~ 第一次用markdown，语法还是挺奇怪的，不太习惯（雾）]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>开始</tag>
      </tags>
  </entry>
</search>
