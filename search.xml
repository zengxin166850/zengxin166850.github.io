<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用设计模式---单例模式]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%88%E5%88%97%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[单例模式简单介绍单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类成为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 模式结构图 单例模式需要注意事项1.单例类的构造函数私有2.提供一个自身的静态私有成员变量3.提供一个公有的静态工厂方法 单例模式实例这里模拟实现一个居民身份证唯一的单例场景。123456789101112131415161718192021222324// 单例类如下public class IdCardNo &#123; private static IdCardNo instance = null; private String no; private IdCardNo() &#123; &#125; public static IdCardNo getInstance() &#123; if (instance == null) &#123; instance = new IdCardNo(); instance.setNo("No5000011113333"); &#125; return instance; &#125; public String getNo() &#123; return no; &#125; private void setNo(String no) &#123; this.no = no; &#125; 单例的多种写法上述场景中使用的是懒汉式写法，单例模式还有如下的几种写法饿汉式：1234567891011public class EagerSingleton &#123; private static EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123; &#125; public static EagerSingleton getInstance() &#123; return instance; &#125; &#125; 饿汉式的写法可以保证线程安全，但从资源利用率角度来考虑，比懒汉式写法稍差。但懒汉式存在线程安全问题，所以接下来考虑多个线程同时首次引用单例的访问限制问题。双重检测的单例：123456789101112131415161718public class Singleton &#123; //volatile禁止指令重排序，保证可见性 private static volatile Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 双重检测虽然解决了多线程的访问限制问题，但这个写法看起来着实不美观。那么我们还有没有别的写法呢？答案是有的。基于枚举的方式：12345678910111213public enum SingletonEnum &#123; INSTANCE; private Singleton instance = null; private SingletonEnum() &#123; instance = new Singleton(); &#125; public Singleton getInstance() &#123; return instance; &#125; &#125; 单元素的枚举类可以保证单例的线程安全、序列化，除单元素枚举外，还有使用java内部类实现的方式。基于内部类实现单例：1234567891011121314151617181920212223242526272829303132public class Singleton implements Serializable &#123; private Singleton() &#123; &#125; private static class SingletonHandler &#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonHandler.instance; &#125; private Object readResolve()&#123; System.out.println("read resolve"); return SingletonHandler.instance; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; Singleton instance = Singleton.getInstance(); File file = new File("ser.out"); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(instance); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); Singleton oIstance = (Singleton)ois.readObject(); ois.close(); System.out.println(oIstance == instance); &#125; &#125; 使用静态内部类的优点是：外部类加载时并不需要立即加载内部类，即当Singletonle被加载时，并不需要去加载SingletonHandler，只有当getInstance()方法第一次被调用时，才会去初始化SingletonHandler,同时初始化该类的静态变量instance,在确保线程安全的同时也延迟了单例的实例化. 总结一个类模板，在整个系统中只允许产生一个实例叫做单例。单例有多种写法：懒汉式、饿汉式、双重检查、枚举、内部类。 饿汉式不管用不用先创建出来，保证线程安全。 懒汉式延迟加载，有效利用资源不保证线程安全。 双重检测方式保证了懒汉式的线程安全问题。 单元素枚举可以同时保证线程安全和序列化。 内部类使用了jvm的类加载机制来保证线程安全和懒加载。 序列化和反序列化保证单例需要重写类的readResolve()方法]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我来了，我的博客]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%88%91%E6%9D%A5%E4%BA%86%EF%BC%8C%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[很久之前，在学习github的使用时就有了搭建这个个人博客的想法，虽说按照教程，早早地就已经搭建好了这个博客， 但是随着毕业季、入职工作等一系列的事情，也没有好好的静下心来整理。现如今工作也稳定下来了，一年多的时间不长不短，也是时候总结一下自己了。从小到大没有写日志习惯的我，估计写出来的东西，也只有自己能看看吧（笑），权当做给自己做个笔记，记录些工作中和生活中的小事吧。现在，第一步，先给我的hexo换个主题吧~ 第一次用markdown，语法还是挺奇怪的，不太习惯（雾）]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>开始</tag>
      </tags>
  </entry>
</search>
