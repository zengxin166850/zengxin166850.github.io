<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES基础--terms聚合</title>
    <url>/2020/07/02/ES%E5%9F%BA%E7%A1%80--terms%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h3 id="1-一般使用"><a href="#1-一般使用" class="headerlink" title="1.一般使用"></a>1.一般使用</h3><p><strong>基于 es-7.2版本</strong></p>
<p><code>Terms</code>聚合一般情况下是针对字段类型为 <code>keyword</code> 的聚合（<code>text</code> 类型的字段需要开启 <code>fielddata</code> ），用于对指定字段进行唯一匹配，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;terms_test&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;fieldname&quot;,</span><br><span class="line">                &quot;size&quot;: 3</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li><code>indexName</code> 为指定的索引名称；</li>
<li><code>terms_test</code> 为自定义名称，后端程序<code>API</code>可以通过该名称获取到 <code>bucket</code> 结果集；</li>
<li><code>size</code>指定了返回的 <code>topK</code> 条数。</li>
</ul>
<p>其响应结果类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;test&quot; : &#123;</span><br><span class="line">      &quot;doc_count_error_upper_bound&quot; : 7,</span><br><span class="line">      &quot;sum_other_doc_count&quot; : 292,</span><br><span class="line">      &quot;buckets&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;人民检察院&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 114</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;党和国家&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 105</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;菏泽市&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 101</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>doc_count_error_upper_bound</code> 表示没有在这次聚合中返回、但是可能存在的潜在聚合结果，其数量为7，可能会排在最后；</p>
</li>
<li><p><code>sum_other_doc_count</code> 表示未参与本次聚合的文档数量，因为 ES 是分布式部署的，每个分片只返回 <code>topK</code>的结果，其余部分不会扫描。这里设置的 <code>size</code> 是3，所以每个分片只会聚合本分片中前三的数据。即有 292 个文档没有参与本次聚合，<strong>设置的 <code>size</code> 越大，返回结果越准确</strong>。但同时也会增加计算成本；</p>
</li>
<li><p><code>buckets</code> 中的是本次 <code>term</code> 聚合的结果，这里的 <code>doc_count</code> 并不一定是准确的， 有时只是一个近似值，原因同上；</p>
</li>
</ul>
<p>数据不准确的原因，本质上是因为分布式导致的，<strong>尤其是当获取 <code>topK</code> 数据时，节点内的 <code>topK</code> 准确不保证整体 <code>topK</code> 准确。</strong>  <code>max</code>、<code>min</code>、<code>avg</code> 的聚合可以获取准确的结果，但 <code>terms</code> 对于分片数据只能取近似值。</p>
<p>可以通过以下方式提高准确度：</p>
<ul>
<li>不分片（实际情况不现实）；</li>
<li>增加 <code>size</code> 的大小；</li>
<li>设置 <code>shard_size</code> ，该参数可以最小化 <code>size</code> 设置较大时的计算成本，设置后他会限制从每个分片取回的个数。例如 <code>size</code> 设置的取5个，<code>shard_size</code> 设置为取10个。此时分片会返回10个数据减小误差。<code>shard_size</code> 不能小于 <code>size</code>（没有意义），当它比 <code>size</code> 小时，es 会重写为 <code>size</code> 的大小。</li>
</ul>
<h3 id="2-show-term-doc-count-error"><a href="#2-show-term-doc-count-error" class="headerlink" title="2. show_term_doc_count_error"></a>2. show_term_doc_count_error</h3><p>查询中可以设置该参数为 <code>true</code> ,<strong>此时返回的每一个 <code>bucket</code> 都会包含一个误差值的范围 ，在按照升序排序或按照子聚合排序时，es会无法计算该误差值，并返回 -1</strong>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET search_jw_words/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;terms_test&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;:&quot;searchContent&quot;,</span><br><span class="line">        &quot;show_term_doc_count_error&quot;: true,</span><br><span class="line">        &quot;size&quot;: 30</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际应用中其实会发现，排名越往后的数据，出现的误差越大，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;buckets&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;人民检察院&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 265,</span><br><span class="line">          &quot;doc_count_error_upper_bound&quot; : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;菏泽市&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 246,</span><br><span class="line">          &quot;doc_count_error_upper_bound&quot; : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;党和国家&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 220,</span><br><span class="line">          &quot;doc_count_error_upper_bound&quot; : 0</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>
<h3 id="3-使用-include-exclude-来过滤结果中的指定内容"><a href="#3-使用-include-exclude-来过滤结果中的指定内容" class="headerlink" title="3. 使用 include/exclude 来过滤结果中的指定内容"></a>3. 使用 <code>include/exclude</code> 来过滤结果中的指定内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;terms_test&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123; </span><br><span class="line">                &quot;field&quot; : &quot;fieldname&quot;,</span><br><span class="line">                &quot;exclude&quot;: [&quot;张三&quot;,&quot;王五&quot;],</span><br><span class="line">                &quot;include&quot;: &quot;李四&quot;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我测试的7.2版本中，两者不能同时使用，要么单独设置 <code>exlude</code>，要么单独设置 <code>include</code> 。</p>
<p>也可以使用正则表达式的方式进行过滤（一开始我想通过正则去除单字的结果，然后后再过滤给定的词典，但并不能起到组合的效果）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;terms_test&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;fieldname&quot;,</span><br><span class="line">                #正则表达式语法与正则查询的语法相同.</span><br><span class="line">                &quot;include&quot; : &quot;.&quot;,</span><br><span class="line">                &quot;exclude&quot; : &quot;water_.*&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-自定义排序"><a href="#4-自定义排序" class="headerlink" title="4. 自定义排序"></a>4. 自定义排序</h3><p>默认状态下，聚合结果会根据返回 <code>bucket</code> 中的 <code>doc_count</code> 来进行降序排序，想要更改的话可以使用以下方式：</p>
<blockquote>
<p>官方文档提示：不推荐根据 <code>count</code> 来降序排，本身聚合是从分片取 <code>topK</code> 的行为，倒序会使准确度更低。</p>
</blockquote>
<p><strong>升序排序的查询方式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">   	&quot;size&quot;: 0, </span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;terms_test&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;fieldname&quot;,</span><br><span class="line">                # _count/_key 分别表示按数量、名称排序</span><br><span class="line">                &quot;order&quot; : &#123; &quot;_count&quot; : &quot;asc&quot; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用子聚合排序：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;terms_test&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;fieldname&quot;,</span><br><span class="line">                &quot;order&quot; : &#123; &quot;sub_agg&quot; : &quot;desc&quot; &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            #按子聚合的最大xx排序。</span><br><span class="line">            &quot;aggs&quot; : &#123;</span><br><span class="line">                &quot;sub_agg&quot; : &#123; &quot;max&quot; : &#123; &quot;field&quot; : &quot;fieldname2&quot; &#125; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;terms_test&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;fieldname&quot;,</span><br><span class="line">                #使用 . 来确定排序依据</span><br><span class="line">                &quot;order&quot; : &#123; &quot;sub_agg.max&quot; : &quot;desc&quot; &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            #stats的结果会同时包含 count、max、min、avg、sum</span><br><span class="line">            &quot;aggs&quot; : &#123;</span><br><span class="line">                &quot;sub_agg&quot; : &#123; &quot;stats&quot; : &#123; &quot;field&quot; : &quot;fieldname2&quot; &#125; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>pipeline</code> 聚合由于本身机制问题不能用该方式。</p>
</blockquote>
<p>官方文档声明为：子聚合的层级可以任意多，只要按照规定的命名方式，就可以完成排序，例如更深一层级的写法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;terms_test&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;fieldname&quot;,</span><br><span class="line">                &quot;order&quot; : &#123; &quot;sub1&gt;sub2.avg&quot; : &quot;desc&quot; &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;aggs&quot; : &#123;</span><br><span class="line">                &quot;sub1&quot; : &#123;</span><br><span class="line">                	#过滤范围只包含 &quot;张三&quot;</span><br><span class="line">                    &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;fieldname2&quot; :  &quot;张三&quot; &#125;&#125;,</span><br><span class="line">                    &quot;aggs&quot; : &#123;</span><br><span class="line">                    	#stats的结果会同时包含 count、max、min、avg、sum</span><br><span class="line">                        &quot;sub2&quot; : &#123; </span><br><span class="line">                        	&quot;stats&quot; : &#123; &quot;field&quot; : &quot;fieldname3&quot; &#125;</span><br><span class="line">                        	&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>order</code> 规则需满足以下条件：（即 <code>sub1&gt;sub2&gt;....sub100.avg</code>）</p>
<ul>
<li>聚合层级间使用 “&gt;” ；</li>
<li>属性间使用 “.” ；</li>
<li>聚合名为自定义的名称。</li>
</ul>
<p><strong>另外 <code>order</code> 还可以使用数组的方式对多个内容进行排序:</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;terms_test&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;fieldname&quot;,</span><br><span class="line">                # 先按子聚合内容排序，再按doc_count排序</span><br><span class="line">                &quot;order&quot; : [&#123; &quot;sub1&gt;sub2.avg&quot; : &quot;desc&quot; &#125;,&#123; &quot;_count&quot;: &quot;desc&quot; &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;aggs&quot; : &#123;</span><br><span class="line">                &quot;sub1&quot; : &#123;</span><br><span class="line">                	# 过滤范围只包含 &quot;张三&quot;</span><br><span class="line">                    &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;fieldname2&quot; :  &quot;张三&quot; &#125;&#125;,</span><br><span class="line">                    &quot;aggs&quot; : &#123;</span><br><span class="line">                    	# stats的结果会同时包含 count、max、min、avg、sum</span><br><span class="line">                        &quot;sub2&quot; : &#123; </span><br><span class="line">                        	&quot;stats&quot; : &#123; &quot;field&quot; : &quot;fieldname3&quot; &#125;</span><br><span class="line">                        	&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-使用-script-脚本进行聚合"><a href="#5-使用-script-脚本进行聚合" class="headerlink" title="5. 使用 script 脚本进行聚合"></a>5. 使用 <code>script</code> 脚本进行聚合</h3><p>es提供了脚本支持—-内置 <code>painless</code> 脚本语言。（下次会单独解释下脚本如何使用）,如下脚本也可以实现对指定字段的聚合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;terms_test&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;script&quot; : &#123;</span><br><span class="line">                    &quot;source&quot;: &quot;doc[&apos;fieldname&apos;].value&quot;,</span><br><span class="line">                    &quot;lang&quot;: &quot;painless&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使用已经创建好的脚本的话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;terms_test&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;script&quot; : &#123;</span><br><span class="line">                	&quot;id&quot;: &quot;my_script&quot;,</span><br><span class="line">                	&quot;params&quot;: &#123;</span><br><span class="line">                        &quot;field&quot;: &quot;fieldname&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对 <code>value</code> 的 <code>script</code> 脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;terms_test&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;fieldname&quot;,</span><br><span class="line">                &quot;script&quot; : &#123;</span><br><span class="line">                    &quot;source&quot; : &quot;&apos;我是前缀: &apos; +_value&quot;,</span><br><span class="line">                    &quot;lang&quot; : &quot;painless&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-多字段聚合"><a href="#6-多字段聚合" class="headerlink" title="6. 多字段聚合"></a>6. 多字段聚合</h3><p><code>terms</code> 聚合不支持多字段。想要进行多字段聚合需要使用 <code>script</code> 脚本进行处理，或者使用 <code>copy_to</code> 字段（<code>copy_to</code>即老版本的 <code>_all</code> 字段，但更加灵活）。</p>
<h3 id="7-collect-mode"><a href="#7-collect-mode" class="headerlink" title="7. collect_mode"></a>7. collect_mode</h3><p><code>collect_mode</code> 分为深度优先搜索（<code>depth_first</code>）和广度优先搜索（<code>breadth_first</code> ），一般情况下默认使用<code>depth_mode</code>。但某些时候更适合<code>breadth_first</code> </p>
<p>场景例如：想要查询最受欢迎的10位演员，及其最常见的5位联合主演。虽然在这个数量级下只是获取50个结果，但每增加一个演员都会进行 n² 的增长：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">    "aggs" : &#123;</span><br><span class="line">        "actors" : &#123;</span><br><span class="line">             "terms" : &#123;</span><br><span class="line">                 "field" : "actors",</span><br><span class="line">                 "size" : 10</span><br><span class="line">             &#125;,</span><br><span class="line">            "aggs" : &#123;</span><br><span class="line">                "costars" : &#123;</span><br><span class="line">                     "terms" : &#123;</span><br><span class="line">                         "field" : "actors",</span><br><span class="line">                         "size" : 5</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，可以使用 <code>breath_first</code> 模式来优化子聚合的加载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;actors&quot; : &#123;</span><br><span class="line">             &quot;terms&quot; : &#123;</span><br><span class="line">                 &quot;field&quot; : &quot;actors&quot;,</span><br><span class="line">                 &quot;size&quot; : 10,</span><br><span class="line">                 # 此处可以选择的值包括 breadth_first 和 depth_first两种</span><br><span class="line">                 &quot;collect_mode&quot; : &quot;breadth_first&quot; </span><br><span class="line">             &#125;,</span><br><span class="line">            &quot;aggs&quot; : &#123;</span><br><span class="line">                &quot;costars&quot; : &#123;</span><br><span class="line">                     &quot;terms&quot; : &#123;</span><br><span class="line">                         &quot;field&quot; : &quot;actors&quot;,</span><br><span class="line">                         &quot;size&quot; : 5</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>breath_first</code> 即先确定好10名最受欢迎的演员，然后再取对应的联合主演。而不是每一个演员都先去确定其联合主演。</p>
<h3 id="8-tips"><a href="#8-tips" class="headerlink" title="8. tips"></a>8. tips</h3><blockquote>
<p>在多个索引上聚合时，聚合字段的类型可能在每个索引中都不相同。某些类型彼此兼容（<code>integer</code>和<code>long</code>或<code>float</code>和<code>double</code>），但是当类型混合使用十进制数和非十进制数时，terms聚合会将非十进制数提升为十进制数。这可能会导致数值的精度下降</p>
</blockquote>
<h3 id="9-API"><a href="#9-API" class="headerlink" title="9. API"></a>9. API</h3><p>本来想在这写下聚合的 <code>API</code>，但发现单独扯出来不太完整。后续单独写下 <code>restHighClient</code> 的基本用法吧。</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch-7.17 源码环境搭建</title>
    <url>/2022/03/18/Elasticsearch-7.17%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><p>本次我选择的环境是 <code>7.X</code> 中目前最新的 <code>7.17</code> 版本，代码下载下来之后，需要关注的文件有以下三个：</p>
<ul>
<li><a href="https://github.com/elastic/elasticsearch/blob/7.17/CONTRIBUTING.md" target="_blank" rel="noopener">CONTRIBUTING.md</a></li>
<li><a href="https://github.com/elastic/elasticsearch/blob/7.17/gradle.properties" target="_blank" rel="noopener">gradle.properties</a></li>
<li><a href="https://github.com/elastic/elasticsearch/blob/7.17/gradle/wrapper/gradle-wrapper.properties" target="_blank" rel="noopener">gradle-wrapper.properties</a></li>
</ul>
<p><code>CONTRIBUTING.md</code> 中的 <code>Contributing to the Elasticsearch codebase</code>部分详细说明了需要的 <code>JDK</code> 版本，<a id="more"></a>而后面的两个 <code>Ggradle</code> 文件中则声明了对应分支所使用的 <code>Gradle</code> 版本，以及一些额外的要求（其它版本的要求类似，都可以在这些文档中找到），以下为从上述文件中获取到的 <code>7.17</code> 的环境要求信息：</p>
<ul>
<li><code>JDK 16</code>（因为在 <a href="https://github.com/elastic/elasticsearch/blob/7.17/gradle.properties" target="_blank" rel="noopener">gradle.properties</a> 文件中明确提到 <code>--add-exports</code>需要 <code>working with jdk16</code>）；</li>
<li><code>GRADLE_USER_HOME</code>，环境变量，用于指定依赖的下载位置；</li>
<li><code>gradle-7.4.1</code> ，在 <a href="https://github.com/elastic/elasticsearch/blob/7.17/gradle/wrapper/gradle-wrapper.properties" target="_blank" rel="noopener">gradle-wrapper.properties</a>中有详细描述，最好的方式是使用 <code>./gradlew</code> 或者<code>gradlew.bat</code> ，它们会自动下载 wrapper文件中对应版本的 <code>gradle</code>，并存放到 <code>GRADLE_USER_HOME</code> 中；</li>
</ul>
<h1 id="导入项目到-IDEA-中"><a href="#导入项目到-IDEA-中" class="headerlink" title="导入项目到 IDEA 中"></a>导入项目到 IDEA 中</h1><p>此部分在 <code>Contributing.md</code> 中也有详细的描述，并说明了要求的最低  <code>idea</code> 的版本为  <code>2020.1</code>（很贴心，每个版本的分支中都有），下面为 7.17 版本的操作步骤：</p>
<ul>
<li>选择 <strong>File &gt; Open</strong></li>
<li>在子窗口中，选择源代码根目录所在的  <code>build.gradle</code> 文件</li>
<li>在子窗口中选择  <strong>Open as Project</strong></li>
<li>选择 <strong>File &gt; Project Structure</strong>，设置项目的 <code>SDK</code> 为 <code>JDK16</code></li>
</ul>
<p><img src="C:\Users\14452\AppData\Roaming\Typora\typora-user-images\image-20220319170442856.png" alt="image-20220319170442856"></p>
<blockquote>
<p>张超老师的源码书中，6.3左右的版本中需要先执行 <code>./gradlew idea</code> 再进行导入，目前使用该命令时会提示已经过时</p>
</blockquote>
<h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><p>等待 <code>Gradle</code> 下载完依赖包之后，我们就可以开始启动项目了，具体的程序入口在 <code>server</code> 目录下的 <code>org.elasticsearch.bootstrap.Elasticsearch#main</code> 方法里。这里我们需要针对启动做一些额外配置：</p>
<p>首先在 <code>idea</code> 的 <strong>run &gt; Edit Configuration</strong> 中新建一个 <code>Application</code> ，设置名称为 <code>local</code> 以及对应的 <code>SDK</code></p>
<p><img src="C:\Users\14452\AppData\Roaming\Typora\typora-user-images\image-20220319171719577.png" alt="image-20220319171719577"></p>
<p>设置模块名为 <code>elasticsearch.server.main</code>（不先设置的话 <code>Main class</code> 会找不到指定类），设置<code>Main class</code> 为 <code>org.elasticsearch.bootstrap.Elasticsearch</code>，同时找到 <code>Modify options</code>，将 <code>add vm options</code> 选中（我用的 <code>idea2021.3</code> 版本默认是隐藏了的）</p>
<p><img src="C:\Users\14452\AppData\Roaming\Typora\typora-user-images\image-20220319172804255.png" alt="image-20220319172804255"></p>
<p><strong>vm options</strong> 一栏的具体内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Des.path.home=I:\eshome</span><br><span class="line">-Des.path.conf=I:\eshome\config</span><br><span class="line">-Dlog4j2.disable.jmx=true</span><br><span class="line">-Djava.security.policy=I:\eshome\config\elasticsearch.policy</span><br><span class="line">-Xms1g</span><br><span class="line">-Xmx1g</span><br></pre></td></tr></table></figure>
<p>在解释这些信息前，我们需要创建一个 eshome 目录（名称随意，可以在你电脑磁盘任意位置），ES 在启动时需要从中加载配置、模块，并向该目录写入相关日志信息。然后我们还需要向其中拷贝一些必要的模块和配置文件。获取这些文件的方式有以下两种：</p>
<ul>
<li>选择官方发布包对应版本，解压后将 <code>config</code>、<code>modules</code>、<code>plugins</code> 目录复制到 <code>eshome</code> 目录中，<strong>注意修改 elasticsearch.yml 中的配置</strong></li>
<li>参考 <code>README</code> 中的说明自行编译，然后拷贝到 <code>eshome</code> 目录中，<strong>注意修改 elasticsearch.yml 中的配置</strong>。运行 <code>./gradlew localDistro</code> 之后即可根据自己当前的操作系统编译出对应的包，例如我是 windows系统，可以在 <code>distribution/archives/windows-zip</code>中找到编译完成的文件。</li>
</ul>
<p>现在我们来细看下 vm options 中各参数的含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Des.path.home</td>
<td>指定 eshome 所在的路径名</td>
</tr>
<tr>
<td>-Des.path.conf</td>
<td>指定配置文件的位置，ES 启动时会使用该目录下的配置文件</td>
</tr>
<tr>
<td>-Djava.security.policy</td>
<td>指定自定义 policy 文件的位置</td>
</tr>
<tr>
<td>-Dlog4j2.disable.jmx</td>
<td>不加此参数倒也能启动，不过控制台中会多出一些 access denied的错误</td>
</tr>
<tr>
<td>-Xms、-Xmx</td>
<td>最小堆内存、最大堆内存设置</td>
</tr>
</tbody>
</table>
<p>除上述信息外，我们还需要手动创建一个名为 <strong>elasticsearch.policy</strong> 的文件，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">	permission javax.management.MBeanTruxtPermission &quot;register&quot;;</span><br><span class="line">	permission javax.management.MBeanServerPermission &quot;createMBeanServer&quot;;</span><br><span class="line">	permission java.lang.RuntimePermission &quot;createClassLoader&quot;;</span><br><span class="line">	permission java.lang.RuntimePermission &quot;getClassLoader&quot;;</span><br><span class="line">	permission java.lang.RuntimePermission &quot;setContextClassLoader&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不同版本下会存在一些区别，启动时如果缺少 <code>permission</code> （例如将上述的最后一行删掉）会报类似如下的错误，将其添加到 <code>policy</code> 文件中即可，本质原因是由于 <code>ES</code> 自定义了代码安全策略，并在自己的 <code>security.policy</code> 文件中进行管理。而我们在调试时 <code>idea</code> 是使用的自行编译的 <code>class</code> 文件，详情可参考这篇文章 <a href="https://www.cnblogs.com/wufengtinghai/p/14579618.html" target="_blank" rel="noopener">elasticsearch之自定义Java代码的安全策略管理</a>。</p>
<p><img src="C:\Users\14452\AppData\Roaming\Typora\typora-user-images\image-20220319183326218.png" alt="image-20220319183326218"></p>
<p>配置好自定义的 <code>policy</code> 文件之后，我们还需要在 <code>server</code> 模块的 <code>resouces</code> 目录下找到源码中携带的 <code>security.policy</code>文件</p>
<p><img src="C:\Users\14452\AppData\Roaming\Typora\typora-user-images\image-20220319185038146.png" alt="image-20220319185038146"></p>
<p>注释掉 <code>codebase.elasticsearch-secure-sm</code> ，<code>codebase.elasticsearch</code>，<code>codebase.elasticsearch-plugin-classloader</code> 三处的权限配置，否则在启动时你会看到如下报错信息= =。（这里的原因是，此部分配置是针对打包后的设置，而我们在调试运行时，只有 <code>classes</code> 文件，所以会识别不到，详情也可参考社区里的提问<a href="https://elasticsearch.cn/question/11513" target="_blank" rel="noopener">idea运行es报Unknown codebases异常</a>）</p>
<p><img src="C:\Users\14452\AppData\Roaming\Typora\typora-user-images\image-20220319185342039.png" alt="image-20220319185342039"></p>
<p>到这里，我们的环境就配置完成了，点击启动，就能看到调试运行单机版的 <code>ES</code> 了</p>
<p><img src="C:\Users\14452\AppData\Roaming\Typora\typora-user-images\image-20220319211949574.png" alt="image-20220319211949574"></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://book.douban.com/subject/30386800/" target="_blank" rel="noopener">《Elasticsearch源码解析与优化实战 》</a></li>
<li><a href="https://www.cnblogs.com/wufengtinghai/p/14579618.html" target="_blank" rel="noopener">elasticsearch之自定义Java代码的安全策略管理</a></li>
<li><a href="https://elasticsearch.cn/question/11513" target="_blank" rel="noopener">idea运行es报Unknown codebases异常</a></li>
<li>官方仓库，Contributing、Readme 等文档内容</li>
</ul>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ES基础--常用知识梳理</title>
    <url>/2020/07/05/ES%E5%9F%BA%E7%A1%80--%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h4 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h4><p><strong>PUT 和 POST 的区别：</strong></p>
<p>相对来说<code>PUT</code>偏向于创建，<code>POST</code> 偏向于更新，其实使用场景不同。在索引（<code>indexing</code>）数据时，<code>PUT</code> 需要指定 <code>id</code> ，<code>POST</code> 可以自动生成。</p>
<p>CRUD的API使用示例及区别：<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看索引</span><br><span class="line">GET _cat/indices</span><br><span class="line"></span><br><span class="line">#索引文档，已有id的会删除重建，版本号+1</span><br><span class="line">PUT index_name/_doc/1 </span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot;:&quot;elasticsearch&quot;,</span><br><span class="line">    &quot;comment&quot;:&quot;you know,for search&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#创建文档，已有id会报错。</span><br><span class="line">PUT index_name/_create/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot;:&quot;elasticsearch&quot;,</span><br><span class="line">    &quot;comment&quot;:&quot;you know,for search&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#创建文档，不指定id，自动生成</span><br><span class="line">POST index_name/_doc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot;:&quot;elasticsearch&quot;,</span><br><span class="line">    &quot;comment&quot;:&quot;you know,for search&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#查询</span><br><span class="line">GET index_name/_doc/1</span><br><span class="line"></span><br><span class="line">#更新，不会删除旧文档，真正的更新</span><br><span class="line">POST index_name/_update/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot;:&quot;elasticsearch&quot;,</span><br><span class="line">    &quot;comment&quot;:&quot;document update&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">DELETE index_name/_doc/1</span><br></pre></td></tr></table></figure></p>
<h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><ul>
<li><code>Master eligible</code> 节点和 <code>Master</code> 节点。<code>eligible</code> 标识该节点是否参与选举。通过设置<code>node.master=false</code>禁止。第一个节点在启动时，会将自己设置为 <code>master</code> 。每个节点都保存了集群的状态（<code>state</code>），但只有 <code>master</code> 可以进行更改（确保数据的一致性）。</li>
<li><code>DataNode</code>，存放数据的节点，负责保存分片数据。</li>
<li><p><code>Coordinating</code> 节点，负责接收 <code>client</code> 的请求，将请求分发给合适的节点。最终汇聚结果，每个节点默认都起到了<code>Coordinating Node</code>的职责。</p>
</li>
<li><p><code>Hot&amp;Warm</code> 节点，不同硬件的 <code>DataNode</code>。<code>Hot&amp;Warm</code> 架构用于降低部署成本</p>
</li>
<li><code>MachineLearning</code> 节点，机器学习节点。</li>
<li><code>TribeNode</code>，5.3后开始加入的，用于连接到不同集群，且支持当做新的集群来处理。</li>
</ul>
<table>
<thead>
<tr>
<th>节点类型</th>
<th>配置参数</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Master eligible</td>
<td>node.master</td>
<td>true</td>
</tr>
<tr>
<td>Data</td>
<td>node.data</td>
<td>true</td>
</tr>
<tr>
<td>Ingest</td>
<td>node.ingest</td>
<td>true</td>
</tr>
<tr>
<td>Coordinating</td>
<td>无</td>
<td>每个节点都是coordinating。设置其他类型全为false</td>
</tr>
<tr>
<td>MachineLearning</td>
<td>node.ml</td>
<td>true(需enable-xpack)</td>
</tr>
</tbody>
</table>
<h4 id="经常提到的-reIndex-和-alias-到底是什么？"><a href="#经常提到的-reIndex-和-alias-到底是什么？" class="headerlink" title="经常提到的 reIndex 和 alias 到底是什么？"></a>经常提到的 reIndex 和 alias 到底是什么？</h4><p><code>reIndex</code> 也称为索引重建。很多时候会遇到诸如：分片数设置错误、<code>mapping</code> 设置错误等。此时就只能选择 <code>reindex</code>，因为这些属性在创建后就不能进行修改。只能进行索引重建</p>
<h4 id="集群颜色体现了什么"><a href="#集群颜色体现了什么" class="headerlink" title="集群颜色体现了什么"></a>集群颜色体现了什么</h4><p>查看集群状态<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET _cluster/health</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>Green</code> 代表所有主副分片均正常，</li>
<li><code>Yellow</code> 代表主分片正常，有副本未能正常分配，</li>
<li><code>Red</code> 代表有主分片为正常分配，如磁盘不足时，新建了一个索引</li>
</ul>
<h3 id="分片和副本"><a href="#分片和副本" class="headerlink" title="分片和副本"></a>分片和副本</h3><p>分片是将一份数据分成多个，水平扩展存储到不同机器，提高存储量。</p>
<p>副本是将一份数据复制为两份或更多，避免数据丢失。</p>
<h4 id="搜索类型"><a href="#搜索类型" class="headerlink" title="搜索类型"></a>搜索类型</h4><ul>
<li><code>match、term、terms、constant score等.....</code></li>
<li><code>match_phrase</code></li>
<li><code>match_phrase_prefix</code></li>
<li><code>query_string</code> ,相对来说更智能，可以识别 <code>and</code> 和 <code>or</code></li>
<li><code>simple_query_string</code>，更笨重一些，无法识别 <code>and</code> 和 <code>or</code>，但可以通过 <code>default_oparator</code> 进行控制。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 假设数据有三条，elasticsearch函数、kibana函数、logstash函数。</span><br><span class="line">//query_string返回前两个</span><br><span class="line">GET search_jw_words/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;query_string&quot;: &#123;</span><br><span class="line">      &quot;default_field&quot;: &quot;content&quot;,</span><br><span class="line">      &quot;query&quot;: &quot;(elasticsearch AND 函数) OR (kibana AND 函数)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//simple——query_string三条全部返回</span><br><span class="line">GET search_jw_words/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;simple_query_string&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;elasticsearch AND 函数&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;content&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//修改默认连接参数，此时则只返回elasticsearch函数</span><br><span class="line">GET search_jw_words/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;simple_query_string&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;elasticsearch AND 函数&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;content&quot;],</span><br><span class="line">      &quot;default_operator&quot;: &quot;AND&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><code>text/keyword</code></li>
<li><code>Date</code>,建立 <code>mapping</code> 时，需要指定 <code>format</code></li>
<li><code>Integer/Floating</code></li>
<li><code>boolean</code></li>
<li><code>IPv4/IPv6</code></li>
<li>复杂类型，对象和嵌套对象。</li>
<li>特殊类型， <code>geo_point,geo_shape,percolator</code></li>
</ul>
<h3 id="mapping-和-DynamicMapping"><a href="#mapping-和-DynamicMapping" class="headerlink" title="mapping 和 DynamicMapping"></a>mapping 和 DynamicMapping</h3><p><code>mapping</code> 指的是字段的映射信息，即每个字段的数据类型，分词配置等等。<strong><code>mapping</code> 创建后，可以新加字段，但不能修改已有字段的 <code>mapping</code></strong>，要修改已有字段只能进行 <code>reindex</code> 操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT search_jw_words</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot; : &#123;</span><br><span class="line">    &quot;properties&quot; : &#123;</span><br><span class="line">      &quot;content&quot; : &#123;</span><br><span class="line">        &quot;type&quot; : &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">        &quot;fielddata&quot;: true,</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">          &quot;keyword&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;searchtime&quot; : &#123;</span><br><span class="line">        &quot;type&quot; : &quot;date&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM-dd||yyyy-MM-dd HH:mm:ss||yyyy-MM-dd HH:mm:ss.SSS||strict_date_optional_time||epoch_millis&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写入文档时，如果索引不存在，<code>es</code> 会自动创建索引。此时，使用到的 <code>mapping</code> 映射就叫做 <code>DynamicMapping</code>。但默认的 <code>DynamicMaapping</code>会出现识别错误的情况。例如地理位置类型推断错误,分词器选择错误等等。所以就需要人为定义好<code>DynamicMapping</code>，减少识别错误的问题，实际使用中，其实用的不多，还是人工定义 <code>mapping</code> 更适合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//查看某索引的mapping</span><br><span class="line">GET indexName/_mapping</span><br><span class="line"></span><br><span class="line">//控制dynamic映射的参数有三个、true、false以及strict，</span><br><span class="line">//默认值为true，false可以写入数据但不会被索引。strict会报错，禁止字段与mapping不一致。</span><br><span class="line">PUT search_jw_words/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    &quot;dynamic&quot;:&quot;strict&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="null-value"><a href="#null-value" class="headerlink" title="null_value"></a>null_value</h3><p>对于插入的字段值为 “NULL” 且需要对其进行检索时，可以使用 <code>null_value</code> （只有 <code>keyword</code> 类型支持设定 <code>null_value</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT movies</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot; : &#123;</span><br><span class="line">    &quot;properties&quot; : &#123;</span><br><span class="line">      &quot;type&quot;:&quot;keyword&quot;,</span><br><span class="line">      &quot;null_value&quot;:&quot;NULL&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="copy-to"><a href="#copy-to" class="headerlink" title="copy_to"></a>copy_to</h3><p>拷贝字段到额外的新字段上，用于满足特性的搜索需求，由于老版本的 “_all” 已经去掉，<code>copy_to</code> 可以用于实现类型的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mappoing&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;firstName&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;copy_to&quot;:&quot;fullName&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;lastName&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;copy_to&quot;:&quot;fullName&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p><code>es</code> 不提供专门的数组类型，任何类型都可以存储多个值，即每种类型都可以存储数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot;:[&quot;张三&quot;,&quot;李四&quot;],</span><br><span class="line">    &quot;age&quot;:[30,20]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多字段类型"><a href="#多字段类型" class="headerlink" title="多字段类型"></a>多字段类型</h3><p>基于不同需求情况下，可能会遇到同样的内容需要被中文检索到，也要被英文检索到。那次此时就可以使用到多字段类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT products</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mapping&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;company&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;fields&quot;:&#123;</span><br><span class="line">                    &quot;keyword&quot;:&#123;</span><br><span class="line">                        &quot;type&quot;:&quot;keyword&quot;,</span><br><span class="line">                        &quot;ignore_above&quot;:256</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;comment&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;fields&quot;:&#123;</span><br><span class="line">                    &quot;english_comment&quot;:&#123;</span><br><span class="line">                        &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                        &quot;analyzer&quot;:&quot;english&quot;,</span><br><span class="line">                        &quot;search_analyzer&quot;:&quot;english&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义分词器"><a href="#自定义分词器" class="headerlink" title="自定义分词器"></a>自定义分词器</h3><p>自定义分词器分为以下三个部分：</p>
<ul>
<li><code>charfilter</code>，增加、替换或删除字符串</li>
<li><code>tokenizer</code>，分词</li>
<li><code>filter</code>，过滤</li>
<li>组合成 <code>analyzer</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自定义分析器标准格式是：</span><br><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;analysis&quot;: &#123;</span><br><span class="line">            &quot;char_filter&quot;: &#123; ... custom character filters ... &#125;,//字符过滤器</span><br><span class="line">            &quot;tokenizer&quot;: &#123; ... custom tokenizers ... &#125;,//分词器</span><br><span class="line">            &quot;filter&quot;: &#123; ... custom token filters ... &#125;, //词单元过滤器</span><br><span class="line">            &quot;analyzer&quot;: &#123; ... custom analyzers ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">============================实例===========================</span><br><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;analysis&quot;: &#123;</span><br><span class="line">            &quot;char_filter&quot;: &#123;</span><br><span class="line">                &quot;&amp;_to_and&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;mapping&quot;,</span><br><span class="line">                    &quot;mappings&quot;: [ &quot;&amp;=&gt; and &quot;]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;my_stopwords&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;stop&quot;,</span><br><span class="line">                    &quot;stopwords&quot;: [ &quot;the&quot;, &quot;a&quot; ]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            &quot;analyzer&quot;: &#123;</span><br><span class="line">                &quot;my_analyzer&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;custom&quot;,</span><br><span class="line">                    &quot;char_filter&quot;: [ &quot;html_strip&quot;, &quot;&amp;_to_and&quot; ],</span><br><span class="line">                    &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">                    &quot;filter&quot;: [ &quot;lowercase&quot;, &quot;my_stopwords&quot; ]</span><br><span class="line">            &#125;&#125;</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">============================实例===========================</span><br><span class="line">比如自定义好的analyzer名字是my_analyzer,在此索引下的某个新增字段应用此分析器</span><br><span class="line">PUT /my_index/_mapping</span><br><span class="line">&#123;</span><br><span class="line">   &quot;properties&quot;:&#123;</span><br><span class="line">        &quot;username&quot;:&#123;</span><br><span class="line">             &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">              &quot;analyzer&quot; : &quot;my_analyzer&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">        &quot;password&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;text&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">=================插入数据====================</span><br><span class="line">PUT /my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;:&quot;The quick &amp; brown fox &quot;,</span><br><span class="line">   &quot;password&quot;:&quot;The quick &amp; brown fox &quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">====username采用自定义分析器my_analyzer,password采用默认的standard分析器==</span><br><span class="line">===验证</span><br><span class="line">GET /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;:&quot;username&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;The quick &amp; brown fox&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;:&quot;password&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;The quick &amp; brown fox&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="indexTemplate和DynamicTemplate"><a href="#indexTemplate和DynamicTemplate" class="headerlink" title="indexTemplate和DynamicTemplate"></a>indexTemplate和DynamicTemplate</h3><p>当一个索引被创建时，会按照以下步骤顺序进行：</p>
<ul>
<li>应用 <code>es</code> 默认的 <code>settings</code> 和 <code>mappings</code></li>
<li>应用 <code>order</code> 数值更低的 <code>indexTemplate</code> 的设定</li>
<li>应用 <code>order</code> 更高的 <code>indexTemplate</code> 的设定，会覆盖之前相同的属性</li>
<li>应用创建索引时，用户手动指定的 <code>settings</code> 和 <code>mappings</code>，覆盖之前相同的属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT _template/template_default</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index_patterns&quot;:[&quot;*&quot;],</span><br><span class="line">    &quot;order&quot;:0,</span><br><span class="line">    &quot;version&quot;:1,</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;number_of_shards&quot;:1,</span><br><span class="line">        &quot;number_of_replicas&quot;:1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT _template/template_test</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index_patterns&quot;:[&quot;test*&quot;],</span><br><span class="line">    &quot;order&quot;:1,</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;number_of_shards&quot;:1,</span><br><span class="line">        &quot;number_of_replicas&quot;:2</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">    //日期推断关闭，数字推断打开</span><br><span class="line">        &quot;date_detection&quot;:false,</span><br><span class="line">        &quot;numeric_detection&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查看template信息</span><br><span class="line">GET _template/template_default</span><br><span class="line">GET _template/temp*</span><br><span class="line"></span><br><span class="line">PUT testtemplate/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;someNumber&quot;:&quot;1&quot;,</span><br><span class="line">    &quot;someDate&quot;:&quot;2020/01/01&quot;</span><br><span class="line">&#125;</span><br><span class="line">GET testtemplate/_mapping</span><br><span class="line"></span><br><span class="line">PUT testmy</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;number_of_replicas&quot;:5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET testmy/_settings</span><br><span class="line">PUT testmy/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;key&quot;:&quot;value&quot;</span><br><span class="line">&#125;</span><br><span class="line">DELETE testmy</span><br><span class="line">DELETE _template/template_default</span><br><span class="line">DELETE _template/template_test</span><br><span class="line">//或</span><br><span class="line">DELETE _template/temp*</span><br></pre></td></tr></table></figure>
<p><code>DynamicTemplate</code> 用于对新字段进行模板映射，当 <code>dynamicTemplates</code> 匹配到该字段时，就会应用已经设置好的 <code>mapping</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;dynamic_templates&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;string_as_boolean&quot;:&#123;</span><br><span class="line">                &quot;match_mapping_type&quot;:&quot;string&quot;,</span><br><span class="line">                &quot;match&quot;:&quot;is*&quot;,</span><br><span class="line">                &quot;mapping&quot;:&#123;</span><br><span class="line">                    &quot;type&quot;:&quot;boolean&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;string_as_keywords&quot;:&#123;</span><br><span class="line">                &quot;match_mapping_type&quot;:&quot;string&quot;,</span><br><span class="line">                &quot;mapping&quot;:&#123;</span><br><span class="line">                    &quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;firstName&quot;:&quot;zhang&quot;</span><br><span class="line">    &quot;isMan&quot;:&quot;true&quot;</span><br><span class="line">&#125;</span><br><span class="line">GET my_index/_mapping</span><br><span class="line">DELETE my_index</span><br><span class="line"></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;dynamic_templates&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;full_name&quot;:&#123;</span><br><span class="line">                &quot;path_match&quot;:&quot;name.*&quot;,</span><br><span class="line">                &quot;path_unmatch&quot;:&quot;*.middle&quot;,</span><br><span class="line">                &quot;mapping&quot;:&#123;</span><br><span class="line">                    &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                    &quot;copy_to&quot;:&quot;full_name&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&#123;</span><br><span class="line">        &quot;first&quot;:&quot;张&quot;,</span><br><span class="line">        &quot;middle&quot;:&quot;尼古拉斯&quot;,</span><br><span class="line">        &quot;last&quot;:&quot;三&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;full_name&quot;: &quot;张三&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合总体可以分为一下几个大类别：</p>
<ul>
<li><code>bucket aggregation</code>，满足特定条件的某些聚合</li>
<li><code>metric aggregation</code>，一些数学运算，可以对文档字段进行统计分析</li>
<li><code>pipeline aggregation</code>，对其它的聚合结果进行二次聚合</li>
<li><code>Matrix aggregation</code>，支持对多个字段的操作，并提供一个结果矩阵。</li>
</ul>
<p><code>bucket</code> 可以简单理解为 <code>sql</code> 语句的 <code>group by</code> 操作，<code>metric</code> 可以理解为 <code>sql</code> 的 <code>count</code> 函数。</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ES集群滚动升级</title>
    <url>/2021/04/07/ES%E9%9B%86%E7%BE%A4%E6%BB%9A%E5%8A%A8%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="滚动升级"><a href="#滚动升级" class="headerlink" title="滚动升级"></a>滚动升级</h2><p>滚动升级即每次升级一个集群节点，但有以下的注意事项：</p>
<ul>
<li>先升级普通的数据节点，最后升级 <code>master</code> ，否则老版本的 <code>node</code> 无法加入到新版本集群中，集群就分裂开了！</li>
<li>支持滚动升级的版本为：<code>mirror</code> 版本之间，跨大版本之间只支 持 <code>5.6---&gt;6.8</code>， <code>6.8---&gt;7.2.1</code>，其余情况需要 <code>full cluster restart</code>，或者多次升级。</li>
</ul>
<h3 id="升级准备"><a href="#升级准备" class="headerlink" title="升级准备"></a>升级准备</h3><ul>
<li>检查 <code>deprecation log</code>，确认是否有使用涉及到已过期的功能，需要对数据进行变更处理的修改这部分内容！<a id="more"></a></li>
<li>必要时需修改相关应用的 <code>code</code> 和配置！</li>
<li>对使用了插件的，需要确认升级后的版本，也具有相应版本的插件，例如 <code>ik</code>！</li>
<li>升级集群之前，现在测试环境中进行。不要直接对生产环境操作！</li>
<li>通过 <code>snapshot</code> 备份好数据!</li>
</ul>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><h4 id="1-停止分片分配："><a href="#1-停止分片分配：" class="headerlink" title="1. 停止分片分配："></a>1. 停止分片分配：</h4><p>当一个节点下线时， <code>allocation</code> 的进程会等待 <code>index.unassigned.node_left.delayed_timeout</code> 默认一分钟 ，然后开始将该节点上的分片移动到其他节点上。这个过程会消耗较大的 <code>I/O</code> 资源。由于滚动升级很快就会重新启动该节点，为了避免这个过程，可以通过如下配置，停止分片的 <code>allocation</code><br>，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/shards-allocation.html" target="_blank" rel="noopener">详细说明见 Modules[shard allocation] 模块</a>。</p>
<ul>
<li><code>all</code> ,允许所有分片（主、副）的分配</li>
<li><code>primaries</code> ，只允许主分片</li>
<li><code>new_primaries</code> ，只允许新建索引的主分片分配</li>
<li><code>none</code> ，不允许所有分片分配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//primaries表示只对主分片进行allocation，确保数据不丢失，副本可以不处理。</span><br><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;persistent&quot;: &#123;</span><br><span class="line">        &quot;cluster.routing.allocation.enable&quot;: &quot;primaries&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-停止不必要的indexing操作，启用同步flush（非必要）"><a href="#2-停止不必要的indexing操作，启用同步flush（非必要）" class="headerlink" title="2. 停止不必要的indexing操作，启用同步flush（非必要）"></a>2. 停止不必要的indexing操作，启用同步flush（非必要）</h4><p> 对于无需更新，或者很少更新的数据会很有用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//检查是否有syncid 标记</span><br><span class="line">GET index_name/_stats?filter_path=**.commit&amp;level=shards </span><br><span class="line"></span><br><span class="line">//手动执行synced flush，无需等待5分钟</span><br><span class="line">POST _flush/synced</span><br><span class="line"></span><br><span class="line">//指定索引名称</span><br><span class="line">POST kimchy,elasticsearch/_flush/synced</span><br></pre></td></tr></table></figure></p>
<p>手动执行 <code>synced flush</code> 后会返回成功数量、失败数量</p>
<h4 id="3-临时停止活动中的-ML-任务（可选）"><a href="#3-临时停止活动中的-ML-任务（可选）" class="headerlink" title="3.临时停止活动中的 ML 任务（可选）"></a>3.临时停止活动中的 ML 任务（可选）</h4><h4 id="4-停止需要升级的节点"><a href="#4-停止需要升级的节点" class="headerlink" title="4.停止需要升级的节点"></a>4.停止需要升级的节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop elasticsearch.service</span><br><span class="line"></span><br><span class="line">sudo -i service elasticsearch stop</span><br><span class="line"></span><br><span class="line">//最好不要用kill -9，可能会造成某些操作来不及做</span><br><span class="line">kill $(cat pid)</span><br></pre></td></tr></table></figure>
<h3 id="5-解压或安装新版本的Elasticsearch"><a href="#5-解压或安装新版本的Elasticsearch" class="headerlink" title="5. 解压或安装新版本的Elasticsearch"></a>5. 解压或安装新版本的Elasticsearch</h3><ul>
<li>解压新版本到新的目录下，修改 <code>jvm.options</code> 设置</li>
<li>设置 <code>path.data</code>、<code>path.logs</code> 指向原来的目录，或者通过 <code>copy</code> 覆盖当前目录</li>
<li>无需设置 <code>cluster.initial_master_nodes</code>,滚动升级的节点都是加入到已经存在的集群中，所以无需设置</li>
<li>需要在每个节点设置 <code>discovery.seed_hosts</code> 或 <code>discovery.seed_providers</code>中的一个</li>
</ul>
<h3 id="6-升级插件"><a href="#6-升级插件" class="headerlink" title="6. 升级插件"></a>6. 升级插件</h3><h3 id="7-Realm-Settings"><a href="#7-Realm-Settings" class="headerlink" title="7. Realm Settings"></a>7. <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/security-settings.html#realm-settings" target="_blank" rel="noopener">Realm Settings</a></h3><h3 id="8-启动节点，并确保加入到了集群中"><a href="#8-启动节点，并确保加入到了集群中" class="headerlink" title="8.启动节点，并确保加入到了集群中"></a>8.启动节点，并确保加入到了集群中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET _cat/nodes</span><br></pre></td></tr></table></figure>
<h3 id="9-打开-shard-allocation"><a href="#9-打开-shard-allocation" class="headerlink" title="9. 打开 shard allocation"></a>9. 打开 shard allocation</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;persistent&quot;: &#123;</span><br><span class="line">    &quot;cluster.routing.allocation.enable&quot;: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-等待集群恢复"><a href="#10-等待集群恢复" class="headerlink" title="10. 等待集群恢复"></a>10. 等待集群恢复</h3><p>在升级下一个节点之前，先等待集群健康恢复为绿色。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET _cat/health?v</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在滚动升级期间，运行新版本的节点的主分片无法分配副本给具有旧版本的节点。因为新版本可能具有旧版本无法理解的其他数据格式</li>
<li>如果无法将副本分片分配给另一个节点（集群中只有一个升级的节点），则副本分片将保持未分配状态，并且状态显示为 <code>yellow</code> 是正常情况，升级第二个节点后就可以变为 green 了。</li>
<li>没有使用 <code>synced flush</code> 的分片恢复将会更慢，通过如下请求，可以查看恢复进度<blockquote>
<p>GET _cat/recovery</p>
</blockquote>
</li>
</ul>
<h3 id="11-重复上述步骤，直到整个集群升级完成、最后，重启-ML-任务"><a href="#11-重复上述步骤，直到整个集群升级完成、最后，重启-ML-任务" class="headerlink" title="11. 重复上述步骤，直到整个集群升级完成、最后，重启 ML 任务"></a>11. 重复上述步骤，直到整个集群升级完成、最后，重启 ML 任务</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/rolling-upgrades.html" target="_blank" rel="noopener">官方文档链接</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Aggregations 聚合总结</title>
    <url>/2021/05/15/Aggregations%E8%81%9A%E5%90%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="聚合分类"><a href="#聚合分类" class="headerlink" title="聚合分类"></a>聚合分类</h2><p>聚合，可以简单的理解为数据库操作中的 <code>Distinct</code>、 <code>Group By</code> ，<code>count</code>、<code>sum</code>、<code>Having</code> 等操作，当然，实际的功能还是有差别的。目前  <code>Elasticsearch</code> 中的聚合操作包含以下几种分类：</p>
<ul>
<li><code>Bucket</code> ，分桶</li>
<li><code>Metric</code> ，⼀些系列的统计⽅法，包括 <code>sum</code>、<code>max</code>、<code>min</code>、<code>avg</code> 、<code>stats</code> 等</li>
<li><code>Matrix</code>（弃用）</li>
<li><code>Pipeline</code>，针对 “聚合” 的聚合。基于其他聚合的结果集</li>
</ul>
<p>之前一直觉得聚合好难，然而真的读完，敲了两遍之后发现也就那样。。。<a id="more"></a>主要还是因为之前看到的都是 <code>bucket_selector</code>  那种复杂操作，没能理解到。</p>
<h3 id="1-Bucket-amp-Metric-聚合分析及嵌套聚合"><a href="#1-Bucket-amp-Metric-聚合分析及嵌套聚合" class="headerlink" title="1.Bucket &amp; Metric 聚合分析及嵌套聚合"></a>1.Bucket &amp; Metric 聚合分析及嵌套聚合</h3><p><code>Aggregation</code> 属于 <code>Search</code> 的 一部分。一般情况下，建议将其 <code>Size</code> 指定为 <code>0</code>，创建测试索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE /employees</span><br><span class="line">PUT /employees/</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot; : &#123;</span><br><span class="line">      &quot;properties&quot; : &#123;</span><br><span class="line">        &quot;age&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;integer&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;gender&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;job&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;text&quot;,</span><br><span class="line">          &quot;fields&quot; : &#123;</span><br><span class="line">            &quot;keyword&quot; : &#123;</span><br><span class="line">              &quot;type&quot; : &quot;keyword&quot;,</span><br><span class="line">              &quot;ignore_above&quot; : 50</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;name&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;salary&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;integer&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 添加测试数据</span><br><span class="line">PUT /employees/_bulk</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;1&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Emma&quot;,&quot;age&quot;:32,&quot;job&quot;:&quot;Product Manager&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;:35000 &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;2&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Underwood&quot;,&quot;age&quot;:41,&quot;job&quot;:&quot;Dev Manager&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;: 50000&#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;3&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Tran&quot;,&quot;age&quot;:25,&quot;job&quot;:&quot;Web Designer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;:18000 &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;4&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Rivera&quot;,&quot;age&quot;:26,&quot;job&quot;:&quot;Web Designer&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;: 22000&#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;5&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Rose&quot;,&quot;age&quot;:25,&quot;job&quot;:&quot;QA&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;:18000 &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;6&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Lucy&quot;,&quot;age&quot;:31,&quot;job&quot;:&quot;QA&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;: 25000&#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;7&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Byrd&quot;,&quot;age&quot;:27,&quot;job&quot;:&quot;QA&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;:20000 &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;8&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Foster&quot;,&quot;age&quot;:27,&quot;job&quot;:&quot;Java Programmer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;: 20000&#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;9&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Gregory&quot;,&quot;age&quot;:32,&quot;job&quot;:&quot;Java Programmer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;:22000 &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;10&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Bryant&quot;,&quot;age&quot;:20,&quot;job&quot;:&quot;Java Programmer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;: 9000&#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;11&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Jenny&quot;,&quot;age&quot;:36,&quot;job&quot;:&quot;Java Programmer&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;:38000 &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;12&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Mcdonald&quot;,&quot;age&quot;:31,&quot;job&quot;:&quot;Java Programmer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;: 32000&#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;13&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Jonthna&quot;,&quot;age&quot;:30,&quot;job&quot;:&quot;Java Programmer&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;:30000 &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;14&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Marshall&quot;,&quot;age&quot;:32,&quot;job&quot;:&quot;Javascript Programmer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;: 25000&#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;15&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;King&quot;,&quot;age&quot;:33,&quot;job&quot;:&quot;Java Programmer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;:28000 &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;16&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Mccarthy&quot;,&quot;age&quot;:21,&quot;job&quot;:&quot;Javascript Programmer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;: 16000&#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;17&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Goodwin&quot;,&quot;age&quot;:25,&quot;job&quot;:&quot;Javascript Programmer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;: 16000&#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;18&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Catherine&quot;,&quot;age&quot;:29,&quot;job&quot;:&quot;Javascript Programmer&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;: 20000&#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;19&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Boone&quot;,&quot;age&quot;:30,&quot;job&quot;:&quot;DBA&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;: 30000&#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123;  &quot;_id&quot; : &quot;20&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot; : &quot;Kathy&quot;,&quot;age&quot;:29,&quot;job&quot;:&quot;DBA&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;: 20000&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Metric"><a href="#Metric" class="headerlink" title="Metric"></a>Metric</h4><p>指标统计，使用 <code>Metric</code> 统计工资的最大值、最小值、平均值示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET employees/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;max_salary&quot;: &#123;</span><br><span class="line">      &quot;max&quot;: &#123;&quot;field&quot;: &quot;salary&quot;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;min_salary&quot;: &#123;</span><br><span class="line">      &quot;min&quot;: &#123;&quot;field&quot;: &quot;salary&quot;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;avg_salary&quot;: &#123;</span><br><span class="line">      &quot;avg&quot;: &#123;&quot;field&quot;: &quot;salary&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cardinality"><a href="#cardinality" class="headerlink" title="cardinality"></a>cardinality</h4><p>基数统计（<span style="color:red">是近似值！！！</span>），<code>cardinality</code> 聚合基于 <a href="http://static.googleusercontent.com/media/research.google.com/fr//pubs/archive/40671.pdf" target="_blank" rel="noopener">HyperLogLog ++</a> 算法。获取不同的 <code>job</code> 的数量示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET employees/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;distinct_job&quot;:&#123;</span><br><span class="line">      &quot;cardinality&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;job.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;distinct_job2&quot;:&#123;</span><br><span class="line">      &quot;cardinality&quot;: &#123;</span><br><span class="line">        &quot;script&quot;:&#123;</span><br><span class="line">          &quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">          &quot;source&quot;:&quot;doc.salary.value/doc.salary.value&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>stats</code> 返回 <code>max</code>、<code>min</code>、<code>avg</code>、<code>sum</code>、<code>count</code> ，<code>extended_stats</code> 会扩展出方差、标准偏差等更专业的统计信息；</li>
<li><code>percentiles</code>、<code>percentile_ranks</code> 返回百分比（<span style="color:red">是近似值！！！</span>）；</li>
<li><code>top_hits</code> 需作为字聚合与 <code>bucket aggs</code> 结合使用；</li>
<li><code>value_count</code>，统计某字段有值的数量，与 <code>cardinality</code> 的区别是不去重，默认忽略空值字段</li>
</ul>
<h4 id="Terms-Aggregation"><a href="#Terms-Aggregation" class="headerlink" title="Terms Aggregation"></a>Terms Aggregation</h4><p>默认只能对 <code>keyword</code> 类型进行聚合，<code>text</code> 类型的字段需要打开 <code>fielddata</code>，才能进⾏ <code>Terms Aggregation</code>（<span style="color:red">也是近似值！！！</span>）</p>
<p>Bucket Size &amp; Top Hits 使用案例：（先根据工作分组，然后查询每种工作年龄前三的人员）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET employees/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;job_bucket&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;:&quot;job.keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;:&#123;</span><br><span class="line">        &quot;old_employees&quot;:&#123;</span><br><span class="line">          &quot;top_hits&quot;:&#123;</span><br><span class="line">            &quot;size&quot;:3,</span><br><span class="line">            &quot;sort&quot;: &#123;&quot;age&quot;:&quot;desc&quot;&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># terms 聚合，使用字聚合的结果 agg_name.xxx 进行排序</span><br><span class="line">GET employees/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;job_bucket&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;:&quot;job.keyword&quot;,</span><br><span class="line">        &quot;order&quot;:&#123;&quot;salary_stats.max&quot;: &quot;desc&quot;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;:&#123;</span><br><span class="line">        &quot;salary_stats&quot;:&#123;</span><br><span class="line">          &quot;stats&quot;:&#123;&quot;field&quot;:&quot;salary&quot;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化 <code>term</code> 聚合的性能：在新建索引时，为字段 <code>mapping</code> 添加 <code>eager_global_ordinals: true</code> 参数</p>
<h4 id="Range-amp-Histogram-Aggs"><a href="#Range-amp-Histogram-Aggs" class="headerlink" title="Range&amp; Histogram Aggs"></a>Range&amp; Histogram Aggs</h4><ul>
<li>按照数字的范围进行分桶</li>
<li>在 <code>range aggs</code> 中，可以自定义 <code>key</code></li>
</ul>
<p>按照工资范围（<code>Range</code>）分桶示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET employees/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;salary_range&quot;:&#123;</span><br><span class="line">      &quot;range&quot;:&#123;</span><br><span class="line">        &quot;field&quot;:&quot;salary&quot;,</span><br><span class="line">        &quot;ranges&quot;:[</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;to&quot;:10000</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;from&quot;:10000,</span><br><span class="line">            &quot;to&quot;:20000</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;key&quot;:&quot;&gt;20000&quot;,</span><br><span class="line">            &quot;from&quot;:20000</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 多次嵌套。根据工作类型分桶，然后按照性别分桶，计算工资的统计信息</span><br><span class="line">POST employees/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;Job_gender_stats&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;job.keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;gender_stats&quot;: &#123;</span><br><span class="line">          &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;gender&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;salary_stats&quot;: &#123;</span><br><span class="line">              &quot;stats&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;salary&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照工资的间隔（<code>Histogram</code>）分桶示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Salary Histogram,工资0到10万，以 5000一个区间进行分桶</span><br><span class="line">POST employees/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;salary_histrogram&quot;: &#123;</span><br><span class="line">      &quot;histogram&quot;: &#123;</span><br><span class="line">        &quot;field&quot;:&quot;salary&quot;,</span><br><span class="line">        &quot;interval&quot;:5000,</span><br><span class="line">        &quot;min_doc_count&quot;:1,</span><br><span class="line">        &quot;extended_bounds&quot;:&#123;</span><br><span class="line">          &quot;min&quot;:0,</span><br><span class="line">          &quot;max&quot;:100000</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 按照月进行 histogram 聚合 </span><br><span class="line">&quot;date_histogram&quot; : &#123;</span><br><span class="line">    &quot;field&quot; : &quot;date&quot;,</span><br><span class="line">    &quot;calendar_interval&quot; : &quot;month&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>数据过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET shirts/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;color_filter&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;:&#123;</span><br><span class="line">          &quot;color&quot;:&quot;red&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 多 filter 过滤</span><br><span class="line">PUT /logs/_bulk?refresh</span><br><span class="line">&#123; &quot;index&quot; : &#123; &quot;_id&quot; : 1 &#125; &#125;</span><br><span class="line">&#123; &quot;body&quot; : &quot;warning: page could not be rendered&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123; &quot;_id&quot; : 2 &#125; &#125;</span><br><span class="line">&#123; &quot;body&quot; : &quot;authentication error&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123; &quot;_id&quot; : 3 &#125; &#125;</span><br><span class="line">&#123; &quot;body&quot; : &quot;warning: connection timed out&quot; &#125;</span><br><span class="line"></span><br><span class="line">GET logs/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot; : &#123;</span><br><span class="line">    &quot;messages&quot; : &#123;</span><br><span class="line">      &quot;filters&quot; : &#123;</span><br><span class="line">        &quot;filters&quot; : &#123;</span><br><span class="line">          &quot;errors&quot; :   &#123; &quot;match&quot; : &#123; &quot;body&quot; : &quot;error&quot;   &#125;&#125;,</span><br><span class="line">          &quot;warnings&quot; : &#123; &quot;match&quot; : &#123; &quot;body&quot; : &quot;warning&quot; &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-pipeline聚合"><a href="#2-pipeline聚合" class="headerlink" title="2. pipeline聚合"></a>2. pipeline聚合</h3><ul>
<li>指标型：<code>avg_bucket</code>、<code>max_bucket</code>、<code>min_bucket</code>、<code>sum_bucket</code>、<code>stats_bucket</code>、<code>extended_stats_bucket</code>。</li>
<li>百分比：<code>percentiles_bucket</code></li>
<li>特殊场景，需要在 <code>hostogram</code> 的子聚合下才能执行：<code>derivative</code> 导数聚合，<code>moving_fn</code> 、<code>cumulative_sum</code></li>
<li>特殊操作：<code>bucket_script</code>、<code>bucket_selector</code></li>
</ul>
<h4 id="min-bucket-和-stats-bucket-实例"><a href="#min-bucket-和-stats-bucket-实例" class="headerlink" title="min_bucket 和 stats_bucket 实例"></a>min_bucket 和 stats_bucket 实例</h4><p>按照工作类型分组，找出平均工资最低的工种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 通过 . 或者 &gt; 符号指定 buckets_path 来进行 pipeline 聚合</span><br><span class="line">GET employees/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;:0,</span><br><span class="line">  &quot;aggs&quot;:&#123;</span><br><span class="line">    &quot;job_bucket&quot;:&#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;job.keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;:&#123;</span><br><span class="line">        &quot;avg_salary&quot;:&#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;salary&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;salary_min_bucket&quot;:&#123;</span><br><span class="line">      &quot;min_bucket&quot;: &#123;</span><br><span class="line">        &quot;buckets_path&quot;: &quot;job_bucket.avg_salary&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;stats_salary&quot;:&#123;</span><br><span class="line">      &quot;stats_bucket&quot;: &#123;</span><br><span class="line">        &quot;buckets_path&quot;: &quot;job_bucket&gt;avg_salary&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bucket-script-实例"><a href="#bucket-script-实例" class="headerlink" title="bucket_script 实例"></a>bucket_script 实例</h4><p>计算每月的 <code>T</code>  桖销售额占总销售额的百分比</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> total_sales </span><br><span class="line">POST /sales/_search</span><br><span class="line">&#123;</span><br><span class="line">    "size": 0,</span><br><span class="line">    "aggs" : &#123;</span><br><span class="line">        "sales_per_month" : &#123;</span><br><span class="line">            "date_histogram" : &#123;</span><br><span class="line">                "field" : "date",</span><br><span class="line">                "calendar_interval" : "month"</span><br><span class="line">            &#125;,</span><br><span class="line">            "aggs": &#123;</span><br><span class="line">                "total_sales": &#123;</span><br><span class="line">                    "sum": &#123;</span><br><span class="line">                        "field": "price"</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                "t-shirts": &#123;</span><br><span class="line">                  "filter": &#123;</span><br><span class="line">                    "term": &#123;</span><br><span class="line">                      "type": "t-shirt"</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  "aggs": &#123;</span><br><span class="line">                    "sales": &#123;</span><br><span class="line">                      "sum": &#123;</span><br><span class="line">                        "field": "price"</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                "t-shirt-percentage": &#123;</span><br><span class="line">                    "bucket_script": &#123;</span><br><span class="line">                        "buckets_path": &#123;</span><br><span class="line">                          "tShirtSales": "t-shirts&gt;sales",</span><br><span class="line">                          "totalSales": "total_sales"</span><br><span class="line">                        &#125;,</span><br><span class="line">                        "script": "params.tShirtSales / params.totalSales * 100"</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bucket-selector-实例"><a href="#bucket-selector-实例" class="headerlink" title="bucket_selector 实例"></a>bucket_selector 实例</h4><p>筛选每月的销售额大于 <code>200</code> 的月份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /sales/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot;: 0,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;sales_per_month&quot; : &#123;</span><br><span class="line">            &quot;date_histogram&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;date&quot;,</span><br><span class="line">                &quot;calendar_interval&quot; : &quot;month&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;aggs&quot;: &#123;</span><br><span class="line">                &quot;total_sales&quot;: &#123;</span><br><span class="line">                    &quot;sum&quot;: &#123;</span><br><span class="line">                        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;sales_bucket_filter&quot;: &#123;</span><br><span class="line">                    &quot;bucket_selector&quot;: &#123;</span><br><span class="line">                        &quot;buckets_path&quot;: &#123;</span><br><span class="line">                          &quot;totalSales&quot;: &quot;total_sales&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;script&quot;: &quot;params.totalSales &gt; 200&quot;#这里只能使用 bucket_selector 使用 bucket_script 会报错</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与其他的 <code>pipeline</code> 管道聚合一样，<code>bucket_selector</code> 聚合在所有其他同级聚合之后执行。这意味着使用 <code>bucket_selector</code> 聚合来过滤响应中返回的存储桶不会节省运行聚合的执行时间。</p>
<h4 id="bucket-sort"><a href="#bucket-sort" class="headerlink" title="bucket_sort"></a>bucket_sort</h4><p>使用子聚合结果：当月的总销售额，降序排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /sales/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot;: 0,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;sales_per_month&quot; : &#123;</span><br><span class="line">            &quot;date_histogram&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;date&quot;,</span><br><span class="line">                &quot;calendar_interval&quot; : &quot;month&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;aggs&quot;: &#123;</span><br><span class="line">                &quot;total_sales&quot;: &#123;</span><br><span class="line">                    &quot;sum&quot;: &#123;</span><br><span class="line">                        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;sales_bucket_sort&quot;: &#123;</span><br><span class="line">                    &quot;bucket_sort&quot;: &#123;</span><br><span class="line">                        &quot;sort&quot;: [</span><br><span class="line">                          &#123;&quot;total_sales&quot;: &#123;&quot;order&quot;: &quot;desc&quot;&#125;&#125;</span><br><span class="line">                        ],</span><br><span class="line">                        &quot;size&quot;: 3</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-聚合的作用范围"><a href="#3-聚合的作用范围" class="headerlink" title="3. 聚合的作用范围"></a>3. 聚合的作用范围</h3><ul>
<li><code>ES</code> 聚合分析的默认作⽤范围是 <code>query</code> 的查询结果集</li>
<li>同时 <code>ES</code> 还⽀持以下⽅式改变聚合的作⽤范围：<code>filter</code>、<code>post_filter</code>、<code>global</code></li>
</ul>
<h4 id="filter-作用范围"><a href="#filter-作用范围" class="headerlink" title="filter 作用范围"></a>filter 作用范围</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET employees/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;old_person&quot;: &#123;</span><br><span class="line">      // filter只对当前的子聚合生效</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;from&quot;: 35</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;job_bucket&quot;: &#123;</span><br><span class="line">          &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;job.keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // all_jobs 还是针对所有数据</span><br><span class="line">    &quot;all_jobs&quot;:&#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;job.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="post-filter作用范围："><a href="#post-filter作用范围：" class="headerlink" title="post_filter作用范围："></a>post_filter作用范围：</h4><p><code>post_filter</code> 用两种应用场景：</p>
<ul>
<li>结果中再次搜索（不推荐，会导致 <code>filter_query</code> 的缓存效果失效）</li>
<li><span style="color:red">聚合后！！！，再过滤返回的 <code>hits</code> 的结果集</span></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正常情况下，hits会返回所有的文档，post_filter 将 hits 结果集也限制为大于 35 岁的员工</span><br><span class="line">GET employees/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 10,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;old_person&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;from&quot;: 35</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;job_bucket&quot;: &#123;</span><br><span class="line">          &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;job.keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;all_jobs&quot;:&#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;job.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;post_filter&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">        &quot;filter&quot;: &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;age&quot;: &#123;</span><br><span class="line">              &quot;gte&quot;: 35</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="global作用范围"><a href="#global作用范围" class="headerlink" title="global作用范围"></a>global作用范围</h4><p>尽管 <code>query</code> 已经限制了范围为 <code>35</code> 岁以上的员工，<code>global_test</code> 通过 <code>global</code> 将作用范围重新改为所有数据。（仅对当前子聚合生效）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET employees/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 10,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 35</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;old_person&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;job.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;global_test&quot;: &#123;</span><br><span class="line">      &quot;global&quot;: &#123;&#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;all_jobs&quot;: &#123;</span><br><span class="line">          &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;job.keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-tips"><a href="#4-tips" class="headerlink" title="4. tips"></a>4. tips</h3><ul>
<li>经常使用到的聚合，<code>Elasticsearch</code> 会缓存下来；</li>
<li>只返回聚合结果需要设置 <code>size:0</code></li>
<li>可以通过 <code>meta</code> 为聚合结果指定自定义的属性</li>
</ul>
<p>返回结果将会带上 <code>&quot;meta&quot;: { &quot;color&quot;: &quot;blue&quot;  }</code> </p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET /twitter/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "titles": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "title"</span><br><span class="line">      &#125;,</span><br><span class="line">      "meta": &#123;</span><br><span class="line">        "color": "blue"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>あなたが生きる、この世界に </p>
<p><img src="/images/202105/你所在的这个世界-玛修.jpg" alt="あなたが生きる、この世界に-玛修.jpg"></p>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Greenplum日志过大引起磁盘空间不足</title>
    <url>/2020/05/27/Greenplum%E6%97%A5%E5%BF%97%E8%BF%87%E5%A4%A7%E5%BC%95%E8%B5%B7%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/</url>
    <content><![CDATA[<h3 id="日志过大，引起磁盘空间不足"><a href="#日志过大，引起磁盘空间不足" class="headerlink" title="日志过大，引起磁盘空间不足"></a>日志过大，引起磁盘空间不足</h3><p>问题回顾：调度任务执行报错， <code>GreenplumPooledSQLException：.........No space left on device (seg0 172.16.252.39:40000 pid=xxxxx)</code>.</p>
<p><img src="/images/202005/nospace.png" alt="image"></p>
<p>登录服务器，查看磁盘情况，发现占用率已经高达100%：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@tdh39 ~]# df -h</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/centos-root  592G  592G   20K  100% /</span><br><span class="line">devtmpfs                  32G     0   32G    0% /dev</span><br><span class="line">tmpfs                     32G     0   32G    0% /dev/shm</span><br><span class="line">tmpfs                     32G  533M   31G    2% /run</span><br><span class="line">tmpfs                     32G     0   32G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1               1014M  169M  845M   17% /boot</span><br><span class="line">tmpfs                    6.3G   40K  6.3G    1% /run/user/0</span><br><span class="line">tmpfs                    6.3G     0  6.3G    0% /run/user/988</span><br><span class="line">tmpfs                    6.3G     0  6.3G    0% /run/user/1003</span><br></pre></td></tr></table></figure>
<p>切换到根目录后，执行 <code>du -sh</code>，发现<code>data</code>目录占用高达<code>581G</code>：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@tdh39 ~]# cd /</span><br><span class="line">[root@tdh39 /]# du -sh *</span><br><span class="line">0	bin</span><br><span class="line">137M	boot</span><br><span class="line">581G	data</span><br><span class="line">0	dev</span><br><span class="line">37M	etc</span><br><span class="line">143M	hadoop</span><br><span class="line">3.8G	home</span><br><span class="line">.......</span><br></pre></td></tr></table></figure></p>
<p>进一步跟踪目录占用后，发现目录为<code>gp510/gpdata</code>，而<code>gpdata</code>是<code>greenplum</code>存放数据的目录。再进入到<code>pg_log</code>，发现存放了大量的<code>csv</code>格式的日志文件：</p>
<p><img src="/images/202005/pg_log1.png" alt="image"></p>
<p>在目录下发现甚至有19年的日志存在，并且由于此次从5月8日开始启用新系统的<code>ETL</code>工具，该系统的<code>ETL</code>方式大致为：</p>
<ol>
<li>查询源表数据；</li>
<li>根据源表结构和字段类型，创建临时表；</li>
<li>将源表数据插入到临时表；</li>
<li>从临时表取出数据，插入到目标表中。类似于 <code>select * from temptable into xxx</code></li>
</ol>
<p>由此看来，是因为日志未做清除策略，加上临时表很占用内存，都存放到了日志中，导致日志文件大小瞬间暴涨，连续运行几天之后，挤爆了磁盘空间。</p>
<p><img src="/images/202005/pg_log2.png" alt="image"></p>
<p>因为暂时无法修改<code>ETL</code>系统策略，只能修改<code>greenplum</code>的日志策略，调整为3天清除一次。编写如下的<code>shell</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># delete log files</span><br><span class="line">find /data/gp510/gpdata/master/gpseg-1/pg_log -mtime +3 -name &quot;*.csv&quot; -exec rm -rf &#123;&#125; \;</span><br><span class="line"># drop caches</span><br><span class="line">echo 1 &gt;  /proc/sys/vm/drop_caches;</span><br></pre></td></tr></table></figure>
<p><code>-mtime</code>代表修改时间，+3代表超过三天前的文件，为该脚本设置定时执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@tdh39 gp510]# crontab -e </span><br><span class="line"></span><br><span class="line">[root@tdh39 gp510]# crontab -l</span><br><span class="line">0  0  *  *  *  /data/gp510/log_task.sh</span><br></pre></td></tr></table></figure>
<p>保存上面的shell文件为<code>log_task.sh</code>，使用<code>crontab -e</code>进入编辑，添加一句<code>0  0  *  *  *  /data/gp510/log_task.sh</code>(每日凌晨执行)并保存。使用<code>crontab -l</code>可以查看该调度。</p>
<p>重启<code>crontab</code>使配置时生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@tdh39 gp510]# service crond restart</span><br></pre></td></tr></table></figure>
<h3 id="查询缓存不足-statement-mem"><a href="#查询缓存不足-statement-mem" class="headerlink" title="查询缓存不足 statement_mem"></a>查询缓存不足 statement_mem</h3><p>设置每个查询在segment主机中可用的内存，默认125M。当扫描一张分区特别多的表时，会出现该错误ERROR: insufficient memory reserved for statement (memquota.c:228)<br>解决方法，可以通过修改配置文件并重启集群，也可以通过如下方式修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su gpadmin</span><br><span class="line">gpconfig -c statement_mem  -v 256MB</span><br><span class="line">gpstop -u</span><br></pre></td></tr></table></figure>
<p>gp重启步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su gpadmin</span><br><span class="line">gpstop -M fast</span><br><span class="line">gpstart</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>greenplum/postgre</tag>
      </tags>
  </entry>
  <entry>
    <title>Week01总结</title>
    <url>/2021/04/10/Week01/</url>
    <content><![CDATA[<h3 id="1-检索结构复习（所有的设计都是-trade-off）"><a href="#1-检索结构复习（所有的设计都是-trade-off）" class="headerlink" title="1. 检索结构复习（所有的设计都是 trade off）:"></a>1. 检索结构复习（所有的设计都是 <code>trade off</code>）:</h3><ul>
<li><p>线性检索，数组与链表效率分析，二分查找法，对于有序数组的范围查找 <code>[x,y]</code>，先二分法定位 <code>x</code>，缩小区间后在 <code>[x,max]</code> 之间再二分找到 <code>y</code> 是比较好的方式，数组可以利用内存局部性原理加快查询，小数据量下的插入操作可以使用到内存拷贝，也不会很慢。</p>
</li>
<li><p>非线性结构，链表 <code>O(N)</code> –&gt; 二叉排序树 <code>(OlogN)</code>，是为了增加链表的检索效率。由于存在树退化的可能，引申出了 红黑树、二叉平衡树等平衡结构，<code>Set</code>、<code>Map</code>的底层就用到了红黑树；</p>
</li>
<li><p>跳表（链表的二分查找），空间换时间的一种结构。采用分层存储的方式，缩小检索范围，<a id="more"></a>大数据量下趋于 <code>O(logn)</code>，小数据量下检索效率不稳定。因为跳表在实际存储时并不是按照 <code>2^n</code> 步长维护的，否则新增节点会修改已有的大部分指针；</p>
</li>
<li><p><code>Redis</code> 为什么使用跳表实现 <code>Sorted Set</code> 操作？（严格来说，不同数据量下 <code>redis</code> 采用的数据结构是不同的，数据少时，<code>Sorted Set</code> 使用的是压缩列表）</p>
<blockquote>
<p>1.set支持范围操作，而跳表在范围查找上的效率高于红黑树。(树的局部中序遍历，不太好操作，否则就是全局中序判断是否相等)</p>
<p>2.跳表在思想上相对于红黑树来说更易理解（实现其实都不简单，并且红黑树有现成的，跳表还得自己写。。雾）</p>
<p>3.跳表更加灵活，调节步长可以灵活控制内存消耗及平衡策略。</p>
</blockquote>
</li>
<li><p><code>Hash</code> 表冲突的解决方式：开放寻址法（对比时总是被吊打，应用场景：以及位图思想，布隆过滤等），链式 <code>hash</code> 法</p>
</li>
<li><p>开发寻址法的优化策略：“双散列，求多个 <code>hash</code> 值”（布隆过滤），布隆过滤在删除一个元素时，不能直接置为0（可以采用计数法，或者定时重建）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算最优哈希函数个数的数学公式: 哈希函数个数 k = (m/n) * ln(2)。其中 m 为 bit 数组长度，n 为要存入的对象的个数。实际上，如果哈希函数个数为 1，且数组长度足够，布隆过滤器就可以退化成一个位图。所以，我们可以认为“位图是只有一个特殊的哈希函数，且没有被压缩长度的布隆过滤器</span><br></pre></td></tr></table></figure>
</li>
<li><p>倒排索引与正排索引。</p>
</li>
</ul>
<h3 id="2-文档阅读："><a href="#2-文档阅读：" class="headerlink" title="2. 文档阅读："></a>2. 文档阅读：</h3><ul>
<li><p><code>Getting started with Elasticsearch</code>，安装部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_cat/health?v</span><br><span class="line">GET /_cat/indices?v</span><br><span class="line">GET /_cat/recovery</span><br><span class="line">GET /_cat/nodes?v</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>term Aggregations，term</code> 聚合</p>
</li>
<li><p><code>Important Elasticsearch Configuration</code>，重要的设置项</p>
</li>
<li><p><code>Documents API</code> ，增删改查复习</p>
</li>
<li><p>集群升级模块</p>
</li>
<li><p><code>API conventions</code>，时间函数支持、通用参数设置等</p>
</li>
<li><p><code>IndexAPI、HEAD、delete_by_query、update_by_query、reindex</code></p>
</li>
<li><p><code>script</code> 在 <code>update、update_by_query、reindex</code> 中的应用</p>
</li>
<li><code>highlight</code> 与 <code>highlight_query</code></li>
</ul>
<h3 id="3-以前忽略的小知识总结"><a href="#3-以前忽略的小知识总结" class="headerlink" title="3. 以前忽略的小知识总结"></a>3. 以前忽略的小知识总结</h3><ul>
<li><p><code>Index,update,delete,bulk</code> 请求支持 手动刷新<code>?refresh</code>参数，可选值包含空字符串 (<code>= true</code>)，也可以设置 <code>wait_for</code> 或 <code>false</code>,默认为 <code>false</code>；</p>
</li>
<li><p><code>refresh_interval</code>  、<code>index.write.wait_for_active_shards</code> 的默认值都为1，后者表示主分片写入即返回成功。增大该参数后。如果处于正常状态的分片数量达不到要求，写入会失败；</p>
</li>
<li><p><code>GET API</code> 默认是 <code>realtime</code> 的，会查询到尚未被 <code>refresh_interval</code> 刷到磁盘的内容，通过 <code>?realtime=false</code> 参数可以关闭；</p>
</li>
<li><p><code>delete</code> 的实际删除时间，默认是在 <code>60s</code> 后。<code>index.gc_deletes</code> 可以设置该时间;</p>
</li>
<li><p><code>routing</code> 可以设置在 <code>mapping</code> 中，设置之后，请求都需要带上 <code>routing</code> 才行。在只有一个分片的情况下，该参数没有效果;</p>
</li>
<li><p><code>delete_by_query、update_by_query</code> 都可以设置 <code>routing</code>，操作指定分片上的内容，默认 <code>scroll_size</code>为<code>1000</code> ,通过 <code>slice_scroll</code> 可以分段并发的删除;</p>
</li>
<li><p>乐观并发控制<code>version</code>，新版本增加了 <code>if_seq_no</code> 、<code>if_primery_term</code>；</p>
</li>
<li><p>reindex 可以通过query、sort、size等查询参数指定范围，通过<code>ingest/pipeline</code>、<code>script</code> 进行数据处理；不支持跨大版本进行 <code>reindex</code></p>
<blockquote>
<p>version_type: external 创建缺失的文档，并更新target中版本号更低的，默认 internal</p>
<p>op_type: create 只创建缺失文档 ，默认全覆盖</p>
</blockquote>
</li>
<li><p>跨集群操作 <code>reindex</code>，需要在 <code>yml</code> 文件中增加 配置 <code>reindex.remote.whitelist: localhost:*,....</code>。此外，跨集群操作使用的堆缓冲区大小默认为100M，批量操作不能太大;</p>
</li>
<li><p><code>Search API</code>，字段映射时 <code>doc_values : false</code> 可以被搜索到，但不能用于排序聚合，<code>script</code> 操作;</p>
</li>
<li><p><code>collapse</code> 可以对结果进行折叠(可以二次折叠)，排序会影响折叠后得展示结果，<code>hits</code> 命中数是折叠之前的总数（必须是 <code>keyword</code> 或数值类型）。<code>inner_hits</code> 可以返回折叠的详细内容;</p>
<blockquote>
<p>不支持与scroll、search_after（from分页是可以的）、rescore 一起使用</p>
</blockquote>
</li>
</ul>
<h3 id="4-脚本记录"><a href="#4-脚本记录" class="headerlink" title="4. 脚本记录"></a>4. 脚本记录</h3><h4 id="1-script操作"><a href="#1-script操作" class="headerlink" title="1. script操作"></a>1. script操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT test/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;counter&quot; : 1,</span><br><span class="line">    &quot;tags&quot; : [&quot;red&quot;]</span><br><span class="line">&#125;</span><br><span class="line">//script更新</span><br><span class="line">POST test/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;:&#123;</span><br><span class="line">    &quot;source&quot;: &quot;&quot;&quot;</span><br><span class="line">    ctx._source.counter += params.count;</span><br><span class="line">    ctx._source.tags.add(params.tag);</span><br><span class="line">    if(ctx._source.tags.length==2)&#123;</span><br><span class="line">      ctx._source.tags.add(3);</span><br><span class="line">      ctx._source.tags.add(4);</span><br><span class="line">      ctx._source.tags.remove(ctx._source.tags.indexOf(&quot;red&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    ctx._source.new_field1=&apos;new_field1&apos;;</span><br><span class="line">    ctx._source.new_field9=&apos;new_field9&apos;;</span><br><span class="line">    ctx._source.remove(&apos;new_field1&apos;);</span><br><span class="line">    ctx._source.indexname=ctx._index;</span><br><span class="line">    ctx._source.type=ctx._type;</span><br><span class="line">    ctx._source.id=ctx._id;</span><br><span class="line">    ctx._source.version=ctx._version;</span><br><span class="line">    ctx._source.routing=ctx._routing;</span><br><span class="line">    if (ctx._source.tags.contains(params.tag)) &#123; ctx.op = &apos;delete&apos; &#125; else &#123; ctx.op = &apos;none&apos; &#125;</span><br><span class="line">    //_now需要格式化</span><br><span class="line">    &quot;&quot;&quot;,</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">      &quot;count&quot;:4,</span><br><span class="line">      &quot;tag&quot;: &quot;blue&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-collapse"><a href="#2-collapse" class="headerlink" title="2. collapse"></a>2. collapse</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /twitter/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;message&quot;: &quot;elasticsearch&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;collapse&quot; : &#123;</span><br><span class="line">        &quot;field&quot; : &quot;user&quot;, </span><br><span class="line">        //支持数组，多种排序返回</span><br><span class="line">        &quot;inner_hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;most_liked&quot;,  </span><br><span class="line">                &quot;size&quot;: 3,</span><br><span class="line">                &quot;sort&quot;: [&quot;likes&quot;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;most_recent&quot;, </span><br><span class="line">                &quot;size&quot;: 3,</span><br><span class="line">                &quot;sort&quot;: [&#123; &quot;date&quot;: &quot;asc&quot; &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        //innerhits本身是类似于发送了子查询的，该参数用于控制并发的数量，默认基于节点数和搜索线程池的大小判断</span><br><span class="line">        &quot;max_concurrent_group_searches&quot;: 4 </span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;sort&quot;: [&quot;likes&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>和服 <code>Alter</code> </p>
<p><img src="/images/202104/和服alter.png" alt="Alt"></p>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Week02总结</title>
    <url>/2021/04/18/Week02/</url>
    <content><![CDATA[<h2 id="1-文档学习"><a href="#1-文档学习" class="headerlink" title="1. 文档学习"></a>1. 文档学习</h2><p>本周文档阅读内容大模块为 <code>Search API</code> 和 <code>Indices API</code>，重点内容包含以下模块</p>
<ul>
<li><p><code>doc_value</code>、<code>explain</code>、<code>collaspace</code> 及 <code>index boost</code>；</p>
</li>
<li><p>特殊查询<code>rescore query、script_fields、inner_hits</code> 以及 <code>post_filter</code>  ；</p>
</li>
<li><p>分页查询  <code>from+size</code>、<code>scroll、search_after</code> ；</p>
</li>
<li><p><code>search_type</code> 之 <code>query_then_fetch</code> 、<code>dfs_query_then_fetch</code>；</p>
</li>
<li><p><code>sort</code>、<code>source_filter</code> 过滤；</p>
</li>
<li><p><code>search_template</code>、<code>explain</code> 与 <code>profile_API</code>。</p>
<a id="more"></a>
</li>
<li><p>索引操作 <code>sharink、split、rollover、open/close</code>（不常用）</p>
</li>
<li>别名 <code>index aliases</code> 与索引模板 <code>index template</code> (疑问，<code>template</code> 的 <code>version</code> 具体什么场景下使用？)</li>
<li><code>synced_flush</code> 与 <code>force_merge</code></li>
</ul>
<h2 id="2-Search-API总结"><a href="#2-Search-API总结" class="headerlink" title="2. Search API总结"></a>2. Search API总结</h2><h3 id="2-1-index、doc-values、store-的区别"><a href="#2-1-index、doc-values、store-的区别" class="headerlink" title="2.1 index、doc_values、store 的区别"></a>2.1 index、doc_values、store 的区别</h3><p><img src="/images/202104/index-doc_values-store.png" alt></p>
<h3 id="2-2-rescore-query"><a href="#2-2-rescore-query" class="headerlink" title="2.2 rescore query"></a>2.2 rescore query</h3><p>重新查询，默认与 <code>query</code>中的得分进行加法计算，使用<code>multi_rescore</code> 时，后者会看到前一个 <code>rescore</code> 算分后的结果集，所以通常会先给定一个大的 <code>window_size</code>，第二个 <code>rescore</code> 再缩小 <code>window_size</code> 的方式。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET twitter/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;query&quot; : &#123;</span><br><span class="line">      &quot;match&quot; : &#123;</span><br><span class="line">         &quot;message&quot; : &#123;</span><br><span class="line">            &quot;operator&quot; : &quot;or&quot;,</span><br><span class="line">            &quot;query&quot; : &quot;the quick brown&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;rescore&quot; : [ &#123;</span><br><span class="line">      &quot;window_size&quot; : 100,</span><br><span class="line">      &quot;query&quot; : &#123;</span><br><span class="line">         &quot;rescore_query&quot; : &#123;</span><br><span class="line">            &quot;match_phrase&quot; : &#123;</span><br><span class="line">               &quot;message&quot; : &#123;</span><br><span class="line">                  &quot;query&quot; : &quot;the quick brown&quot;,</span><br><span class="line">                  &quot;slop&quot; : 2</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;query_weight&quot; : 0.7,</span><br><span class="line">         &quot;rescore_query_weight&quot; : 1.2</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;, &#123;</span><br><span class="line">      &quot;window_size&quot; : 10,</span><br><span class="line">      &quot;query&quot; : &#123;</span><br><span class="line">         &quot;score_mode&quot;: &quot;multiply&quot;,</span><br><span class="line">         &quot;rescore_query&quot; : &#123;</span><br><span class="line">            &quot;function_score&quot; : &#123;</span><br><span class="line">               &quot;script_score&quot;: &#123;</span><br><span class="line">                  &quot;script&quot;: &#123;</span><br><span class="line">                    &quot;source&quot;: &quot;Math.log10(doc.likes.value + 2)&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-script-fields的取值方式"><a href="#2-3-script-fields的取值方式" class="headerlink" title="2.3 script_fields的取值方式"></a>2.3 script_fields的取值方式</h3><p><code>script_fields</code> 有两种取值方式 ,<code>doc[&#39;my_field&#39;].value</code>的方式会通过 <code>term</code> 加载整个字段到缓存中，使得 <code>script</code> 的执行更快，但占用的内存也更多，<strong>同时这种写法也只支持简单的值字段，无法取到 <code>JSON Object</code> 对象</strong>。官方的推荐做法仍旧是使用 <code>doc[...]</code>，因为<code>params[&#39;_source&#39;][&#39;my_field&#39;]</code> 的方式在每次处理时都会去加载 <code>_source</code>,执行会慢很多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST test/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;request&quot;:&#123;</span><br><span class="line">    &quot;uri&quot;:&quot;http://www.baidu.com&quot;,</span><br><span class="line">    &quot;param&quot;:&#123;</span><br><span class="line">      &quot;id&quot;:&quot;1&quot;,</span><br><span class="line">      &quot;name&quot;:&quot;测试&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//查询会失败，无法获取</span><br><span class="line">GET test/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;script_fields&quot;: &#123;</span><br><span class="line">    &quot;test1&quot;: &#123;</span><br><span class="line">      &quot;script&quot;: &#123;</span><br><span class="line">        &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">        //查询会失败，无法取到request对象</span><br><span class="line">        &quot;source&quot;: &quot;doc[&apos;request&apos;].value&quot;</span><br><span class="line">        //可以使用如下方式, value 可以不需要，text字段需要指定fielddata或keyword</span><br><span class="line">        //&quot;source&quot;: &quot;doc[&apos;request.uri.keyword&apos;]&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方式二可以取到 json object</span><br><span class="line">GET test/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;script_fields&quot;: &#123;</span><br><span class="line">    &quot;test2&quot;: &#123;</span><br><span class="line">      &quot;script&quot;: &#123;</span><br><span class="line">        &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">        &quot;source&quot;: &quot;params[&apos;_source&apos;][&apos;request&apos;]&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-post-filter"><a href="#2-4-post-filter" class="headerlink" title="2.4 post_filter"></a>2.4 post_filter</h3><p>应用场景：</p>
<ul>
<li>结果中再次搜索（不推荐，会导致 <code>filter_query</code> 的缓存效果失效）</li>
<li>聚合后过滤返回的 <code>hits</code> 的结果集</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 索引定义、数据初始化</span><br><span class="line">DELETE shirts</span><br><span class="line">PUT shirts</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;brand&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;color&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;model&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST _bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;shirts&quot;,&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;brand&quot;:&quot;gucci&quot;,&quot;color&quot;:&quot;red&quot;,&quot;model&quot;:&quot;slim&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;shirts&quot;,&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;brand&quot;:&quot;gucci&quot;,&quot;color&quot;:&quot;black&quot;,&quot;model&quot;:&quot;slim&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;shirts&quot;,&quot;_id&quot;:&quot;3&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;brand&quot;:&quot;gucci&quot;,&quot;color&quot;:&quot;black&quot;,&quot;model&quot;:&quot;ntrms&quot;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果中再次搜索-post-fiter"><a href="#结果中再次搜索-post-fiter" class="headerlink" title="结果中再次搜索 post_fiter"></a>结果中再次搜索 post_fiter</h4><blockquote>
<p>用户第一次搜索 <code>gucci</code>、基于第一次的结果中，再次搜索颜色为 <code>red</code>，此时的查询 <code>dsl</code> 为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /shirts/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;brand&quot;: &quot;gucci&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;post_filter&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;color&quot;: &quot;red&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="post-filter-先聚合，再过滤-hits"><a href="#post-filter-先聚合，再过滤-hits" class="headerlink" title="post_filter 先聚合，再过滤 hits"></a>post_filter 先聚合，再过滤 hits</h4><p>以下 <code>dsl</code> 的查询逻辑为：先筛选所有 <code>brand</code> 为 <code>gucci</code> 的数据，然后按照 <code>model</code> 进行聚合。子聚合在父聚合的基础上，筛选颜色只为 <code>red</code> 的数据并进行二次聚合；由于此时返回的 <code>hits</code> 中包含的是父聚合中的所有数据，于是通过 <code>post_filter</code> 将其设置为只返回子聚合的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET shirts/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;brand&quot;: &quot;gucci&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;models&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;model&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;color_red&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;color&quot;: &quot;red&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;models&quot;: &#123;</span><br><span class="line">          &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;model&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;post_filter&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;color&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: &quot;red&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-from-size、scroll、search-after对比"><a href="#2-5-from-size、scroll、search-after对比" class="headerlink" title="2.5 from+size、scroll、search_after对比"></a>2.5 from+size、scroll、search_after对比</h3><ul>
<li><code>from + size</code> 适用于普通的分页查询，也不需要深度分页，支持随机翻页，数据是实时的；</li>
<li><code>scroll</code> 属于索引快照数据，通过不停地滚动查询来遍历所有数据，适合深度分页，但不具有实时性，当滚动开始后直到结束也不会发生变化；</li>
<li><code>search_after</code>，通过具备唯一性的属性来排序，按照排序值来实现翻页效果，适合深度分页，并且数据实时的。但不能进行随机翻页，只能一页一页的展示。</li>
</ul>
<p>需要注意的是 ： <code>search_after</code> 需要指定唯一字段为排序依据，否则同分值的会被过滤掉。</p>
<p>如下所示的<code>search_after</code> 是通过 <code>taxful_total_size</code> 排序后的数值进行翻页，当出现金额相同的情况时，两条数据都会被过滤掉，所以应该在 <code>sort</code> 和 <code>search_after</code> 中都加上类似 <code>id</code> 的唯一字段作区分。</p>
<p><img src="/images/202104/search_template.png" alt></p>
<h3 id="2-6-Nested、Join、Object类型的区别"><a href="#2-6-Nested、Join、Object类型的区别" class="headerlink" title="2.6 Nested、Join、Object类型的区别"></a>2.6 Nested、Join、Object类型的区别</h3><h4 id="创建映射mapping，两个字段分别为-nested-和-object"><a href="#创建映射mapping，两个字段分别为-nested-和-object" class="headerlink" title="创建映射mapping，两个字段分别为 nested 和 object"></a>创建映射mapping，两个字段分别为 nested 和 object</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT nested_object_test</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;my_object&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">          &quot;username&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;text&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;my_nested&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;nested&quot;,</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">          &quot;username&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;text&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="索引一条数据"><a href="#索引一条数据" class="headerlink" title="索引一条数据"></a>索引一条数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//采用数组格式，分别放两个字段存入一条数据</span><br><span class="line">POST nested_object_test/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;my_object&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;username&quot;: &quot;Tom smith&quot;,</span><br><span class="line">      &quot;age&quot;: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;username&quot;: &quot;William smith&quot;,</span><br><span class="line">      &quot;age&quot;: 30</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;my_nested&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;username&quot;: &quot;Tom smith&quot;,</span><br><span class="line">      &quot;age&quot;: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;username&quot;: &quot;William smith&quot;,</span><br><span class="line">      &quot;age&quot;: 30</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搜索对比"><a href="#搜索对比" class="headerlink" title="搜索对比"></a>搜索对比</h4><p>检索同时满足 <code>username = Tom ，age=30</code> 条件的数据，正常情况下是没有结果的，而 <code>object</code> 字段的检索会返回结果，其本质原因是 <code>object</code> 类型在存储时会进行扁平化处理，即上述测试数据在存储时被处理为了：</p>
<blockquote>
<p>username: [“Tom smith” , “William smith”], age: [20,30]</p>
</blockquote>
<p>使用  <code>Nested</code>  嵌套对象时则不会出现该情况，<code>Nested</code> 数据类型允许对象数组中的对象被独立索引，存储时会分为多条 <code>lucene</code> 文档 (即，上述的测试数据会分为两个隐藏文档 ，每一个都存储着对应的 <code>username</code> 和 <code>age</code> ，最后召回时进行 <code>join</code>，所以效率也相对更低)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//错误结果</span><br><span class="line">GET nested_object_test/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;my_object.username&quot;: &quot;Tom&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;my_object.age&quot;: 30</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//预期结果</span><br><span class="line">GET nested_object_test/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;nested&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;my_nested&quot;,</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">          &quot;must&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;match&quot;: &#123;</span><br><span class="line">                &quot;my_nested.username&quot;: &quot;Tom&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;term&quot;: &#123;</span><br><span class="line">                &quot;my_nested.age&quot;: 30</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Join</code>类型 的性能不太好，<code>nested</code> 与 <code>object</code> 相比性能会低几倍，<code>join</code> 在 <code>nested</code>基础上会再低几倍。</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>Object</th>
<th>Nested</th>
<th>Join</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>速度快，性能好</td>
<td>文档存储在一起，性能较好</td>
<td>父子文档独立更新，互不影响</td>
</tr>
<tr>
<td>缺点</td>
<td>不支持数组字段的组合检索</td>
<td>更新时需要整个文档一起更新</td>
<td>内存占用多，读取性能差</td>
</tr>
<tr>
<td>场景</td>
<td>不需要对 <code>object</code> 数组查询、聚合</td>
<td>查询多，子文档偶尔更新</td>
<td>子文档更新频繁</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>nested</code> 的查询。聚合都需要使用 <code>nested_query</code>;</p>
<p><code>Join</code> 需要通过 <code>parent_id</code>、<code>has_parent</code>、<code>has_child</code> 查询，且父子文档需要在同一分片上（使用<code>routing</code>）</p>
</blockquote>
<p>需要注意的是，<code>has_child</code> 查询筛选的是子文档内容，然后返回父文档，通过 <code>inner_hits</code> 可以同时返回父子文档。<code>has_child</code> 查询的相关性算分，是由命中的 <code>child</code> 影响的。同时排序方式也和常规的 sort 不同，需要通过 <code>score_mode</code> 来影响最终的父文档排序。（ <code>inner_hits</code> 中的排序可以直接使用常规 <code>sort</code> ）</p>
<ul>
<li><code>none</code> ，默认</li>
<li><code>avg、max、min、sum</code> ；分别表示根据子文档得分的平均值、最大值、最小值、求和来排序</li>
</ul>
<h4 id="Join-的语法案例："><a href="#Join-的语法案例：" class="headerlink" title="Join 的语法案例："></a><code>Join</code> 的语法案例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建索引</span><br><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;properties&quot; : &#123;</span><br><span class="line">            &quot;my-join-field&quot; : &#123;</span><br><span class="line">                &quot;type&quot; : &quot;join&quot;,</span><br><span class="line">                &quot;relations&quot;: &#123;</span><br><span class="line">                    &quot;parent&quot;: &quot;child&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 查询</span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;has_child&quot; : &#123;</span><br><span class="line">            &quot;type&quot; : &quot;child&quot;,</span><br><span class="line">            &quot;query&quot; : &#123;</span><br><span class="line">                &quot;match_all&quot; : &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;inner_hits&quot;: &#123;&#125;,</span><br><span class="line">            &quot;max_children&quot;: 10,</span><br><span class="line">            &quot;min_children&quot;: 2,</span><br><span class="line">            &quot;score_mode&quot; : &quot;min&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方文档： <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/query-dsl-has-child-query.html#has-child-query-performance" target="_blank" rel="noopener">has_child 的排序问题</a>（has_parent也类似）</p>
<h3 id="2-7-search-template-与-render-template"><a href="#2-7-search-template-与-render-template" class="headerlink" title="2.7 search_template 与 render template"></a>2.7 search_template 与 render template</h3><p><code>search_template</code> 的功能主要是用于工程代码和搜索解耦，维护人员定好 <code>search_template</code> 的基础结构和参数后，程序即可编写，当涉及到搜索调整，在参数没有更改的情况下，只需要调整  <code>template</code> 即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;shirts&quot;,&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;brand&quot;:&quot;gucci&quot;,&quot;color&quot;:&quot;red&quot;,&quot;model&quot;:&quot;slim&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;test&quot;,&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;brand&quot;:&quot;gucci&quot;,&quot;color&quot;:&quot;black&quot;,&quot;model&quot;:&quot;slim&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;test&quot;,&quot;_id&quot;:&quot;3&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;brand&quot;:&quot;gucci&quot;,&quot;color&quot;:&quot;black&quot;,&quot;model&quot;:&quot;ntrms&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;test&quot;,&quot;_id&quot;:&quot;4&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;brand&quot;:&quot;gucci&quot;,&quot;color&quot;:&quot;black&quot;,&quot;model&quot;:&quot;ntrms&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 0.直接使用search_template</span><br><span class="line">GET shirts/_search/template</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;:&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">      &quot;match&quot;:&#123;</span><br><span class="line">        &quot;&#123;&#123;my_field&#125;&#125;&quot;:&quot;&#123;&#123;my_value&#125;&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">    &quot;my_field&quot;:&quot;color&quot;,</span><br><span class="line">    &quot;my_value&quot;:&quot;black&quot;,</span><br><span class="line">    &quot;my_size&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DELETE _scripts/shirts_template</span><br><span class="line"></span><br><span class="line">#1.script存储 search_template,使用 mustache 模板语法</span><br><span class="line">POST _scripts/shirts_template</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;lang&quot;: &quot;mustache&quot;,</span><br><span class="line">    &quot;source&quot;: &#123;</span><br><span class="line">      &quot;query&quot;:&#123;</span><br><span class="line">      &quot;match&quot;:&#123;</span><br><span class="line">        &quot;&#123;&#123;my_field&#125;&#125;&quot;:&quot;&#123;&#123;my_value&#125;&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;size&quot;:&quot;&#123;&#123;my_size&#125;&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#2.使用模板（id只能在dsl里声明）</span><br><span class="line">GET _search/template</span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;:&quot;shirts_template&quot;,</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">    &quot;my_size&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;my_field&quot;:&quot;color&quot;,</span><br><span class="line">    &quot;my_value&quot;:&quot;black&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># render template 模板渲染测试</span><br><span class="line">GET _render/template</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">      &quot;match&quot;: &#123;</span><br><span class="line">        &quot;&#123;&#123;my_field&#125;&#125;&quot;: &quot;&#123;&#123;my_value&#125;&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">    &quot;my_field&quot;: &quot;color&quot;,</span><br><span class="line">    &quot;my_value&quot;: &quot;black&quot;,</span><br><span class="line">    &quot;my_size&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#或者带上模板id渲染</span><br><span class="line">GET _render/template/shirts_template</span><br><span class="line">&#123;</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">    &quot;my_field&quot;: &quot;color&quot;,</span><br><span class="line">    &quot;my_value&quot;: &quot;black&quot;,</span><br><span class="line">    &quot;my_size&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 整体渲染</span><br><span class="line">GET _render/template</span><br><span class="line">&#123;</span><br><span class="line">    &quot;source&quot;: &quot;&#123;\&quot;query\&quot;:&#123;\&quot;bool\&quot;:&#123;\&quot;must\&quot;: &#123;&#123;#toJson&#125;&#125;clauses&#123;&#123;/toJson&#125;&#125; &#125;&#125;&#125;&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">        &quot;clauses&quot;: [</span><br><span class="line">            &#123; &quot;term&quot;: &#123; &quot;user&quot; : &quot;foo&quot; &#125; &#125;,</span><br><span class="line">            &#123; &quot;term&quot;: &#123; &quot;user&quot; : &quot;bar&quot; &#125; &#125;</span><br><span class="line">        ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-indices-API-总结"><a href="#3-indices-API-总结" class="headerlink" title="3. indices API 总结"></a>3. indices API 总结</h2><p><code>open/close</code>、<code>shrink</code>、<code>split</code>、<code>rollover</code> 等API 不在考试范围内，暂且跳过。</p>
<h3 id="3-1-索引别名-index-aliases"><a href="#3-1-索引别名-index-aliases" class="headerlink" title="3.1 索引别名 index aliases"></a>3.1 索引别名 index aliases</h3><p>别名概念可以类比数据库的字段别名，起到一个昵称的作用。</p>
<ul>
<li><code>index aliases</code> 可以指定多个索引，所以也可以通过别名来检索多个 <code>index</code>；</li>
<li><code>index aliases</code> 的范围可以是整个索引，也可以是一部分数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// add 表示增加别名，remove 表示移除别名，remove_index 则等同于 delete_index</span><br><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">    &quot;actions&quot; : [</span><br><span class="line">        &#123; &quot;add&quot; : &#123; &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias1&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;remove&quot; : &#123; &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias1&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;remove_index&quot;: &#123; &quot;index&quot;: &quot;test&quot; &#125; &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">// 针对一部分数据添加别名</span><br><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">    &quot;actions&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;add&quot; : &#123;</span><br><span class="line">                 &quot;index&quot; : &quot;test1&quot;,</span><br><span class="line">                 &quot;alias&quot; : &quot;alias2&quot;,</span><br><span class="line">                 &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">// routing</span><br><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">    &quot;actions&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;add&quot; : &#123;</span><br><span class="line">                 &quot;index&quot; : &quot;test&quot;,</span><br><span class="line">                 &quot;alias&quot; : &quot;alias1&quot;,</span><br><span class="line">                 &quot;routing&quot; : &quot;1&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">// is_write_index,当一个别名对应了多个索引后，就无法使用别名来进行 index 操作了</span><br><span class="line">// 因为 es 不知道数据应该写到哪个索引下,使用 `is_write_index:true` 则可以指定。</span><br><span class="line">// 常规场景还是推荐通过index_name来进行 index操作</span><br><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">    &quot;actions&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;add&quot; : &#123;</span><br><span class="line">                 &quot;index&quot; : &quot;test&quot;,</span><br><span class="line">                 &quot;alias&quot; : &quot;alias1&quot;,</span><br><span class="line">                 &quot;is_write_index&quot; : true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;add&quot; : &#123;</span><br><span class="line">                 &quot;index&quot; : &quot;test2&quot;,</span><br><span class="line">                 &quot;alias&quot; : &quot;alias1&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">// 在索引创建时声明别名</span><br><span class="line">PUT /logs_20162801</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mappings&quot; : &#123;</span><br><span class="line">        &quot;properties&quot; : &#123;</span><br><span class="line">            &quot;year&quot; : &#123;&quot;type&quot; : &quot;integer&quot;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;aliases&quot; : &#123;</span><br><span class="line">        &quot;current_day&quot; : &#123;&#125;,</span><br><span class="line">        &quot;2016&quot; : &#123;</span><br><span class="line">            &quot;filter&quot; : &#123;</span><br><span class="line">                &quot;term&quot; : &#123;&quot;year&quot; : 2016 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 直接删除别名</span><br><span class="line">DELETE /logs_20162801/_alias/current_day</span><br><span class="line">// 通过 put 请求直接添加</span><br><span class="line">PUT /&#123;index&#125;/_alias/&#123;name&#125;</span><br><span class="line">// 查看别名</span><br><span class="line">GET /&#123;index&#125;/_alias</span><br></pre></td></tr></table></figure>
<h3 id="3-2-索引模板-index-template"><a href="#3-2-索引模板-index-template" class="headerlink" title="3.2 索引模板 index template"></a>3.2 索引模板 index template</h3><p>索引模板可以用于数据量非常大，需要进行索引生命周期管理，按日期划分索引的场景，或者想要提取多个索引之间的共同字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 索引模板样例</span><br><span class="line">PUT _template/template_1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;index_patterns&quot;: [</span><br><span class="line">    &quot;te*&quot;,</span><br><span class="line">    &quot;bar*&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;aliases&quot;: &#123;</span><br><span class="line">    &quot;alias1&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;number_of_shards&quot;: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;_source&quot;: &#123;</span><br><span class="line">      &quot;enabled&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;host_name&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;created_at&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;EEE MMM dd HH:mm:ss Z yyyy&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 增</span><br><span class="line">PUT _template/template_1</span><br><span class="line">// 删</span><br><span class="line">DELETE /_template/template_1</span><br><span class="line">// 改，执行新增操作，同名称的模板会覆盖原来的模板，新模板只对新创建的索引起效。对已经建好的历史索引不起作用</span><br><span class="line">...</span><br><span class="line">// 查</span><br><span class="line">GET /_template/template_1</span><br><span class="line"></span><br><span class="line">// 索引模板的顺序问题，这里创建了两个模板。而b的order顺序更大，那么创建logstash-b-tomcat-1时，生效的是B模板。</span><br><span class="line">PUT _template/b-template</span><br><span class="line">&#123;</span><br><span class="line">  &quot;order&quot;:1,</span><br><span class="line">  &quot;index_patterns&quot;:[&quot;logstash-b-tomcat-*&quot;,&quot;logstash-b1-tomcat-*&quot;,&quot;logstash-b2-server-*&quot;,&quot;logstash-b3-tomcat-*&quot;],</span><br><span class="line">  &quot;settings&quot;:&#123;</span><br><span class="line">    &quot;number_of_shards&quot;:&quot;5&quot;,</span><br><span class="line">    &quot;number_of_replicas&quot;:&quot;1&quot;,</span><br><span class="line">    &quot;refresh_interval&quot;:&quot;30s&quot;,</span><br><span class="line">    &quot;translog.durability&quot;:&quot;async&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT logstash-b-tomcat-1</span><br><span class="line"></span><br><span class="line">PUT _template/a-template</span><br><span class="line">&#123;</span><br><span class="line">  &quot;order&quot;:0,</span><br><span class="line">  &quot;index_patterns&quot;:[&quot;*&quot;],</span><br><span class="line">  &quot;settings&quot;:&#123;</span><br><span class="line">    &quot;number_of_shards&quot;:&quot;5&quot;,</span><br><span class="line">    &quot;number_of_replicas&quot;:&quot;0&quot;,</span><br><span class="line">    &quot;refresh_interval&quot;:&quot;30s&quot;,</span><br><span class="line">    &quot;translog.durability&quot;:&quot;async&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>索引模板其实是可以使用变量的！</strong>，以下案例中展示了动态添加别名。<code>{index}</code> 会在索引创建时替换为实际的索引名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT _template/template_1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index_patterns&quot; : [&quot;te*&quot;],</span><br><span class="line">    &quot;settings&quot; : &#123;</span><br><span class="line">        &quot;number_of_shards&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;aliases&quot; : &#123;</span><br><span class="line">        &quot;alias1&quot; : &#123;&#125;,</span><br><span class="line">        &quot;alias2&quot; : &#123;</span><br><span class="line">            &quot;filter&quot; : &#123;</span><br><span class="line">                &quot;term&quot; : &#123;&quot;user&quot; : &quot;kimchy&quot; &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;routing&quot; : &quot;kimchy&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;&#123;index&#125;-alias&quot; : &#123;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-synced-flush"><a href="#3-3-synced-flush" class="headerlink" title="3.3 synced flush"></a>3.3 synced flush</h3><p><code>sync flush</code> 是 <code>Elasticsearch</code> 提供的一种机制，当一个分片在 <code>5</code> 分钟内没有收到任何 <code>indexing</code> 操作时，会被标记为 <code>inactive</code> 非活跃状态，然后启用 <code>synced flush</code>，给每一个分配标记一个唯一的 <code>sync_id</code>,这个 <code>id</code> 在集群恢复（或者重启时）可以快速检测两个分配是否相同，在这种情况下，可以无需复制 <code>segment</code> 段文件，以加快恢复速度。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/indices-synced-flush.html" target="_blank" rel="noopener">synced_flush说明</a></p>
<p>对于无需更新，或者很少更新的数据会很有用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//检查是否有syncid 标记</span><br><span class="line">GET index_name/_stats?filter_path=**.commit&amp;level=shards </span><br><span class="line"></span><br><span class="line">//手动执行synced flush，无需等待5分钟</span><br><span class="line">POST _flush/synced</span><br><span class="line"></span><br><span class="line">//指定索引名称</span><br><span class="line">POST kimchy,elasticsearch/_flush/synced</span><br></pre></td></tr></table></figure>
<p>手动执行 <code>synced flush</code> 后会返回成功数量、失败数量</p>
<h3 id="3-4-forcemerge-段合并"><a href="#3-4-forcemerge-段合并" class="headerlink" title="3.4 forcemerge 段合并"></a>3.4 forcemerge 段合并</h3><p>对 <code>Elasticsearch</code> 的存储内容进行逐层拆解后是这样的：</p>
<p><span style="color:red">index—&gt;多shard—&gt;多lucene—–&gt; 多segment</span></p>
<p>默认情况下每一个 <code>refresh_interval</code> 产生一个 <code>segment</code>。后台也会有进程自动进行 <code>merge</code>，如下的指令表示强制进行 <code>merge，max_num_segments</code> 指定了合并后的段个数</p>
<p><code>only_expunge_deletes</code> 参数表示把标记为 <code>delete</code> 的数据进行 <code>merge</code> （可以理解为真正删除，默认会等 <code>60s</code> ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST index_name/_forcemerge?max_num_segments=1&amp;flush=true&amp;only_expunge_deletes=true</span><br></pre></td></tr></table></figure>
<p><code>index.merge.scheduler.max_thread_count：</code>  限制 <code>merge</code> 的并发线程数量，根据 <code>cpu</code> 核数修改。</p>
<p><code>index.merge.policy.expunge_deletes_allowed:</code> 可以限制段合并的阈值，当删除的比例低于该阈值时，段合并不会生效。</p>
<h2 id="4-tips"><a href="#4-tips" class="headerlink" title="4. tips"></a>4. tips</h2><ul>
<li><p><code>es 7.x</code> 为了提高性能，在命中数据大于 <code>1000</code> 时，不会返回准确的命中总数，并指出数据总量是 <code>gte 10000</code>的，设置 <code>track_total_hits:true</code> 可以解决该问题，也可以将该参数设置为一个固定的数值，<code>ES</code> 会返回 <code>gte</code> 该数值的说明；</p>
</li>
<li><p>返回 <code>version</code>，可以设置 <code>version:true</code>；</p>
</li>
<li><p><code>sort</code>  可以对数组类型进行排序，例如：返回数组的平均值。或最小值；</p>
</li>
<li><p>副本虽然影响写入速度，但是可以增加查询速度和数据安全性，因为查询可以在任一副本上获取到结果；</p>
</li>
<li><p><code>query_then_fetch</code> 与 <code>dfs_query_then_fetch</code> 都是分两阶段，从不同的分片查询 <code>X</code> 条数据，最后汇总取 <code>top X</code> 区别在于 <code>dfs</code> 方式会在第一阶段计算分布式的词频，以得到更准确的相关性得分；</p>
</li>
<li><p><code>explain API</code> 用于查看相关性算分的详情，而 <code>profile API</code> 则是用于查看每个步骤的执行耗时。</p>
</li>
<li><p>默认不需要执行，特殊情况下可以手动执行的 <code>dsl</code> 语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1.清除缓存</span><br><span class="line">POST /twitter/_cache/clear</span><br><span class="line">// 2. flush</span><br><span class="line">POST /twitter/_flush</span><br></pre></td></tr></table></figure>
<p> `，</p>
</li>
</ul>
<hr>
<p><img src="/images/202104/souji okita.png" alt="Alt"></p>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka知识点总结</title>
    <url>/2021/07/25/Kafka%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-Kafka是什么？"><a href="#1-Kafka是什么？" class="headerlink" title="1.Kafka是什么？"></a>1.Kafka是什么？</h2><p><code>kafka</code> 是一款由  <code>scala</code>  语言编写的，基于 ”发布/订阅“ 模式的高性能消息中间件。它的组成部分包括了 <code>provider</code>、<code>consumer</code>、<code>partition</code>（分区）、<code>topic</code>（主题）、<code>broker</code>（节点）几个。</p>
<p>在 <code>kafka</code> 中，<code>topic</code> 与 <code>partition</code> 之间是一对多的关系，一条消息只会发送到一个特定的  <code>topic</code> 中，随后根据 <code>kafka</code> 的负载均衡策略，分配到不同的 <code>partition</code> 中（每一个 <code>partition</code> 中的数据是有序的），而 <code>partition</code> 又分可以分为 主分区、副本分区，用于实现多个机器上的分布式存储，以此实现了高可用。</p>
<p><code>kafka</code> 的常见应用场景有两种，一种是当做常规的消息中间件来使用，另一种是作为流处理技术使用它的 <code>kafka stream</code>（未使用过）<a id="more"></a></p>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://z3.ax1x.com/2021/07/25/W2OmDS.png" alt></p>
<h2 id="2-kafka-的高性能是如何保障的"><a href="#2-kafka-的高性能是如何保障的" class="headerlink" title="2. kafka 的高性能是如何保障的"></a>2. kafka 的高性能是如何保障的</h2><p>大致有下几点，最重要和经常说的应该是 “零拷贝 + 顺序写” </p>
<ul>
<li>零拷贝，利用操作系统的优点，例如 <code>linux</code> 上的 <code>mmap</code> 与 <code>sendfile</code> ，加快数据的复制速度；</li>
<li>顺序写，可以类比 <code>mysql</code> 的 <code>redolog</code> 以及 <code>redis</code> 中的 <code>AOF</code> 日志，顺序写盘相对于磁盘随机读取来说，<code>IO</code> 效率会高上不少；</li>
<li>批量提交，<code>kafka</code> 不会为每一条消息都去写一次，会暂时等待一小波数据（<code>linger.ms</code>），或者达到批量条数后（<code>batch.size</code>），然后批量一起写。</li>
<li><p>数据压缩，<code>Kafka</code> 提供了数据压缩参数，采用数据压缩能减少数据传输量，提高效率。（题外话：个人认为压缩可以节省网络传输的耗时，但是相对的 压缩/解压 的过程也会耗时间，应该适用于网络状况不太好，或者节省 <code>broker</code> 服务器资源的场景下使用，对于 <code>consumer</code> 来说，消费速度肯定是会受到影响的）</p>
</li>
<li><p>日志分段存储，只允许写最新的段日志文件，旧的段数据只读，这样做的好处是避免文件越来越大。除此之外，<code>kafka</code> 给每个文件都保存了偏移量和索引信息，并且会将索引信息全部装入到内存中，减少磁盘 <code>IO</code> 操作。</p>
</li>
<li><code>Page Cache</code>，这一点基本上主流的中间件都会用到，在写数据时，可以只将数据写到 <code>Page Cache</code> 便返回成功，不等待执行 <code>fsync</code> 将数据刷到磁盘的过程。（这是配置项，可以加速吞吐量，但也会增加数据丢失的风险）</li>
</ul>
<h2 id="3-如何理解零拷贝？"><a href="#3-如何理解零拷贝？" class="headerlink" title="3.如何理解零拷贝？"></a>3.如何理解零拷贝？</h2><p>一般的数据从网络到磁盘，或者从磁盘到网络，都需要经过四次拷贝。比如说磁盘到网络，要经过：</p>
<p><img src="https://z3.ax1x.com/2021/07/25/W2z0cn.gif" alt></p>
<ul>
<li>磁盘到内核缓冲区</li>
<li>内核缓存区到应用缓冲区</li>
<li>应用缓冲区到内核缓存区</li>
<li>内核缓存区到网络缓冲区</li>
</ul>
<p>而零拷贝省去了第二步和第三步：</p>
<p><img src="https://z3.ax1x.com/2021/07/25/W2zsBV.gif" alt></p>
<p>直接在内核中完成了数据的拷贝，无需要再经过一次应用缓冲区的中转。</p>
<p><code>Kafka</code> 利用了两项零拷贝技术，<code>mmap</code> 和 <code>sendfile</code>。前者是用于解决网络数据落盘的，<code>Kafka</code> 直接利用内存映射，完成了“写入操作”，对于 <code>Kafka</code> 来说，完成了网络缓冲区到磁盘缓冲区的“写入”，之后强制调用 <code>flush</code>或者等操作系统自动刷盘（有参数控制）。<code>Java</code> 提供了 <code>FileChannel</code> 和  <code>MappedByteBuffer</code>两项技术来实现 <code>mmap</code>。</p>
<p><code>sendfile</code>是另外一种零拷贝实现，主要解决磁盘到网络的数据传输（数据推送）。操作系统读取磁盘数据到内存缓冲，直接丢过去<code>socket buffer</code>，而后发送出去。很多中间件，例如 <code>Nignx</code>, <code>tomcat</code> 都采用了类似的技术。</p>
<h2 id="4-kafka-的-ISR-是什么？如何工作的？"><a href="#4-kafka-的-ISR-是什么？如何工作的？" class="headerlink" title="4.kafka 的 ISR 是什么？如何工作的？"></a>4.kafka 的 ISR 是什么？如何工作的？</h2><p><code>ISR</code> 又称为分区同步队列，<code>Kafka</code> 为每个主分区维护了一个 <code>ISR</code>，处于 <code>ISR</code> 的分区意味着与主分区保持了同步（所以主分区也在 <code>ISR</code> 里面）。</p>
<p>当 <code>Producer</code> 写入消息的时候，需要等 <code>ISR</code> 里面分区的确认，当 <code>ISR</code> 确认之后，就被认为消息已经提交成功了。</p>
<p><code>ISR</code> 里面的分区会定时从主分区里面拉取数据，如果长时间未拉取，或者数据落后太多（已被取消），分区会被移出 <code>ISR</code>。<code>ISR</code> 里面分区已经同步的偏移量被称为 <code>LEO（Log End Offset）</code>，最小的 <code>LEO</code> 称为 <code>HW</code>（木桶最短的那块板），也就是消费者可以消费的最新消息。</p>
<p><img src="https://z3.ax1x.com/2021/07/25/WRCvi8.png" alt></p>
<p>当主分区挂掉的时候，会从 <code>ISR</code> 里面选举一个新的主分区出来。</p>
<p> 写入消息的时候， 我们可以在 <code>Producer</code> 里面控制 <code>ACK</code> 机制。<code>Producer</code> 可以配置成三种：</p>
<ol>
<li><code>Producer</code> 发出去就算成功；</li>
<li><code>Producer</code> 发出去，主分区写入本地磁盘就算成功；</li>
<li><code>Producer</code> 发出去，<code>ISR</code> 所有的分区都写入磁盘，就算成功；</li>
</ol>
<p>三种配置的性能依次下降，但是可靠性依次上升。</p>
<p>因为 <code>ISR</code> 里面包含了主分区，也就是说，如果整个 <code>ISR</code> 只有主分区，那么全部写入就退化为主分区写入。所以在可靠性要求非常高的情况下，我们要求 <code>ISR</code> 中分区不能少于三个。该参数可以在 <code>Broker</code> 中配置（<code>min.insync.replicas</code>）</p>
<p><code>ISR</code> 的同步机制和其它中间件机制也是类似的，在涉及主从同步的时候都要在性能和可靠性之间做取舍。通常的选项都是：</p>
<ol>
<li>主写入就认为成功</li>
<li>主写入，至少一个从写入就认为成功；</li>
<li>主写入，大部分从库写入就认为成功（一般“大部分”是可以配置的，从这个意义上来说，2 和 3 可以合并为一点）；</li>
<li>主写入，所有从库写入就认为成功；</li>
</ol>
<p>而“写入”也会有不同语义：</p>
<ol>
<li>中间件写到日志缓存就认为写入了；</li>
<li>中间件写入到系统缓存（<code>page cache</code>）就认为写入了；</li>
<li>中间件强制刷新到磁盘（发起了 <code>fsync</code>）就认为写入了；</li>
</ol>
<p>都是性能到可靠性的取舍。</p>
<p><img src="https://z3.ax1x.com/2021/07/25/WRFNqA.png" alt></p>
<h2 id="5-什么时候分区会被移出-ISR？"><a href="#5-什么时候分区会被移出-ISR？" class="headerlink" title="5.什么时候分区会被移出 ISR？"></a>5.什么时候分区会被移出 ISR？</h2><p>在旧版本中是两种情况：</p>
<ul>
<li><p>消息落后太多，由参数 <code>replica.lag.max.messages</code> 进行控制，在 <code>0.9</code> 以后就已经取消了</p>
<blockquote>
<p>为什么要删除？ 因为这个参数本身很难给出一个合适的值。以默认的值 4000 为例，对于消息流入速度很低的主题（比如 TPS 为 10 ），这个参数就没什么用；对于消息流入速度很高的主题（比如 TPS 为 2000 ），这个参数的取值又会引入 ISR 的频繁变动( ISR 需要在 Zookeeper 中维护)。所以从 0.9x 版本开始，Kafka 就彻底移除了这一个参数。</p>
</blockquote>
</li>
<li><p>分区长时间没有发起<code>fetch</code>请求，由参数 <code>replica.lag.time.max.ms</code> 控制。</p>
</li>
</ul>
<p>基本上，除非是新的 <code>Broker</code>，否则几乎都是由网络、磁盘 <code>IO</code> 和 <code>GC</code> 引起的，大多数情况下，是负载过高导致的</p>
<p>这两个参数，设置过小会导致 <code>ISR</code> 频繁变化，过大会导致可靠性降低，存在数据丢失的风险。</p>
<h2 id="6-Kafka-的负载均衡策略有哪些？"><a href="#6-Kafka-的负载均衡策略有哪些？" class="headerlink" title="6.Kafka 的负载均衡策略有哪些？"></a>6.Kafka 的负载均衡策略有哪些？</h2><p>一般来说有两种，一种是轮询，即 <code>Producer</code> 轮流挑选不同的 <code>Partition</code>；另外一种是 <code>Hash</code> 取余，这要求我们提供 <code>Key</code>。</p>
<p>选取 <code>Hash key</code> 时， 一般会根据业务 <code>id</code> 取余，或者拼接某几个字段在一起。这样一来可以将业务上的同类数据发往同一个 <code>partition</code> （也保证了顺序），缺点在于可能会导致某个分区的数据特别多，类似 <code>redis</code> 的热点 <code>key</code> 问题。</p>
<p>这些负载均衡其实都只考虑了发送端，而没有考虑到 <code>consumer</code> 的负载，假如消息分发已经很均匀了，但不同消费者之间的消费速度不一致，也有可能引起问题。</p>
<h2 id="7-为什么-Kafka-的从-Partition-不能读取？"><a href="#7-为什么-Kafka-的从-Partition-不能读取？" class="headerlink" title="7.为什么 Kafka 的从 Partition 不能读取？"></a>7.为什么 Kafka 的从 Partition 不能读取？</h2><p>首先是 <code>Kafka</code> 自身的限制，即 <code>Kafka</code> 强制要求一个 <code>Partition</code> 只能有一个 <code>Consumer</code>，因此 <code>Consumer</code> 天然只需要消费主 <code>Partition</code> 就可以。</p>
<p>那么假如说 <code>Kafka</code> 放开这种限制，比如说有多个 <code>Consumer</code>，分别从主 <code>Partition</code> 和从 <code>Partition</code> 上读取数据，那么会出现一个问题：即偏移量如何同步的问题。例如一个 <code>Consumer</code> 从 <code>Partition A</code> 读取了 <code>0 - 100</code> 的消息，那么另外一个 <code>Consumer</code> 从 <code>Partition B</code> 上读取，就只能读取 <code>100</code> 之后的数据。那么 <code>Kafka</code> 就需要在不同的 <code>Partition</code> 之间协调这个已读取偏移量。而这是分布式一致性的问题，难以解决。</p>
<p><code>MySQL</code> 的主从模式比起来，并没有这种问题，即 <code>MySQL</code> 不需要进行类似偏移量的协商。</p>
<p>而从另外一个角度来说，<code>Kafka</code> 的读取压力是远小于 <code>MySQL</code> 的，毕竟一个 <code>Topic</code>，是不会有特别多的消费者的。并且 <code>Kafka</code> 也不需要支持复杂查询，所以完全没必要读取从 <code>Partition</code> 的数据。</p>
<h2 id="8-为什么-Kafka-在消费者端采用了拉（PULL）模型？"><a href="#8-为什么-Kafka-在消费者端采用了拉（PULL）模型？" class="headerlink" title="8.为什么 Kafka 在消费者端采用了拉（PULL）模型？"></a>8.为什么 Kafka 在消费者端采用了拉（PULL）模型？</h2><p>采用拉模型的核心原因在于，消费者的消费速率不同。在拉模型之下，消费者自己消费完毕就自己再去拉一批，那么这种速率是由消费者自己控制的，所需要的控制信息也是由消费者自己保存的。而采用推模型，就意味着中间件要和消费者就速率问题进行协商，否则容易导致要么推送过快，要么推送过慢的问题。</p>
<p>推模型的一个极大的好处是避免竞争，例如在多个消费者拉同一主题的消息的时候，就需要保证，不同消费者不会引起并发问题。而 <code>Kafka</code> 不会有类似的问题，因为 <code>Kafka</code> 限制了一个 <code>Partition</code> 只能有一个消费者，所以拉模型反而更加合适。</p>
<h2 id="9-分区过多问题如何解决"><a href="#9-分区过多问题如何解决" class="headerlink" title="9.分区过多问题如何解决"></a>9.分区过多问题如何解决</h2><p>对于 <code>Producer</code> 来说，它采用的是批量发送的机制，那么分区数量多的话，就需要消耗大量的内存来维护这些缓存的消息。同时，也增大了数据丢失的风险。</p>
<p>对于 <code>Consumer</code> 来说，分区数量多意味着要么部署非常多的实例，要么开启非常多的线程，无论是哪一种方案，都是开销巨大。</p>
<p>对于 <code>Broker</code> 来说，分区特别多而对应的 <code>Broker</code> 数量又不足的话，那么意味着一个 <code>Broker</code> 上分布着大量的分区，那么一次宕机就会引起 <code>Kafka</code> 延时猛增。同时，每一个分区都要求 <code>Broker</code> 开启三个句柄，那么会引起 <code>Broker</code> 上的文件句柄被急速消耗，可能导致程序崩溃。还要考虑到，<code>Kafka</code> 虽然采用了顺序写，但是这是指在一个分区内部顺序写，在多个分区之间，是无法做到顺序写的。</p>
<p>（注意，对于 <code>Broker</code> 来说，如果你的集群规模非常大，以至于虽然有一万个分区，但是每个 <code>Broker</code> 上只有寥寥几个分区，那么分区数量对 <code>Broker</code> 来说是没影响的。我们这里的讨论，都是建立在我一个 <code>Broker</code> 上放了很多分区的基础上）</p>
<p>（分区数量和性能的关系类似一个二次函数，随着分区增长会慢慢变好，但是到达一个临界点之后，就会开始衰退）</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li>增加 <code>Broker</code>，确保 <code>Broker</code> 上不会存在很多的分区。这可以避免 <code>Broker</code> 上文件句柄数量过多，顺序写退化为随机写，以及宕机影响范围太大的问题。</li>
<li>其次可以考虑拆分 <code>Topic</code> 并且部署到不同的集群。（光是拆分没啥用， 还得加 <code>broker</code> ）</li>
</ul>
<h2 id="10-Rebalance-问题"><a href="#10-Rebalance-问题" class="headerlink" title="10.Rebalance 问题"></a>10.Rebalance 问题</h2><p><code>rebanlance</code> 通常发生在以下两种情况：</p>
<ul>
<li><code>Topic</code> 或者分区的数量变化（例如增加新的分区）</li>
<li>消费者数量变化（加入或者退出）。超时又可以细分为两个：一个是消费超时（<code>max.poll.interval.ms</code>），一个是心跳超时（<code>session.timeout.ms</code>）</li>
</ul>
<h4 id="rebanlance-的步骤："><a href="#rebanlance-的步骤：" class="headerlink" title="rebanlance 的步骤："></a>rebanlance 的步骤：</h4><ul>
<li>新的消费者向协调者上报自己的订阅信息；</li>
<li>协调者强制别的消费者发起一轮 <code>rebalance</code>，上报自己的订阅信息；</li>
<li>协调者从消费者中挑选一个 <code>leader</code>，注意这里是挑选了消费者中的 <code>leader</code>；</li>
<li>协调者将订阅信息发给 <code>leader</code>，让 <code>leader</code> 来制作分配方案；</li>
<li><code>leader</code> 上报自己的方案；</li>
<li>协调者同步方案给别的消费者</li>
</ul>
<h4 id="rebanlance-会导致的问题"><a href="#rebanlance-会导致的问题" class="headerlink" title="rebanlance 会导致的问题"></a>rebanlance 会导致的问题</h4><ol>
<li>重复消费：如果在消费者已经消费了，但是还没提交，这个时候发生了 <code>rebalance</code>，那么别的消费者可能会再一次消费；</li>
<li>影响性能：<code>rebalance</code> 的过程，一般是在几十毫秒到上百毫秒。这个过程会导致集群处于一种不稳定状态中，影响消费者的吞吐量；</li>
</ol>
<h4 id="如何避免-rebalance？"><a href="#如何避免-rebalance？" class="headerlink" title="如何避免 rebalance？"></a>如何避免 rebalance？</h4><p>首先，<code>Topic</code> 或者分区变化，引起 <code>rebalance</code> 是无法避免的，因为一般都是因为业务变化引起的。比如说，随着流量增加，我们要增加分区。</p>
<p>能够避免的就是防止消费者出现消费超时或者心跳超时。消费超时可以增大 <code>max.poll.interval.ms</code> 参数，避免被协调者踢掉。或者优化消费逻辑，使得消费者能够快速消费，拉取下一批消息</p>
<h2 id="11-事务消息问题"><a href="#11-事务消息问题" class="headerlink" title="11. 事务消息问题"></a>11. 事务消息问题</h2><p><code>Kafka</code> 的事务消息语义是：一次发送多条，要么一起成功要么一起失败。不是业务处理结果，与消息发送成功、失败绑定这种事务语义（<code>rocketmq</code>）。</p>
<p><code>rocketmq</code> 的事务消息逻辑：</p>
<ul>
<li>发送半消息，此时内容对于消费者不可见，</li>
<li>查询本地事务执行结果</li>
<li>如果本地事务执行成功（提交半消息），如果执行失败（标记半消息为删除）。如果查询超时（重试）</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/07/25/WRZZ7j.png" alt></p>
<p>要点：<code>rocketmq</code> 的半消息与普通消息其实无异，只是包装了一下，放在了特殊的队列中（不可见）提交的时候再发送到真正的队列中（延时消息有同样的思路！！！）</p>
<p><code>rocketmq</code> 的事务消息执行流程：</p>
<p><img src="https://z3.ax1x.com/2021/07/25/WRZmAs.png" alt></p>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Week04总结</title>
    <url>/2021/05/01/Week04/</url>
    <content><![CDATA[<h2 id="1-文档学习"><a href="#1-文档学习" class="headerlink" title="1. 文档学习"></a>1. 文档学习</h2><p>本周阅读了 <code>Analyzer API、ingest API、Modules</code> 三个章节，以及 <code>xpack</code> 的配置 <code>https</code> 访问部分，重点内容如下：</p>
<ul>
<li>内置分词器，以及自定义分词器；</li>
<li><code>ingest</code> 数据处理；</li>
<li><code>shard allocation</code> 与 <code>cluster allocaiton</code> ；</li>
<li>跨集群检索 <code>cross-cluster search</code>；</li>
<li><code>xpack</code> 角色配置、<code>https</code> 配置</li>
</ul>
<a id="more"></a>
<h2 id="2-Analyzer-总结"><a href="#2-Analyzer-总结" class="headerlink" title="2. Analyzer 总结"></a>2. Analyzer 总结</h2><p>分词器是对一串语句进行词语分割处理的组件，它由三个部分组成：</p>
<ul>
<li><code>char_filter</code>（针对原始文本处理，如去掉某些符号、处理 <code>html</code> 等）</li>
<li><code>tokenizer</code>按照规则，将上一步处理后的语句切分为单词</li>
<li><code>token filter</code> 将切分后的单词进行加工（如转为小写、去除停用词增加同义词等等）</li>
</ul>
<p>分词的流程也是严格按照 <code>char_filter ---&gt; tokenizer ----&gt; filter</code> 这样的顺序进行的。</p>
<p>分词测试 <code>API</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;text&quot;:     &quot;The quick brown fox.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;:  [ &quot;lowercase&quot;, &quot;asciifolding&quot; ],</span><br><span class="line">  &quot;text&quot;:      &quot;Is this déja vu?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-内置分词器"><a href="#2-1-内置分词器" class="headerlink" title="2.1 内置分词器"></a>2.1 内置分词器</h3><ul>
<li><code>standard</code> ，默认分词器，按词切分，小写处理；</li>
<li><code>simple</code>，按照非字母切分，小写处理，<code>dog&#39;s</code> 会被拆分为 <code>dog</code> 和 <code>s</code>；</li>
<li><code>stop</code>，小写处理，过滤停用词 <code>the</code>、<code>a</code>、<code>is</code> 等，<code>dog&#39;s</code> 会被拆分为 <code>dog</code> 和 <code>s</code>；</li>
<li><code>whitespace</code>，按空格拆分，不做小写处理；</li>
<li><code>keyword</code>，不分词；</li>
<li><code>pattern</code>，正则分词，例如自定义通过逗号切分；</li>
<li><code>language</code>，常见语言分词，例如 <code>english</code>；</li>
<li><code>fingerprint</code>，没看懂</li>
</ul>
<h3 id="2-2-常用内置-tokenizer"><a href="#2-2-常用内置-tokenizer" class="headerlink" title="2.2 常用内置 tokenizer"></a>2.2 常用内置 tokenizer</h3><ul>
<li><code>standard</code> 按词切分，保留数字；<code>letter</code> 按非字母拆分，不保留数字</li>
<li><code>lowercase</code>  与 <code>letter</code> 类型，新增加了转小写操作；<code>whitespace</code>  按空格拆分；</li>
<li><code>uax_url_email</code>  与 <code>standard</code> 类似，增加了识别邮箱和 <code>url</code> 等数据；</li>
<li><code>NGram Tokenizer</code>，滑动窗口分词，分词长度介于 <code>min_gram</code>只 <code>max_gram</code> 之间。</li>
<li><code>Keyword Tokenizer</code></li>
<li><code>Pattern Tokenizer</code> 正则分割</li>
<li><code>Path Hierarchy Tokenizer</code>路径切割</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokenizer"</span>: <span class="string">"path_hierarchy"</span>,</span><br><span class="line">  <span class="attr">"text"</span>: <span class="string">"/one/two/three"</span></span><br><span class="line">&#125;</span><br><span class="line">-------result--------</span><br><span class="line">[ /one, /one/two, /one/two/three ]</span><br></pre></td></tr></table></figure>
<h3 id="2-3-常用内置-token-filter"><a href="#2-3-常用内置-token-filter" class="headerlink" title="2.3 常用内置 token filter"></a>2.3 常用内置 token filter</h3><h4 id="asciifolding"><a href="#asciifolding" class="headerlink" title="asciifolding"></a>asciifolding</h4><p> <code>ASCII</code> 过滤器，去除不在 <code>ASCII</code> 中的特殊标点符号，保留大小写，示例：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [&quot;asciifolding&quot;],</span><br><span class="line">  &quot;text&quot;: &quot;Is This-&lt;déja v&apos;u&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p>分词长度过滤器。只保留长度介于 <code>min</code> 和 <code>max</code> 之间的 <code>token</code> 。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [&#123;&quot;type&quot;: &quot;length&quot;, &quot;min&quot;:1, &quot;max&quot;:3 &#125;],</span><br><span class="line">  &quot;text&quot;: &quot;Is This-&lt;déja v&apos;u&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="lowercase"><a href="#lowercase" class="headerlink" title="lowercase"></a>lowercase</h4><p>将分词统一转为小写<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [&quot;lowercase&quot;],</span><br><span class="line">  &quot;text&quot;: &quot;Is This-&lt;déja v&apos;u&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="uppercase"><a href="#uppercase" class="headerlink" title="uppercase"></a>uppercase</h4><p>将分词统一转为大写<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [&quot;lowercase&quot;],</span><br><span class="line">  &quot;text&quot;: &quot;Is This-&lt;déja v&apos;u&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ngram"><a href="#ngram" class="headerlink" title="ngram"></a>ngram</h4><p><span style="color:red">对分词结果进行再拆分</span>，然后保留长度介于 <code>min_gram</code> 和 <code>max_gram</code> 之间的词<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [&#123;&quot;type&quot;: &quot;ngram&quot;, &quot;min_gram&quot;:3, &quot;max_gram&quot;:4 &#125;],</span><br><span class="line">  &quot;text&quot;: &quot;Is This-&lt;déja v&apos;u&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="shingle"><a href="#shingle" class="headerlink" title="shingle"></a>shingle</h4><p>将分词结果进行单词组装并保留原分词结果。例如<code>[We ,love ,apple] =&gt; [We ,love ,apple, We love , love apple]</code>；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [&#123;&quot;type&quot;: &quot;shingle&quot;, &quot;min_shingle_size&quot;:2 &#125;],</span><br><span class="line">  &quot;text&quot;: &quot;Is This-&lt;déja v&apos;u&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><p>过滤停用词，支持 <code>stopwords</code> 和 <code>stopwords_path</code></p>
<h4 id="word-delimiter"><a href="#word-delimiter" class="headerlink" title="word_delimiter"></a>word_delimiter</h4><p>将分词结果再次按照 “下划线”、“横线” 等分隔符进行拆分<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;filter&quot;: [&quot;word_delimiter&quot;],</span><br><span class="line">  &quot;text&quot;: &quot;Is this-&lt;déja v&apos;u?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="multiplexer"><a href="#multiplexer" class="headerlink" title="multiplexer"></a>multiplexer</h4><p>在分词的相同 <code>position</code> 执行多个 <code>filter</code>，如果处理后的词和原词相同。则移除掉。否则保留原词和新词<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;filter&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;multiplexer&quot;,</span><br><span class="line">      &quot;filters&quot;: [</span><br><span class="line">        &quot;lowercase&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;Is This-&lt;déja v&apos;u&quot;</span><br><span class="line">&#125;</span><br><span class="line">------result-------</span><br><span class="line">[Is(is),This-&lt;déja(this-&lt;déja),v&apos;u]</span><br></pre></td></tr></table></figure></p>
<h4 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h4><p>条件过滤，下面的例子表示将长度小于 <code>5</code> 的词转为小写<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;filter&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;condition&quot;,</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &quot;lowercase&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;script&quot;: &#123;</span><br><span class="line">        &quot;source&quot;: &quot;token.getTerm().length() &lt; 5&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;Is This-&lt;déja v&apos;u&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="predicate-token-filter"><a href="#predicate-token-filter" class="headerlink" title="predicate_token_filter"></a>predicate_token_filter</h4><p>移除不满足 <code>script</code> 条件的 <code>token</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;filter&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;predicate_token_filter&quot;,</span><br><span class="line">      &quot;script&quot;: &#123;</span><br><span class="line">        &quot;source&quot;: &quot;token.getTerm().length() &gt; 5&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;Is This-&lt;déja v&apos;u&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="stemmer、snowball"><a href="#stemmer、snowball" class="headerlink" title="stemmer、snowball"></a>stemmer、snowball</h4><p>提取各种语言的词干，默认语言为<code>english</code>，去掉 <code>ing</code>、<code>ed</code> 等。两者提取的词干略有不同（例如 <code>are</code> ,<code>stemmer</code> 会提取为 <code>ar</code> ,<code>snowball</code> 则保持不变）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;filter&quot;: [&quot;stemmer&quot;],</span><br><span class="line">  &quot;text&quot;: &quot;Is This-&lt;déja doing&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="stemmer-override"><a href="#stemmer-override" class="headerlink" title="stemmer_override"></a>stemmer_override</h4><p>覆盖 <code>stemmer</code> 的自动提取词干，顺序需要在其他 <code>stemmer</code> 之前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;stemmer_override&quot;,</span><br><span class="line">      &quot;rules&quot;: [</span><br><span class="line">        &quot;doing =&gt; dddd&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;stemmer&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;What are you doing?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="keyword-marker"><a href="#keyword-marker" class="headerlink" title="keyword_marker"></a>keyword_marker</h4><p>保护  <code>token</code> 不被 <code>stemmer</code> 提取词干<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;keyword_marker&quot;,</span><br><span class="line">      &quot;keywords&quot;: [</span><br><span class="line">        &quot;doing&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;stemmer&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;What are you doing?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="kstem"><a href="#kstem" class="headerlink" title="kstem"></a>kstem</h4><p><code>english</code> 的高性能 <code>filter</code>，必须所有的词均为小写状态才能使用</p>
<h4 id="synonym"><a href="#synonym" class="headerlink" title="synonym"></a>synonym</h4><p><span style="color:red">重点！！！，同义词处理</span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;synonym&quot;,</span><br><span class="line">      &quot;synonyms&quot;: [</span><br><span class="line">        &quot;you =&gt; 你&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;What are you doing?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持同义词文件路径参数 <code>synonyms_path</code> ，文件案例如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i-pod, i pod =&gt; ipod,</span><br><span class="line">sea biscuit, sea biscit =&gt; seabiscuit</span><br><span class="line">ipod, i-pod, i pod</span><br><span class="line">foozball , foosball</span><br><span class="line">universe , cosmos</span><br><span class="line">lol, laughing out loud</span><br></pre></td></tr></table></figure></p>
<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p><span style="color:red">将 <code>token</code> 字符串翻转过来</span></p>
<h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><p>有点类似于 <code>substring</code>，将原 <code>token</code> 按照 <code>length</code> 长度进行截取。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [&#123;</span><br><span class="line">    &quot;type&quot;:&quot;truncate&quot;,</span><br><span class="line">    &quot;length&quot;:3</span><br><span class="line">  &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;What are you doing?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><p>相同的 <code>token</code> 只保留一个，设置 <code>only_on_same_position:true</code> 之后则只会移除在相同位置的，默认 <code>false</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [&quot;unique&quot;], </span><br><span class="line">  &quot;text&quot;: &quot;What are you doing? are you doing?&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [&#123;</span><br><span class="line">    &quot;type&quot;:&quot;unique&quot;,</span><br><span class="line">    &quot;only_on_same_position&quot;:true</span><br><span class="line">  &#125;], </span><br><span class="line">  &quot;text&quot;: &quot;What are you doing? are you doing?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>限制分词个数,由 <code>max_token_count</code> 控制，默认为 <code>1</code>。<code>consume_all_tokens:true</code>试了下没什么用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;filter&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;limit&quot;,</span><br><span class="line">      &quot;max_token_count&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;What are you  doing?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="keep"><a href="#keep" class="headerlink" title="keep"></a>keep</h4><p><code>keep_words</code> 只留下指定的词， <code>keep_types</code> 留下指定类型的词( 通过 <code>mode</code> 可以指定 <code>exclude</code> 模式)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [&#123;</span><br><span class="line">    &quot;type&quot;:&quot;keep&quot;,</span><br><span class="line">    &quot;keep_words&quot;:[&quot;this&quot;]</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;text&quot;: &quot;Is this 123&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;keep_types&quot;,</span><br><span class="line">      &quot;mode&quot;: &quot;exclude&quot;,</span><br><span class="line">      &quot;types&quot;: [</span><br><span class="line">        &quot;&lt;NUM&gt;&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;Is this déja v&apos;u 234&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="apostrophe"><a href="#apostrophe" class="headerlink" title="apostrophe"></a>apostrophe</h4><p>撇号处理器，去掉 <code>&#39;</code> 之后的字符，例如 <code>don&#39;t =&gt; don</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [</span><br><span class="line">    &quot;apostrophe&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;d&apos;uuuuu&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="fingerprint"><a href="#fingerprint" class="headerlink" title="fingerprint"></a>fingerprint</h4><p>对 <code>token</code> 排序并去重</p>
<h3 id="2-4-常用内容中-char-filter"><a href="#2-4-常用内容中-char-filter" class="headerlink" title="2.4 常用内容中 char filter"></a>2.4 常用内容中 char filter</h3><h4 id="html-strip-char-filter"><a href="#html-strip-char-filter" class="headerlink" title="html_strip char filter"></a>html_strip char filter</h4><p>顾名思义，在原文本基础上过滤 <code>html</code> 标签；通过 <code>escaped_tags</code> 可以自定义不需要处理的标签。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [</span><br><span class="line">    &quot;asciifolding&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;char_filter&quot;: [&#123;</span><br><span class="line">    &quot;type&quot;:&quot;html_strip&quot;,</span><br><span class="line">    &quot;escaped_tags&quot;:&quot;span&quot;</span><br><span class="line">  &#125;], </span><br><span class="line">  &quot;text&quot;: &quot;&lt;div&gt;&lt;span&gt;déja&lt;/span&gt;&lt;/div&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="mapping-char-filter"><a href="#mapping-char-filter" class="headerlink" title="mapping char filter"></a>mapping char filter</h4><p>在原文本基础上进行字符映射，例如将 <code>and</code> 转为 <code>&amp;</code> ,定义时至少要声明 <code>mappings</code> 或 <code>mappings_path</code> 中的其中一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;char_filter&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;mapping&quot;,</span><br><span class="line">      &quot;mappings&quot;: [</span><br><span class="line">        &quot;and =&gt; &amp;&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;you and me&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pattern-replace-char-filter"><a href="#pattern-replace-char-filter" class="headerlink" title="pattern replace char filter"></a>pattern replace char filter</h4><p>使用 <code>java</code> 正则表达式进行文本替换，正则写的很糟糕的话，会导致运行慢、节点宕机、<code>Stack Overflow</code> 等一系列问题。下面是一个替换数字 <code>-</code> 连接符为 <code>_</code> 的案例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;char_filter&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;pattern_replace&quot;,</span><br><span class="line">      &quot;pattern&quot;: &quot;&quot;&quot;(\d+)-(?=\d)&quot;&quot;&quot;,</span><br><span class="line">      &quot;replacement&quot;: &quot;$1_&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;text&quot;: &quot;My card is 123-456-789&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">还有个群友提问到的场景，如何将 <code>babyShoes</code> 拆分为 <code>baby</code> 和 <code>shoes</code></span>，下面是解决办法。（这里拆分后会有新问题，高亮位置不正确，因为正则映射后，原词的 <code>position</code> 位置被我们改动了）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;char_filter&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;pattern_replace&quot;,</span><br><span class="line">      &quot;pattern&quot;: &quot;&quot;&quot;(?&lt;=\p&#123;Lower&#125;)(?=\p&#123;Upper&#125;)&quot;&quot;&quot;,</span><br><span class="line">      &quot;replacement&quot;: &quot; &quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;filter&quot;: [&quot;lowercase&quot;], </span><br><span class="line">  &quot;text&quot;: &quot;The fooBarBaz method&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-跨集群检索"><a href="#3-跨集群检索" class="headerlink" title="3. 跨集群检索"></a>3. 跨集群检索</h2><p>跨集群检索允许只发送一个请求同时查询多个集群上的数据</p>
<h3 id="3-1-跨集群检索案例"><a href="#3-1-跨集群检索案例" class="headerlink" title="3.1 跨集群检索案例"></a>3.1 跨集群检索案例</h3><p>使用跨集群检索之前，需要先配置 <code>remote_server</code> ，方式如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;persistent&quot;: &#123;</span><br><span class="line">    &quot;cluster&quot;: &#123;</span><br><span class="line">      &quot;remote&quot;: &#123;</span><br><span class="line">        &quot;cluster_one&quot;: &#123;</span><br><span class="line">          &quot;seeds&quot;: [</span><br><span class="line">            &quot;127.0.0.1:9300&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;cluster_two&quot;: &#123;</span><br><span class="line">          &quot;seeds&quot;: [</span><br><span class="line">            &quot;127.0.0.1:9301&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;cluster_three&quot;: &#123;</span><br><span class="line">          &quot;seeds&quot;: [</span><br><span class="line">            &quot;127.0.0.1:9302&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置好 <code>remote_server</code> 之后就可以直接进行查询了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /twitter,cluster_one:twitter,cluster_two:twitter/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;user&quot;: &quot;kimchy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以下设置，可以选择性的跳过由于某个集群不可用，而引起的查询报错问题：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;persistent&quot;: &#123;</span><br><span class="line">    &quot;cluster.remote.cluster_two.skip_unavailable&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-cross-cluster-search-CCS-是如何工作的"><a href="#3-2-cross-cluster-search-CCS-是如何工作的" class="headerlink" title="3.2 cross-cluster search(CCS) 是如何工作的"></a>3.2 cross-cluster search(CCS) 是如何工作的</h3><p>跨集群的检索肯定会涉及到集群之间的通信，而任何网络问题或者请求延迟都会使查询变慢。为了避免 <code>cross-cluster search</code> 的慢查询问题，在发送请求时 <code>Elasticsearch</code> 提供了以下两种策略：</p>
<ul>
<li><code>Minimize network roundtrips</code>，默认情况下，<code>Elasticsearch</code> 减少远程集群之间的网络往返次数，这样可以减少网络延迟对搜索速度的影响。但是，<code>Elasticsearch</code> 不能减少大型搜索请求（例如包含 <code>Scroll</code> 或 <code>inner_hits</code> 的请求）的网络往返次数。(该分多次的还是得分多次查询….)</li>
<li><code>Don’t minimize network roundtrips</code>，对于 <code>scroll</code> 和 <code>inner_hits</code> 这类检索， <code>Elasticsearch</code> 可以通过批量 <code>outgoing</code> 和 <code>ingoing</code> 的方式来访问远程集群。通过在请求中添加 <code>?ccs_minimize_roundtrips=false</code> 参数可以关闭请求数量压缩，速度较慢，但适用于低延迟的网络环境。</li>
</ul>
<h4 id="Minimize-network-roundtrips-检索的步骤："><a href="#Minimize-network-roundtrips-检索的步骤：" class="headerlink" title="Minimize network roundtrips 检索的步骤："></a><code>Minimize network roundtrips</code> 检索的步骤：</h4><ol>
<li>将跨集群搜索请求发送到本地集群。该集群中的协调节点接收并解析该请求；</li>
</ol>
<p><img src="/images/202105/crossClusterSearch1_1.png" alt="crossClusterSearch1_1.png"></p>
<ol start="2">
<li>协调节点向每个集群发送单个搜索请求，包括其自身的搜索请求。每个集群独立执行搜索请求；</li>
</ol>
<p><img src="/images/202105/crossClusterSearch1_2.png" alt="crossClusterSearch1_2.png"></p>
<ol start="3">
<li>每个远程集群将其搜索结果发送回协调节点；</li>
</ol>
<p><img src="/images/202105/crossClusterSearch1_3.png" alt="crossClusterSearch1_3.png"></p>
<ol start="4">
<li>从每个集群收集结果之后，协调节点将在跨群集搜索响应中返回最终结果。</li>
</ol>
<p><img src="/images/202105/crossClusterSearch1_4.png" alt="crossClusterSearch1_4.png"></p>
<h4 id="Don’t-minimize-network-roundtrips-检索的步骤："><a href="#Don’t-minimize-network-roundtrips-检索的步骤：" class="headerlink" title="Don’t minimize network roundtrips 检索的步骤："></a><code>Don’t minimize network roundtrips</code> 检索的步骤：</h4><ol>
<li>将跨集群搜索请求发送到本地集群。该集群中的协调节点接收并解析该请求；</li>
</ol>
<p><img src="/images/202105/crossClusterSearch2_1.png" alt="crossClusterSearch2_1.png"></p>
<ol start="2">
<li>协调节点向每个集群发送单个搜索请求，包括其自身的搜索请求。每个集群独立执行搜索请求；</li>
</ol>
<p><img src="/images/202105/crossClusterSearch2_2.png" alt="crossClusterSearch2_2.png"></p>
<ol start="3">
<li>每个远程集群将其响应发送回协调节点。该响应中包含了将要执行跨集群搜索请求的分片和索引的信息。</li>
</ol>
<p><img src="/images/202105/crossClusterSearch2_3.png" alt="crossClusterSearch2_3.png"></p>
<ol start="4">
<li>协调节点向<span style="color:red">每个分片</span>（包括其自己的集群中的分片）发送搜索请求。每个分片独立执行搜索请求。</li>
</ol>
<p><img src="/images/202105/crossClusterSearch2_4.png" alt="crossClusterSearch2_4.png"></p>
<ol start="5">
<li>每个分片将其搜索结果发送回协调节点。</li>
</ol>
<p><img src="/images/202105/crossClusterSearch2_5.png" alt="crossClusterSearch2_5.png"></p>
<ol start="6">
<li>从每个集群收集结果之后，协调节点将在跨群集搜索响应中返回最终结果。</li>
</ol>
<p><img src="/images/202105/crossClusterSearch2_6.png" alt="crossClusterSearch2_6.png"></p>
<h2 id="4-index-level-shard-allocation"><a href="#4-index-level-shard-allocation" class="headerlink" title="4. index_level shard allocation"></a>4. index_level shard allocation</h2><h4 id="设置节点属性"><a href="#设置节点属性" class="headerlink" title="设置节点属性"></a>设置节点属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// yml 配置</span><br><span class="line">node.attr.size: medium</span><br><span class="line"></span><br><span class="line">// 启动参数配置</span><br><span class="line">./bin/elasticsearch -Enode.attr.size=medium</span><br></pre></td></tr></table></figure>
<h4 id="配置索引策略："><a href="#配置索引策略：" class="headerlink" title="配置索引策略："></a>配置索引策略：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 声明多个则表示需要同时满足</span><br><span class="line">PUT test/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;index.routing.allocation.include.size&quot;: &quot;big&quot;,</span><br><span class="line">  &quot;index.routing.allocation.include.rack&quot;: &quot;rack1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>index.routing.allocation.include.{attribute}</code>，节点至少需要满足 <code>include</code> 中的一个属性；</li>
<li><code>index.routing.allocation.require.{attribute}</code>，节点必须满足 <code>require</code> 中的所有属性</li>
<li><code>index.routing.allocation.exclude.{attribute}</code>，索引不能分配在 <code>exclude</code> 属性的节点上</li>
</ul>
<p><code>attribute</code> 属性值由用户自定义 ，也可以使用 <code>Elasticsearch</code> 内建的以下属性：</p>
<ul>
<li><code>_name</code>，通过节点名称匹配节点</li>
<li><code>_host_ip</code>，通过主机 <code>IP</code> 地址（与主机名关联的 <code>IP</code> ）匹配节点</li>
<li><code>_publish_ip</code>，通过发布 <code>IP</code> 地址匹配节点</li>
<li><code>_ip</code>，匹配 <code>_host_ip</code> 或 <code>_publish_ip</code></li>
<li><code>_host</code> 通过主机名匹配节点</li>
</ul>
<h4 id="限制每个节点上的分片数量"><a href="#限制每个节点上的分片数量" class="headerlink" title="限制每个节点上的分片数量"></a>限制每个节点上的分片数量</h4><p>使用该配置会影响物理层面的分配，如果节点数不够，可能会导致部分分片状态为 <code>unAssigned</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index.routing.allocation.total_shards_per_node</span><br><span class="line">cluster.routing.allocation.total_shards_per_node</span><br></pre></td></tr></table></figure></p>
<h2 id="5-cluster-level-shard-allocation"><a href="#5-cluster-level-shard-allocation" class="headerlink" title="5. cluster_level shard allocation"></a>5. cluster_level shard allocation</h2><p><code>allocation awareness</code> 和 <code>Fore awareness</code> 是针对不同机房、机架环境设置的，例如不希望将主副分片分配到同一个机架，或者同一个地区。避免一处停电，影响所有数据。</p>
<h4 id="第一步：设置节点属性，与index-level是相同的-可自定义"><a href="#第一步：设置节点属性，与index-level是相同的-可自定义" class="headerlink" title="第一步：设置节点属性，与index_level是相同的,可自定义"></a>第一步：设置节点属性，与index_level是相同的,可自定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node.attr.rack_id: rack1</span><br></pre></td></tr></table></figure>
<h4 id="第二步：设置集群层面的分片分配策略，属性保持相同"><a href="#第二步：设置集群层面的分片分配策略，属性保持相同" class="headerlink" title="第二步：设置集群层面的分片分配策略，属性保持相同"></a>第二步：设置集群层面的分片分配策略，属性保持相同</h4><p>如下的例子中</p>
<ul>
<li><code>awareness.attribute</code> 指明了分片分配的感知策略基于 <code>rack_id</code></li>
<li><code>force.rack_id.values</code> 指明了分片分配的范围，主副分片必须在两个机架上。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT _cluster/setting</span><br><span class="line">&#123;</span><br><span class="line">    &quot;persistent&quot;:&#123;</span><br><span class="line">        &quot;cluster.routing.allocation.awareness.attribute&quot;: &quot;rack_id&quot;,</span><br><span class="line">        &quot;cluster.routing.allocation.awareness.force.rack_id.values&quot;: &quot;rack1,rack2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>如果只有一个机架属性，副本分配将表现为 <code>unassigned</code> 状态<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT test_004</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;number_of_shards&quot;: 5,</span><br><span class="line">    &quot;number_of_replicas&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-ingest-pipeline"><a href="#6-ingest-pipeline" class="headerlink" title="6. ingest pipeline"></a>6. ingest pipeline</h2><h3 id="6-1-增删改查"><a href="#6-1-增删改查" class="headerlink" title="6.1 增删改查"></a>6.1 增删改查</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//重复调用，会自动更新原有的声明</span><br><span class="line">PUT _ingest/pipeline/my_pipeline</span><br><span class="line">&#123;</span><br><span class="line">  &quot;description&quot; : &quot;describe pipeline&quot;,</span><br><span class="line">  &quot;processors&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;set&quot; : &#123;</span><br><span class="line">        &quot;field&quot;: &quot;foo&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;bar&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">// 查询</span><br><span class="line">GET _ingest/pipeline/my_pipeline</span><br><span class="line">// 删除</span><br><span class="line">DELETE _ingest/pipeline/my_pipeline</span><br></pre></td></tr></table></figure>
<h3 id="6-2-condition-语法（可以使用正则判断）"><a href="#6-2-condition-语法（可以使用正则判断）" class="headerlink" title="6.2 condition 语法（可以使用正则判断）"></a>6.2 condition 语法（可以使用正则判断）</h3><p>根据数据内容判断<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// if 案例</span><br><span class="line">PUT _ingest/pipeline/drop_guests_network</span><br><span class="line">&#123;</span><br><span class="line">  &quot;processors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;drop&quot;: &#123;</span><br><span class="line">        &quot;if&quot;: &quot;ctx.network_name == &apos;Guest&apos;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">// 展开对象，多条件判断案例</span><br><span class="line">PUT _ingest/pipeline/drop_guests_network</span><br><span class="line">&#123;</span><br><span class="line">  &quot;processors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;dot_expander&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;network.name&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;drop&quot;: &#123;</span><br><span class="line">        &quot;if&quot;: &quot;ctx.network?.name != null &amp;&amp; ctx.network.name.contains(&apos;Guest&apos;)&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用复杂的代码语法判断<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 有些类似于 `script` 操作了</span><br><span class="line">PUT _ingest/pipeline/not_prod_dropper</span><br><span class="line">&#123;</span><br><span class="line">  &quot;processors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;drop&quot;: &#123;</span><br><span class="line">        &quot;if&quot;: &quot;&quot;&quot;</span><br><span class="line">            Collection tags = ctx.tags;</span><br><span class="line">            if(tags != null)&#123;</span><br><span class="line">              for (String tag : tags) &#123;</span><br><span class="line">                  if (tag.toLowerCase().contains(&apos;prod&apos;)) &#123;</span><br><span class="line">                      return false;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按条件使用 <code>processor</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT _ingest/pipeline/logs_pipeline</span><br><span class="line">&#123;</span><br><span class="line">  &quot;description&quot;: &quot;A pipeline of pipelines for log files&quot;,</span><br><span class="line">  &quot;version&quot;: 1,</span><br><span class="line">  &quot;processors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;pipeline&quot;: &#123;</span><br><span class="line">        &quot;if&quot;: &quot;ctx.service?.name == &apos;apache_httpd&apos;&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;httpd_pipeline&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;pipeline&quot;: &#123;</span><br><span class="line">        &quot;if&quot;: &quot;ctx.service?.name == &apos;syslog&apos;&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;syslog_pipeline&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;fail&quot;: &#123;</span><br><span class="line">        &quot;message&quot;: &quot;This pipeline requires service.name to be either `syslog` or `apache_httpd`&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-3-处理器-processors"><a href="#6-3-处理器-processors" class="headerlink" title="6.3 处理器 processors"></a>6.3 处理器 processors</h3><ul>
<li><code>append</code>，向数组中添加元素，如果数组不存在，则使用给定元素新建。</li>
<li><code>bytes</code>，单位转换，<code>1kb --&gt; 1024</code></li>
<li><code>convert</code>，类型转换，字符串转数字，或者转 <code>boolean</code></li>
<li><code>date</code>，日期格式化，处理后的字段默认为 <code>@timestamp</code> ，通过 <code>target_field</code> 变更</li>
<li><code>date_index_name</code>，按照日期将数据分配到不同索引，使用 <code>set</code> 处理器修改 <code>_index</code> 也可以实现类似效果</li>
<li><code>dissect</code> ，也称解剖…从单个文本字段中提取结构化字段，与 <code>grok</code> 类似，但不使用正则表达，所以某些情况下速度比 <code>grok</code> 更快</li>
<li><code>dot_expander</code>，展开类似 <code>fullname.firstname</code> 的字段为 <code>object</code> 格式.</li>
<li><code>drop</code>，移除文档，可以按 <code>if</code> 条件来 <code>drop</code></li>
<li><code>fail</code>，抛出异常的处理器，用于提示请求出错</li>
<li><code>foreach</code>，遍历数组字段，可以在内部使用所有其他的处理器。</li>
<li><code>grok</code></li>
<li><code>gsub</code>，将字符串按照 <code>pattern</code> 进行替换，如果不是字符串类型则会报错。</li>
<li><code>html_strip</code>，去除 <code>html</code> 标签</li>
<li><code>json</code>，将 <code>json</code> 字符串转换为对象</li>
<li><code>kv</code>，通过 <code>field_split</code> 切分为数组，再根据 <code>value_split</code> 切分 <code>key</code> 和 <code>value</code></li>
<li><code>lowercase/uppercase</code>，大小写转换</li>
<li><code>pipeline</code>，类似于 <code>include</code> 的感觉，引用另一个 <code>pipeline</code> 的所有处理器</li>
<li><code>remove</code>，移除一个已有的字段，如果字段不存在，抛出错误</li>
<li><code>rename</code>，字段重命名</li>
<li><code>script</code>，脚本处理器</li>
<li><code>set</code>，为字段设值</li>
<li><code>split</code>，分割</li>
<li><code>sort</code>，排序</li>
<li><code>trim</code>，去空格</li>
<li><code>urldecode</code>，解析 <code>url</code> 中的转义字符，例如 <code>%23</code> 对应 <code>#</code></li>
</ul>
<p><span style="color:red">一个较为全面的应用案例：</span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _ingest/pipeline/_simulate</span><br><span class="line">&#123;</span><br><span class="line">  &quot;pipeline&quot;: &#123;</span><br><span class="line">    &quot;processors&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;append&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;tags&quot;,</span><br><span class="line">          &quot;value&quot;: [</span><br><span class="line">            &quot;&#123;&#123;app&#125;&#125;&quot;,</span><br><span class="line">            &quot;&#123;&#123;owner&#125;&#125;&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;bytes&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;file&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;date&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;date_test&quot;,</span><br><span class="line">          &quot;formats&quot;: [</span><br><span class="line">            &quot;yyyy-MM-dd&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;target_field&quot;: &quot;@date&quot;,</span><br><span class="line">          &quot;timezone&quot;: &quot;UTC+8&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dissect&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;log&quot;,</span><br><span class="line">          &quot;pattern&quot;: &quot;[%&#123;ts&#125;] [%&#123;level&#125;] %&#123;*p1&#125;:%&#123;&amp;p1&#125; %&#123;*p2&#125;:%&#123;&amp;p2&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dot_expander&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;fullname.firstname&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dot_expander&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;fullname.lastname&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;fail&quot;: &#123;</span><br><span class="line">          &quot;if&quot;: &quot;ctx.tags.contains(&apos;blue&apos;) != true&quot;,</span><br><span class="line">          &quot;message&quot;: &quot;The production tag is not present, found tags: &#123;&#123;tags&#125;&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;foreach&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;hobby&quot;,</span><br><span class="line">          &quot;processor&quot;: &#123;</span><br><span class="line">            &quot;uppercase&quot;: &#123;</span><br><span class="line">              &quot;field&quot;: &quot;_ingest._value&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;grok&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;message&quot;,</span><br><span class="line">          &quot;patterns&quot;: [</span><br><span class="line">            &quot;%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;html_strip&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;html_strip_test&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;join&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;hobby&quot;,</span><br><span class="line">          &quot;separator&quot;: &quot;-&quot;,</span><br><span class="line">          &quot;target_field&quot;: &quot;join_hobby&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;json&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;json_test&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;kv&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;kv_test&quot;,</span><br><span class="line">          &quot;field_split&quot;: &quot;&amp;&quot;,</span><br><span class="line">          &quot;value_split&quot;: &quot;=&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;remove&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;ip&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;rename&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;rename_test&quot;,</span><br><span class="line">          &quot;target_field&quot;: &quot;new_rename_test&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;script&quot;: &#123;</span><br><span class="line">          &quot;source&quot;: &quot;&quot;&quot;</span><br><span class="line">          ArrayList hobbyList = ctx.hobby;</span><br><span class="line">          hobbyList.remove(0);</span><br><span class="line">          ctx.script_test = hobbyList;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;set&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;set_test&quot;,</span><br><span class="line">          &quot;value&quot;: &quot;我是&#123;&#123;set_test&#125;&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;split&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;split_test&quot;,</span><br><span class="line">          // +号表示连续的符号视为一个</span><br><span class="line">          &quot;separator&quot;: &quot;,+&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;sort&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;sort_test&quot;,</span><br><span class="line">          &quot;order&quot;: &quot;asc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;trim&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;trim_test&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;urldecode&quot;:&#123;</span><br><span class="line">          // url转义符解析，例如 %23 对应 #</span><br><span class="line">          &quot;field&quot;:&quot;urldecode_test&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;docs&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_source&quot;: &#123;</span><br><span class="line">        &quot;tags&quot;: &quot;blue&quot;,</span><br><span class="line">        &quot;app&quot;: &quot;surfshark&quot;,</span><br><span class="line">        &quot;owner&quot;: &quot;zengxin&quot;,</span><br><span class="line">        &quot;file&quot;: &quot;1kb&quot;,</span><br><span class="line">        &quot;date_test&quot;: &quot;2021-05-10&quot;,</span><br><span class="line">        &quot;log&quot;: &quot;[2018-08-10T17:15:42,466] [ERR] ip:1.2.3.4 error:REFUSED&quot;,</span><br><span class="line">        &quot;fullname.firstname&quot;: &quot;zeng&quot;,</span><br><span class="line">        &quot;fullname.lastname&quot;: &quot;xin&quot;,</span><br><span class="line">        &quot;hobby&quot;: [</span><br><span class="line">          &quot;read&quot;,</span><br><span class="line">          &quot;moive&quot;,</span><br><span class="line">          &quot;coding&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;ip&quot;: &quot;8.8.8.8&quot;,</span><br><span class="line">        &quot;message&quot;: &quot;55.3.244.1 GET /index.html 15824 0.043&quot;,</span><br><span class="line">        &quot;html_strip_test&quot;: &quot;&lt;span style=&apos;color:red&apos;&gt;测试&lt;/span&gt;&quot;,</span><br><span class="line">        &quot;json_test&quot;: &quot;&quot;&quot;&#123;&quot;foo&quot;: 2000&#125;&quot;&quot;&quot;,</span><br><span class="line">        &quot;kv_test&quot;: &quot;username=zhangsan&amp;password=123456&quot;,</span><br><span class="line">        &quot;rename_test&quot;: &quot;history&quot;,</span><br><span class="line">        &quot;set_test&quot;: &quot;123&quot;,</span><br><span class="line">        &quot;split_test&quot;:&quot;zengxin,,,zhengxin,tomas,北方&quot;,</span><br><span class="line">        &quot;sort_test&quot;:[10,23,9,11,7,5],</span><br><span class="line">        &quot;trim_test&quot;:&quot;这是      的   &quot;,</span><br><span class="line">        &quot;urldecode_test&quot;:&quot;http://172.25.17.142:5601/app/kibana%23/dev_tools/console?_g=()&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-x-pack：role、https-配置"><a href="#7-x-pack：role、https-配置" class="headerlink" title="7. x-pack：role、https 配置"></a>7. x-pack：role、https 配置</h2><h3 id="7-1-身份认证与用户鉴权"><a href="#7-1-身份认证与用户鉴权" class="headerlink" title="7.1 身份认证与用户鉴权"></a>7.1 身份认证与用户鉴权</h3><h4 id="Authentication-认证体系"><a href="#Authentication-认证体系" class="headerlink" title="Authentication 认证体系"></a>Authentication 认证体系</h4><ul>
<li>提供用户名、密码</li>
<li>提供密钥或 <code>kerberos</code> 票据<h4 id="Realms：X-pack中的认证服务"><a href="#Realms：X-pack中的认证服务" class="headerlink" title="Realms：X-pack中的认证服务"></a>Realms：X-pack中的认证服务</h4></li>
<li>内置 <code>Realms</code>（免费），<code>File/Native</code> 用户名/密码保存在 <code>Elasticsearch</code> 中；</li>
<li>外部 <code>Realms</code>（收费），<code>LDAP/Active Directory/PKI/SAML/Kerberos</code>。</li>
</ul>
<h4 id="RBAC-用户鉴权"><a href="#RBAC-用户鉴权" class="headerlink" title="RBAC 用户鉴权"></a>RBAC 用户鉴权</h4><p>什么是 <code>RBAC</code>: <code>Role Based Access Control</code>（基于角色的权限控制），定义一个角色，并分配一组权限。权限包括索引级，字段级，集群级的不同的操作。然后通过将角色分配给用户，使得用户拥有这些权限。<br>ES </p>
<ul>
<li>User </li>
<li>Role</li>
<li>Permission</li>
<li>Previlege</li>
</ul>
<h3 id="7-2-集群安全通信-tranposrt-https"><a href="#7-2-集群安全通信-tranposrt-https" class="headerlink" title="7.2 集群安全通信: tranposrt + https"></a>7.2 集群安全通信: tranposrt + https</h3><h4 id="配置xpack"><a href="#配置xpack" class="headerlink" title="配置xpack"></a>配置xpack</h4><ol>
<li>切换到 <code>es</code> 启动用户，修改配置文件 <code>xpack.security.enabled: true</code></li>
<li>执行 <code>bin/elasticsearch-certutil ca</code> 生成 <code>ca</code> 文件，一路回车默认即可, <code>7.2</code> 版本的默认文件名为 <code>elastic-stack-ca.p12</code>，存放在安装根目录下</li>
<li>执行 <code>bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12</code> 生成证书。默认文件名为 <code>elastic-certificates.p12</code> ，存放在安装根目录下</li>
<li>执行 <code>mv elastic-certificates.p12 config/cert/</code> 将证书移动到 <code>config/cert/</code> 目录下</li>
<li>将证书拷贝到集群其它节点的 <code>config/cert/</code> 目录下</li>
<li>修改最终的配置文件为如下所示</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br><span class="line">xpack.security.transport.ssl.verification_mode: certificate</span><br><span class="line">xpack.security.transport.ssl.keystore.path: cert/elastic-certificates.p12</span><br><span class="line">xpack.security.transport.ssl.truststore.path: cert/elastic-certificates.p12</span><br><span class="line"></span><br><span class="line">xpack.security.http.ssl.enabled: true</span><br><span class="line">xpack.security.http.ssl.keystore.path: cert/elastic-certificates.p12</span><br><span class="line">xpack.security.http.ssl.truststore.path: cert/elastic-certificates.p12</span><br></pre></td></tr></table></figure>
<h4 id="配置用户名、密码"><a href="#配置用户名、密码" class="headerlink" title="配置用户名、密码"></a>配置用户名、密码</h4><p>执行 <code>bin/elasticsearch-setup-passwords interactive</code> 初始化各用户的密码</p>
<h4 id="kibana-访问设置"><a href="#kibana-访问设置" class="headerlink" title="kibana 访问设置"></a>kibana 访问设置</h4><p><code>kibana</code> 使用 <code>https</code> 时还需要修改如下三个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elasticsearch.hosts: [&quot;http://localhost:9200&quot;]</span><br><span class="line">elasticsearch.ssl.certificateAuthorities: [ &quot;/path/to/your/CA.pem&quot; ]</span><br><span class="line">elasticsearch.ssl.verificationMode: certificate</span><br></pre></td></tr></table></figure>
<p>生成 <code>pem</code> 文件需要使用到 <code>openssl</code>，执行如下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -in elastic-certificates.p12 -cacerts -nokeys -out elastic-ca.pem</span><br></pre></td></tr></table></figure>
<h4 id="kibana的https设置"><a href="#kibana的https设置" class="headerlink" title="kibana的https设置"></a>kibana的https设置</h4><ol>
<li>执行 <code>bin/elasticsearch-certutil ca --pem</code>，生成的 <code>elastic-stack-ca.zip</code> 文件中包含了 <code>ca.crt</code>，<code>ca.key</code> 两个文件;</li>
<li>解压缩后，将两个文件拷贝到 <code>config/cert</code> 目录下，编辑 <code>kibana.yml</code> 文件的如下配置；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.ssl.enabled: true</span><br><span class="line">server.ssl.certificate: config/cert/ca.crt</span><br><span class="line">server.ssl.key: config/cert/ca.key</span><br></pre></td></tr></table></figure>
<p><span style="color:red">由于证书是自签的，仅能用于测试，所以kibana中会有SSL相关的报错</span></p>
<hr>
<p>あなたがいきる、この世界に</p>
<p><img src="/images/202105/你所在的这个世界-加藤段藏.jpg" alt="Alt"></p>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-alpine镜像安装字体库</title>
    <url>/2019/07/07/docker-alpine%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93%E5%BA%93/</url>
    <content><![CDATA[<p>记录下前不久在制作镜像时踩的一个坑。（镜像的主要功能是，发送一个图片地址和中文名称。然后将微软雅黑字体作为签字写到图片上并返回。）<a id="more"></a></p>
<h2 id="openjdk与oraclejdk"><a href="#openjdk与oraclejdk" class="headerlink" title="openjdk与oraclejdk"></a>openjdk与oraclejdk</h2><p>为了减小镜像的大小，我使用了 <code>alpine</code> 镜像。开始我的 <code>dockerfile</code> 如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">FROM java:<span class="number">8</span>-alpine</span><br><span class="line">USER root</span><br><span class="line">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">COPY target/image-sign.jar image-sign.jar</span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"image-sign.jar"</span>]</span><br></pre></td></tr></table></figure></p>
<!--more-->
<p>使用<code>docker build</code>时候成功的制作了镜像。诶？好像看起来没什么问题啊？<br><code>docker run</code>启动容器。然后访问接口：<br><img src="/images/sign-error.png" alt="sign-error"><br>空指针？单独运行程序没有问题的呀，怎么放到 <code>docker</code> 就出现这个问题了。仔细一查发现是因为 <code>dockerfile</code>制作镜像时下载的<code>openjdk</code>的原因,<code>openjdk</code>是开源的，在<code>oracle</code>接手之后，两者的内容已经有些区别了。<code>From java:8-alpine</code>这一句，<br>下载的是<code>openjdk8</code>，而我需要的是<code>oraclejdk8</code>.两者在功能上的小差别导致了这个问题。将基础镜像改为<code>FROM anapsix/alpine-java</code>之后就ok了</p>
<h2 id="linux字体库的锅"><a href="#linux字体库的锅" class="headerlink" title="linux字体库的锅"></a>linux字体库的锅</h2><p>修改为<code>oraclejdk</code>后，镜像虽然能够正常运行了，但我通过接口转入的中文却不能正常显示:<br><img src="/images/ch-error.png" alt="ch-error"><br>在网上翻阅到的原因都说是缺少字体，<code>linux</code>下是没有微软雅黑、宋体这些字体的。但我按照他们的方式却怎么也安装不成功(后来发现是我网络的问题。),最后找到的解决办法如下：<br>1.将<code>windows</code>下的字体找到，复制出来。宋体为<code>simsun.ttc</code>,需要改后缀名为<code>ttf</code>，微软雅黑为<code>msyf.tff</code>。<br>2.编辑<code>dockerfile</code>为如下即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">FROM anapsix/alpine-java</span><br><span class="line">RUN    echo <span class="string">"http://mirror.math.princeton.edu/pub/alpinelinux/v3.8/main"</span> &gt; <span class="regexp">/etc/</span>apk/repositories \</span><br><span class="line">       &amp;&amp; echo <span class="string">"http://mirror.math.princeton.edu/pub/alpinelinux/v3.8/community"</span> &gt;&gt; <span class="regexp">/etc/</span>apk/repositories \</span><br><span class="line">       &amp;&amp; apk add ttf-dejavu fontconfig \</span><br><span class="line">       &amp;&amp; rm -rf /<span class="keyword">var</span>/cache/apk<span class="comment">/* \</span></span><br><span class="line"><span class="comment">       &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \ </span></span><br><span class="line"><span class="comment">       &amp;&amp; echo "Asia/Shanghai" &gt; /etc/timezone </span></span><br><span class="line"><span class="comment">COPY target/image-sign.jar image-sign.jar</span></span><br><span class="line"><span class="comment">COPY ttf/*  /usr/share/fonts/</span></span><br><span class="line"><span class="comment">ENTRYPOINT ["java","-jar","image-sign.jar"]</span></span><br></pre></td></tr></table></figure>
<p>这里做下解释，<code>apk</code>是<code>alpine</code>系统的安装工具，类似<code>centos</code>的<code>yum</code>与<code>ubuntu</code>系统的<code>apt-get</code>，<br>前两句<code>echo</code>是更改<code>apk</code>安装的镜像地址，不清楚是资源的问题还是啥，在我没有改这个的时候。一直安装不成功。具体可见<code>github</code>的这个<code>issues</code>：<br><a href="https://github.com/gliderlabs/docker-alpine/issues/207" target="_blank" rel="noopener">apk WARNING Ignoring APKINDEX No such file or director</a></p>
<p>当然，这个办法也是在<code>issue</code>里找到的= =，<code>github</code>还是解决问题的好地方啊~，之后的<code>apk add ttf-dejavu fontconfig</code>是为容器安装字体库，同时删除安装包(减小镜像大小)。<br><code>COPY ttf/*  /usr/share/fonts/</code>  将从<code>windows</code>下拿到的字体文件放入<code>docker</code>镜像内，问题解决~<br><img src="/images/sign-success.png" alt="sign-success"></p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p> <code>dockerfile</code> 如果具有多个 <code>RUN</code> 指令，考虑写在同一行的话会减少镜像的体积。毕竟 <code>docker</code> 每运行一个指令都会加上一层 <code>layer</code>。  </p>
<p>以上です～。</p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Week03总结</title>
    <url>/2021/04/24/Week03/</url>
    <content><![CDATA[<h2 id="1-文档学习"><a href="#1-文档学习" class="headerlink" title="1. 文档学习"></a>1. 文档学习</h2><p>本周阅读内容为 <code>cat API</code>、<code>cluster API</code>、<code>query API</code> 部分， 以及 <code>script</code> 和 <code>mapping</code> 的小章节内容。 <code>Aggregatins</code> 暂时跳过了（这一章我一直觉得很难 orz… 最后再来慢慢啃吧）,这周总结的重点内容如下：</p>
<ul>
<li><code>cluster reroute</code>、<code>cluster update settings</code></li>
<li><code>Compound query</code></li>
<li><code>full text query</code></li>
<li><code>scripting</code></li>
<li><code>mapping</code></li>
</ul>
<a id="more"></a>
<h2 id="2-cat-API、cluster-API总结"><a href="#2-cat-API、cluster-API总结" class="headerlink" title="2. cat API、cluster API总结"></a>2. cat API、cluster API总结</h2><h3 id="2-1-常用的状态查看-API"><a href="#2-1-常用的状态查看-API" class="headerlink" title="2.1 常用的状态查看 API"></a>2.1 常用的状态查看 API</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 查看集群健康：</span><br><span class="line">GET _cluster/health</span><br><span class="line">GET _cat/health?v</span><br><span class="line"></span><br><span class="line">// 查看索引健康、文档情况</span><br><span class="line">GET _cat/indices?v</span><br><span class="line"></span><br><span class="line">// 查看分片情况、分配、恢复状态等</span><br><span class="line">GET /_cat/shards/[index]?v</span><br><span class="line"></span><br><span class="line">// 查看节点属性</span><br><span class="line">GET _cat/nodeattrs?v</span><br><span class="line"></span><br><span class="line">// 查看节点信息</span><br><span class="line">GET _cat/nodes?v</span><br><span class="line"></span><br><span class="line">// 查看 `pending_task`</span><br><span class="line">GET /_cluster/pending_tasks</span><br><span class="line">GET /_cat/pending_tasks?v</span><br><span class="line"></span><br><span class="line">// 查看索引模板</span><br><span class="line">GET /_cat/templates?v&amp;s=name</span><br></pre></td></tr></table></figure>
<h3 id="2-2-cluster-reroute"><a href="#2-2-cluster-reroute" class="headerlink" title="2.2 _cluster/reroute"></a>2.2 _cluster/reroute</h3><p><code>reroute</code> 一共包含以下几种指令：</p>
<ul>
<li><code>move</code> ，将分片从一个节点移至另一个节点，已经分配成功的 <code>shard</code> 只能使用 <code>move</code> 指令；</li>
<li><code>cancel</code>，取消分片的分配， 通常用于取消恢复中 <code>recovery</code> 状态的分片分配；</li>
<li><code>allocate_replica</code> ，仅用于 <code>unsigned</code> 的副本分配,。</li>
</ul>
<p>在 <code>uri</code> 中添加 <code>?retry_failed</code> 可以自动失败重试，重试次数默认为 <code>5</code> ， 通过修改集群配置参数 <code>index.allocation.max_retries</code> 可以进行调整<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET _cat/shards/test2?v</span><br><span class="line">// response-----------</span><br><span class="line">index shard prirep state   docs store ip           node</span><br><span class="line">test2 0     r      STARTED    1 4.1kb 172.25.17.58 node3</span><br><span class="line">test2 0     p      STARTED    1 4.1kb 172.25.17.87 node2</span><br><span class="line"></span><br><span class="line"># 我这里先查询到 shard 0 的主分片分布在 node2上，然后通过 reroute 移动到 node1 上。</span><br><span class="line">POST _cluster/reroute?retry_failed</span><br><span class="line">&#123;</span><br><span class="line">  &quot;commands&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;move&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;test2&quot;,</span><br><span class="line">        &quot;shard&quot;: 0,</span><br><span class="line">        &quot;from_node&quot;: &quot;node2&quot;,</span><br><span class="line">        &quot;to_node&quot;: &quot;node1&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"># 分配 unsigned 的副本</span><br><span class="line">POST _cluster/reroute?retry_failed</span><br><span class="line">&#123;</span><br><span class="line">  &quot;commands&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;allocate_replica&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;index_name&quot;,</span><br><span class="line">        &quot;shard&quot;: 0,</span><br><span class="line">        &quot;node&quot;: &quot;node2&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="强制分配不可恢复的错误"><a href="#强制分配不可恢复的错误" class="headerlink" title="强制分配不可恢复的错误"></a>强制分配不可恢复的错误</h4><p>除以上指令之外，还有两个特殊的命令，这些命令允许将主分片 <code>reroute</code>。但是使用时需要特别小心，因为主分片的分配通常是由 <code>Elasticsearch</code> 自动处理的。无法自动分配主分片的原因包括：</p>
<ul>
<li>创建了一个新索引，但是没有满足分配决定者的节点。</li>
<li>在群集中的当前数据节点上找不到数据的最新分片副本。为防止数据丢失，系统不会自动将陈旧的分片副本提升为主副本。</li>
</ul>
<p>以下两个命令很危险，可能会导致数据丢失。<span style="color:red">只有在无法恢复原始数据并且集群能够接受数据丢失的情况，考虑使用。对于网络波动或其他可恢复性的分配失败，应该考虑使用 <code>retry_failed</code> 进行重试。</span></p>
<h4 id="allocate-stale-primary"><a href="#allocate-stale-primary" class="headerlink" title="allocate_stale_primary"></a>allocate_stale_primary</h4><p><span style="color:red">将包含旧数据的副本升级为主分片</span>。需要给定 index 索引名称（index）和分片（shard）参数。<span style="color:red">使用此命令可能会导致数据丢失。如果具有数据版本更高的节点稍后重新加入群集，则该节点的数据将被删除或被新创建的副本覆盖掉。</span>为明确操作危险性，此命令要求将该标志 accept_data_loss 显式设置为 true 才能执行。</p>
<h4 id="allocate-empty-primary"><a href="#allocate-empty-primary" class="headerlink" title="allocate_empty_primary"></a>allocate_empty_primary</h4><p>将空的主碎片分配给节点，需要给定 index 索引名称（index）和分片（shard）参数。使用此命令将导致完全丢失索引到该分片的所有数据（如果先前已启动）。如果具有数据副本的节点稍后重新加入群集，则该数据将被删除。为明确操作危险性，此命令要求将该标志 accept_data_loss 显式设置为 true 才能执行。</p>
<h2 id="3-query-API-总结"><a href="#3-query-API-总结" class="headerlink" title="3.  query API 总结"></a>3.  query API 总结</h2><h3 id="3-1-组合查询-compound-query"><a href="#3-1-组合查询-compound-query" class="headerlink" title="3.1 组合查询 compound query"></a>3.1 组合查询 compound query</h3><ul>
<li><code>bool query</code> ，包含了 <code>must</code>、<code>must_not</code>、<code>should</code>、<code>filter</code> 四种基础查询，自由组合；</li>
<li><code>boosting query</code> ，权重查询，适用于 xx 公司、xx 集团等关键词区分权重的场景；</li>
<li><code>constant_score</code>，不需要相关性算分的场景（<code>filter</code> 使用的就是 <code>constant score</code> 只不过分值为 <code>0</code>）；</li>
<li><code>disjunction max</code>，单个字段最匹配（类比 <code>multi_match</code> 的 <code>best fields</code> 效果）</li>
<li><code>function score</code>，自定义算分</li>
</ul>
<h4 id="bool-query"><a href="#bool-query" class="headerlink" title="bool query"></a>bool query</h4><p><strong>组合查询：</strong>多条件之间可以自由拼装、嵌套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET index_name/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot; : &#123;</span><br><span class="line">      &quot;must&quot; : &#123;</span><br><span class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot; : &#123; &quot;tag&quot; : &quot;tech&quot; &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;must_not&quot; : &#123;</span><br><span class="line">        &quot;range&quot; : &#123;</span><br><span class="line">          &quot;age&quot; : &#123; &quot;gte&quot; : 10, &quot;lte&quot; : 20 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;should&quot; : [</span><br><span class="line">        &#123; &quot;term&quot; : &#123; &quot;tag&quot; : &quot;wow&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;term&quot; : &#123; &quot;tag&quot; : &quot;elasticsearch&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;minimum_should_match&quot; : 1,</span><br><span class="line">      &quot;boost&quot; : 1.0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="boosting-query"><a href="#boosting-query" class="headerlink" title="boosting query"></a>boosting query</h4><p><strong>权重查询：</strong>返回满足 <code>positive</code>  查询的数据，对于该结果中同时也满足 <code>negative</code> 的数据进行评分降低操作。</p>
<ul>
<li>例如检索企业名称这种数据中都带有【公司】、【有限公司】、【集团】之类的比较范的关键词；</li>
<li>或者在检索苹果时，【派、树、面包】这些相关性更低，而【苹果】公司相关性可能更高的场景。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET index_name/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;boosting&quot; : &#123;</span><br><span class="line">            &quot;positive&quot; : &#123;</span><br><span class="line">                &quot;term&quot; : &#123;</span><br><span class="line">                    &quot;text&quot; : &quot;apple&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;negative&quot; : &#123;</span><br><span class="line">                 &quot;term&quot; : &#123;</span><br><span class="line">                     &quot;text&quot; : &quot;pie tart fruit crumble tree&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;negative_boost&quot; : 0.5</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="constant-score"><a href="#constant-score" class="headerlink" title="constant score"></a>constant score</h4><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">GET index_name/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "constant_score" : &#123;</span><br><span class="line">            "filter" : &#123;</span><br><span class="line">                "term" : &#123; "user" : "kimchy"&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "boost" : 1.2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="disjunction-max"><a href="#disjunction-max" class="headerlink" title="disjunction max"></a>disjunction max</h4><p>对于普通的 <code>match</code> 查询而言，<span style="color:red">当多个字段都有匹配时</span>，很可能就会比某个字段完全匹配的分数更高，而 <code>disjunction max</code> 则根据匹配度最完整的字段来做主要评分，其余字段只起到辅助评分的效果。下面的例子中所展示的 <code>tie_breaker</code> 就是指其他字段的得分系数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET index_name/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;dis_max&quot; : &#123;</span><br><span class="line">            &quot;queries&quot; : [</span><br><span class="line">                &#123; &quot;term&quot; : &#123; &quot;title&quot; : &quot;Quick pets&quot; &#125;&#125;,</span><br><span class="line">                &#123; &quot;term&quot; : &#123; &quot;body&quot; : &quot;Quick pets&quot; &#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;tie_breaker&quot; : 0.7</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="function-score"><a href="#function-score" class="headerlink" title="function score"></a>function score</h4><p><code>function score</code> 目前共包含以下几种：</p>
<ul>
<li><code>script_score</code> 可以自定义脚本计算分数，由于 <code>script</code> 具有编译缓存机制，所以能抽取参数的情况下，尽量是抽取参数后使用固定脚本；</li>
<li><code>random_score+seed</code> 可以用于随机推荐、排名场景；</li>
<li><code>weight</code> 权重，我目前将它简单的理解为 <code>boost</code>，很简单（略过）;</li>
<li><code>field_value_factor</code> ,可以应用在内容相同（相似），通过投票数、点赞数等其他字段影响分数的场景；</li>
<li><code>decay functions</code> 大概用在附近位置、相近时间等，(有点类似于 <code>range_query</code> 的感觉，但分数计算会更加圆滑–&gt;因为是通过衰减函数计算的)。</li>
</ul>
<p><strong>基础用法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET kibana_sample_data_ecommerce/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_source&quot;: [</span><br><span class="line">    &quot;product_name&quot;,</span><br><span class="line">    &quot;category&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;boost&quot;: &quot;5&quot;,</span><br><span class="line">      // function_score 的其中一种，随机</span><br><span class="line">      &quot;random_score&quot;: &#123;&#125;,</span><br><span class="line">      // function_score 与 query 分数相乘</span><br><span class="line">      &quot;boost_mode&quot;: &quot;multiply&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>boost_mode</code> 与 <code>score_mode</code> 的区别</strong><br>多个 <code>function</code> 之间的算分为 <code>score_mode</code>，基础 <code>query</code>与 <code>function_score</code> 之间的算分为 <code>boost_mode</code>。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;function_score&quot;: &#123;</span><br><span class="line">          &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">          // match_all的 query 查询分为1，boost 将其置为5</span><br><span class="line">          &quot;boost&quot;: &quot;5&quot;, </span><br><span class="line">          &quot;functions&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                  &quot;filter&quot;: &#123; &quot;match&quot;: &#123; &quot;test&quot;: &quot;bar&quot; &#125; &#125;,</span><br><span class="line">                  &quot;random_score&quot;: &#123;&#125;, </span><br><span class="line">                  &quot;weight&quot;: 23</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                  &quot;filter&quot;: &#123; &quot;match&quot;: &#123; &quot;test&quot;: &quot;cat&quot; &#125; &#125;,</span><br><span class="line">                  &quot;weight&quot;: 42</span><br><span class="line">              &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;max_boost&quot;: 42,</span><br><span class="line">          // 多个function之间采用最大值得分</span><br><span class="line">          &quot;score_mode&quot;: &quot;max&quot;,</span><br><span class="line">          // 最终算分为 query 基础分 * function的得分</span><br><span class="line">          &quot;boost_mode&quot;: &quot;multiply&quot;,</span><br><span class="line">          &quot;min_score&quot; : 42</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>random_score + seed</code> 的使用案例</strong><br>当 <code>seed</code> 相同时，返回的随机分数是固定的，可以用于对不同的用户展示乱序结果，但同一个用户结果不变的场景</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /blogs/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;random_score&quot;: &#123;</span><br><span class="line">        &quot;seed&quot;: 911119</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>field_value_factor的使用案例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;function_score&quot;: &#123;</span><br><span class="line">            &quot;field_value_factor&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;likes&quot;,</span><br><span class="line">                &quot;factor&quot;: 1.2,</span><br><span class="line">                &quot;modifier&quot;: &quot;sqrt&quot;,</span><br><span class="line">                &quot;missing&quot;: 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>decay functions 衰减函数的使用案例</strong></p>
<p>通过衰减函数对文档进行评分，函数的衰减速度取决于文档的数字字段值距用户给定原点的距离。类似于范围查询，分数变化更加的平滑，而不是固定的数值。</p>
<p>衰减函数的类型，包括 <code>gauss</code> 高斯函数、<code>linear</code> 线性函数、<code>exp</code> 指数函数三种<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;gauss&quot;: &#123;</span><br><span class="line">    //字段名</span><br><span class="line">    &quot;location&quot;: &#123; </span><br><span class="line">          &quot;origin&quot;: &quot;11, 12&quot;,</span><br><span class="line">          &quot;scale&quot;: &quot;2km&quot;,</span><br><span class="line">          &quot;offset&quot;: &quot;0km&quot;,</span><br><span class="line">          &quot;decay&quot;: 0.33</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red"><code>decay_function</code> 参数示意图:</span></p>
<p><img src="/images/202105/es_decay_param.jpg" alt="es_decay_param.jpg"></p>
<p><span style="color:red">三种衰减函数示意图：</span></p>
<p><img src="/images/202105/es_decay_function.jpg" alt="es_decay_function.jpg"></p>
<p>官方案例说明：假设我们在一个小镇的中心搜索附近的酒店，我们希望离小镇中心越近越好，同时价格也是一个选择因素，例如有一个更便宜的，距离稍微远些也是可选项。</p>
<p>我们将搜索范围限定在 2km 以内，并且希望价格不高于 100 元。那么可以使用如下的衰减函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 价格</span><br><span class="line">&quot;gauss&quot;: &#123;</span><br><span class="line">    &quot;price&quot;: &#123;</span><br><span class="line">          &quot;origin&quot;: &quot;0&quot;,</span><br><span class="line">          &quot;scale&quot;: &quot;100&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 位置</span><br><span class="line">&quot;gauss&quot;: &#123; </span><br><span class="line">    &quot;location&quot;: &#123;</span><br><span class="line">        // 假设中心坐标是 11,12 </span><br><span class="line">        &quot;origin&quot;: &quot;11, 12&quot;,</span><br><span class="line">        &quot;scale&quot;: &quot;2km&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-full-text-query"><a href="#3-2-full-text-query" class="headerlink" title="3.2 full text query"></a>3.2 full text query</h3><ul>
<li><code>intervals</code>（跳过）</li>
<li><code>match</code>、<code>match boolean prefix</code>、<code>match phrase</code> 、<code>match phrase prefix</code></li>
<li>multi match</li>
<li>common term query</li>
<li>query string 与 simple query string</li>
</ul>
<h4 id="match-boolean-prefix-和-match-phrase-prefix-的使用案例"><a href="#match-boolean-prefix-和-match-phrase-prefix-的使用案例" class="headerlink" title="match boolean prefix 和 match phrase prefix 的使用案例"></a><code>match boolean prefix</code> 和 <code>match phrase prefix</code> 的使用案例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET index_name/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_bool_prefix&quot; : &#123;</span><br><span class="line">            &quot;message&quot; : &quot;quick brown f&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">GET index_name/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot; : &#123;</span><br><span class="line">            &quot;should&quot;: [</span><br><span class="line">                &#123; &quot;term&quot;: &#123; &quot;message&quot;: &quot;quick&quot; &#125;&#125;,</span><br><span class="line">                &#123; &quot;term&quot;: &#123; &quot;message&quot;: &quot;brown&quot; &#125;&#125;,</span><br><span class="line">                &#123; &quot;prefix&quot;: &#123; &quot;message&quot;: &quot;f&quot;&#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 词语必须连在一起</span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase_prefix&quot;: &#123;</span><br><span class="line">      &quot;message&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;quick brown f&quot;,</span><br><span class="line">        &quot;slop&quot;: 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="multi-match"><a href="#multi-match" class="headerlink" title="multi match"></a>multi match</h4><p><code>most_fields</code> 等同于普通的 <code>should + match</code> 查询，各字段分值相加；<code>best_fields</code> 相当于 <code>disjunction max</code> 查询；<code>cross fields</code> 用于跨字段查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 字段名可以通过 ‘^’ 符号实现 boost 效果，* 实现字段通配符</span><br><span class="line">GET index_name/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot; : &#123;</span><br><span class="line">      &quot;query&quot;:    &quot;this is a test&quot;, </span><br><span class="line">      &quot;fields&quot;: [ &quot;subject^3&quot;, &quot;message&quot;, &quot;*_name&quot; ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// best_fields</span><br><span class="line">POST blogs/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;best_fields&quot;,</span><br><span class="line">      &quot;query&quot;: &quot;Quick pets&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;title&quot;,&quot;body&quot;],</span><br><span class="line">      &quot;tie_breaker&quot;: 0.2,</span><br><span class="line">      &quot;minimum_should_match&quot;: &quot;20%&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="common-term-query"><a href="#common-term-query" class="headerlink" title="common term query"></a>common term query</h4><p>这个 <code>query</code> 是为了解决普通 <code>term_query</code> 存在的问题而延伸的功能，在介绍 <code>common term query</code> 之前，需要先了解 <code>term</code> 查询的问题点：</p>
<p>常规的 <code>term</code> 查询，例如 <code>the brown fox</code> 这个词需要拆分三个 <code>term</code> ，分别是 <code>the</code> 、<code>brown</code> 以及 <code>fox</code> ，每个 <code>term</code> 都会查询所有的文档，对于 <code>the</code> 这种通用的定冠词可以匹配到大量的文档。它对于的相关性影响应该更低，所以 <code>term</code> 查询的处理方法是将 <code>the</code> 视为停用词，这样不仅减小了索引空间占用，也减少了扫描文档的数量。但是也带了一个新的问题，虽然 <code>the</code> 对于结果的相关性影响更小，但依旧对文档的总得分是有影响的。视为停用词之后则此部分不再贡献相关性得分了。同时也会影响召回率：例如 <code>happy</code> 和 <code>not happy</code> 的判断将会不准确。</p>
<p><code>common term query</code> 将词分为两部分，<code>more important</code>（低频词） 和 <code>less important</code>（高频词）。查询时也分为两个步骤，先查找 <code>more important</code> 部分，此时返回的结果相对更少，然后查找 <code>less important</code> 部分，对相关性算分的贡献值更小，但不会查找全部文档，而是在 <code>more important</code> 的结果集中二次筛选。<br>如果所有的词都是 <code>less important</code> 的高频词，那默认情况下将通过 <code>AND</code> 将词语组合在一起进行一次查询。（可以通过 <code>minimum_should_match</code> 控制）。</p>
<p>判断关键词属于 <code>more important</code> 还是 <code>less important</code> 的参数是 <code>cutoff_frequency</code>（此参数是对于分片而言的） ,如下的查询中，词频超过 <code>1%</code> 的将作为 <code>less important</code>（高频词）,高频词之间采用 <code>OR</code> 关联，低频词采用 <code>AND</code> 关联（<code>match_query</code> 也支持该参数，但不支持 <code>*_freq_operator</code>）。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"common"</span>: &#123;</span><br><span class="line">            <span class="attr">"body"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"nelly the elephant as a cartoon"</span>,</span><br><span class="line">                <span class="attr">"cutoff_frequency"</span>: <span class="number">0.001</span>,</span><br><span class="line">                <span class="attr">"low_freq_operator"</span>: <span class="string">"and"</span>,</span><br><span class="line">                <span class="attr">"high_freq_operator"</span>: <span class="string">"or"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 大致相当于</span></span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"must"</span>: [</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"body"</span>: <span class="string">"nelly"</span>&#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"body"</span>: <span class="string">"elephant"</span>&#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"body"</span>: <span class="string">"cartoon"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"body"</span>: <span class="string">"the"</span>&#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"body"</span>: <span class="string">"as"</span>&#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"body"</span>: <span class="string">"a"</span>&#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还可以增加 minimum_should_match 控制 or 匹配的个数</span></span><br><span class="line">minimum_should_match: 2</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">"minimum_should_match": &#123;</span><br><span class="line">    "low_freq" : 2,</span><br><span class="line">    "high_freq" : 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-named-query"><a href="#3-3-named-query" class="headerlink" title="3.3 named query"></a>3.3 named query</h3><p>可以用于判断具体是哪个查询条件命中了数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot; : &#123;</span><br><span class="line">            &quot;should&quot; : [</span><br><span class="line">                &#123;&quot;match&quot; : &#123; &quot;name.first&quot; : &#123;&quot;query&quot; : &quot;shay&quot;, &quot;_name&quot; : &quot;first&quot;&#125; &#125;&#125;,</span><br><span class="line">                &#123;&quot;match&quot; : &#123; &quot;name.last&quot; : &#123;&quot;query&quot; : &quot;banon&quot;, &quot;_name&quot; : &quot;last&quot;&#125; &#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;filter&quot; : &#123;</span><br><span class="line">                &quot;terms&quot; : &#123;</span><br><span class="line">                    &quot;name.last&quot; : [&quot;banon&quot;, &quot;kimchy&quot;],</span><br><span class="line">                    &quot;_name&quot; : &quot;test&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-scripting总结"><a href="#4-scripting总结" class="headerlink" title="4. scripting总结"></a>4. scripting总结</h2><p>script 可以用的地方很多，目前包括了 reindex、pipeline、update、update_by_query、script_score、script_fields、search_templatey 以及 script 聚合等。场景非常广泛。复习此部分时刚好解决了群里小伙伴的一个疑问</p>
<h3 id="群友提问-script-如何实现-split字符串分割"><a href="#群友提问-script-如何实现-split字符串分割" class="headerlink" title="群友提问 script 如何实现 split字符串分割"></a>群友提问 script 如何实现 split字符串分割</h3><p>场景数据如下，希望将 <code>b</code> 字段分割为数组存到新字段中，在 <code>reindex</code> 时发现 <code>pipeline</code> 可以实现，但使用 <code>script</code> 脚本时确报错编译失败：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE index_a/_doc/1</span><br><span class="line"></span><br><span class="line">PUT index_a/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;a&quot; : &quot;aaaa&quot;,</span><br><span class="line">  &quot;b&quot;: &quot;asdf,asgeg,geg,saeg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>painless</code> 与 <code>java</code> 语言是类似的，经查看 <code>String</code> 类的 <code>split</code> 方法参数为正则 <code>regex</code> 表达式。所以直接使用 <code>,</code> 会编译失败，而使用 <code>/,/</code> 正则表达式时则会提示需要设置 <code>yml</code> 参数 <code>script.painless.regex.enabled: true</code> ，默认情况下正则是关闭的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET index_a/_doc/1</span><br><span class="line">POST index_a/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;:&#123;</span><br><span class="line">    &quot;source&quot;:&quot;&quot;&quot;</span><br><span class="line">    ctx._source.b_list = ctx._source.b.split(/,/)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 错误信息</span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;root_cause&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;script_exception&quot;,</span><br><span class="line">        &quot;reason&quot;: &quot;compile error&quot;,</span><br><span class="line">        &quot;script_stack&quot;: [</span><br><span class="line">          &quot;... st = ctx._source.b.split(/,/)&quot;,</span><br><span class="line">          &quot;                             ^---- HERE&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;script&quot;: &quot;    ctx._source.b_list = ctx._source.b.split(/,/)&quot;,</span><br><span class="line">        &quot;lang&quot;: &quot;painless&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;type&quot;: &quot;script_exception&quot;,</span><br><span class="line">    &quot;reason&quot;: &quot;compile error&quot;,</span><br><span class="line">    &quot;script_stack&quot;: [</span><br><span class="line">      &quot;... st = ctx._source.b.split(/,/)&quot;,</span><br><span class="line">      &quot;                             ^---- HERE&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;script&quot;: &quot;    ctx._source.b_list = ctx._source.b.split(/,/)&quot;,</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;caused_by&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;illegal_state_exception&quot;,</span><br><span class="line">      &quot;reason&quot;: &quot;Regexes are disabled. Set [script.painless.regex.enabled] to [true] in elasticsearch.yaml to allow them. Be careful though, regexes break out of Painless&apos;s protection against deep recursion and long loops.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot;: 400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种解决办法：使用 <code>StringTokenizer</code> 拆分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST index_a/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;:&#123;</span><br><span class="line">    &quot;source&quot;:&quot;&quot;&quot;</span><br><span class="line">    String b = ctx._source.b;</span><br><span class="line">    ArrayList b_list = new ArrayList();</span><br><span class="line">    if(!b.isEmpty())&#123;</span><br><span class="line">      String splitter = &quot;,&quot;;</span><br><span class="line">      StringTokenizer token = new StringTokenizer(b,splitter);</span><br><span class="line">      while(token.hasMoreTokens())&#123;</span><br><span class="line">        b_list.add(token.nextToken());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx._source.b_list = b_list;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-mapping-总结"><a href="#5-mapping-总结" class="headerlink" title="5. mapping 总结"></a>5. mapping 总结</h2><h3 id="5-1-normalizer"><a href="#5-1-normalizer" class="headerlink" title="5.1 normalizer"></a>5.1 normalizer</h3><p>normalizer 是用于解决 keyword 类型的数据规范问题的，例如某个字段设置为了 keyword 类型，但数据清洗时存在的不规范导致了两种数据 apple、Apple，由于 keyword 类型的性质，导致两者成为了不同的单词。</p>
<p>normalizer 会在数据写入之前进行统一处理，例如使用 <code>filter: lowercase</code> 将 <code>apple</code> 和 <code>Apple</code> 统一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE test_normalizer</span><br><span class="line"># 自定义 normalizer</span><br><span class="line">PUT test_normalizer</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;analysis&quot;: &#123;</span><br><span class="line">      &quot;normalizer&quot;: &#123;</span><br><span class="line">        &quot;lowercase&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;custom&quot;,</span><br><span class="line">          &quot;filter&quot;: [</span><br><span class="line">            &quot;lowercase&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;doc&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;type_normalizer&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">          &quot;normalizer&quot;: &quot;lowercase&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT test_normalizer/doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;apple&quot;,</span><br><span class="line">  &quot;type_normalizer&quot;: &quot;apple&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT test_normalizer/doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Apple&quot;,</span><br><span class="line">  &quot;type_normalizer&quot;: &quot;Apple&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 查询三</span><br><span class="line">GET test_normalizer/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;:&#123;</span><br><span class="line">      &quot;type&quot;:&quot;aPple&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 查询四</span><br><span class="line">GET test_normalizer/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;:&#123;</span><br><span class="line">      &quot;type_normalizer&quot;:&quot;aPple&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-Dynamic-mapping"><a href="#5-2-Dynamic-mapping" class="headerlink" title="5.2 Dynamic mapping"></a>5.2 Dynamic mapping</h3><p> <strong><code>dynamic_field_mapping</code></strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//日期推断</span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;create_date&quot;: &quot;2015/09/02&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_mapping</span><br><span class="line">//关闭推断</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;date_detection&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/1 </span><br><span class="line">&#123;</span><br><span class="line">  &quot;create&quot;: &quot;2015/09/02&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 格式化</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;dynamic_date_formats&quot;: [&quot;MM/dd/yyyy&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;create_date&quot;: &quot;09/25/2015&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 数字推断</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;numeric_detection&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;my_float&quot;:   &quot;1.0&quot;, </span><br><span class="line">  &quot;my_integer&quot;: &quot;1&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>dynamic_template</strong></p>
<ul>
<li>字段类型匹配：<code>match_mapping_type</code></li>
<li>字段名称匹配：<code>match</code>、<code>unmatch</code>、<code>match_pattern</code></li>
<li>字段通配符：<code>path_match</code>、<code>path_unmatch</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//match_mapping_type、match</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;dynamic_templates&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;longs_as_strings&quot;: &#123;</span><br><span class="line">          &quot;match_mapping_type&quot;: &quot;string&quot;,</span><br><span class="line">          &quot;match&quot;:   &quot;long_*&quot;,</span><br><span class="line">          &quot;unmatch&quot;: &quot;*_text&quot;,</span><br><span class="line">          &quot;mapping&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;long&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// path_match</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;dynamic_templates&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;full_name&quot;: &#123;</span><br><span class="line">          &quot;path_match&quot;:   &quot;name.*&quot;,</span><br><span class="line">          &quot;path_unmatch&quot;: &quot;*.middle&quot;,</span><br><span class="line">          &quot;mapping&quot;: &#123;</span><br><span class="line">            &quot;type&quot;:       &quot;text&quot;,</span><br><span class="line">            &quot;copy_to&quot;:    &quot;full_name&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><code>dynamic</code> 的三种级别： <code>true</code>、<code>false</code>、<code>strict</code></strong>，可以用在 <code>properties</code> 同级，也可以用在字段上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT index_name</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;dynamic&quot;: &quot;strict&quot;,</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;social_networks&quot;: &#123;</span><br><span class="line">        &quot;dynamic&quot;: true,</span><br><span class="line">        &quot;properties&quot;: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-docvalue-fields查询、data-nanos类型"><a href="#5-3-docvalue-fields查询、data-nanos类型" class="headerlink" title="5.3 docvalue_fields查询、data_nanos类型"></a>5.3 docvalue_fields查询、data_nanos类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE my_index</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;date&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;date_nanos&quot; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123; &quot;date&quot;: &quot;2015-01-01&quot; &#125; </span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/2</span><br><span class="line">&#123; &quot;date&quot;: &quot;2015-01-01T12:10:30.123456789Z&quot; &#125; </span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/3</span><br><span class="line">&#123; &quot;date&quot;: 1420070400 &#125; </span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;sort&quot;: &#123; &quot;date&quot;: &quot;asc&quot;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  &quot;docvalue_fields&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;field&quot; : &quot;date&quot;,</span><br><span class="line">      &quot;format&quot;: &quot;strict_date_time&quot; </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-index-options"><a href="#5-4-index-options" class="headerlink" title="5.4 index_options"></a>5.4 index_options</h3><p><code>index_options</code> 参数控制向倒排索引添加哪些信息，主要用于搜索和高亮。有下面四种参数： </p>
<ul>
<li><code>docs</code> 仅索引文档的 <code>id</code>，可以用于判断该 <code>term</code> 在这个字段是否出现过；</li>
<li><code>freqs</code> 索引文档的 id 和 term 的词频。计算相关性得分时，词频高的 <code>term</code>  分数会更高 ；</li>
<li><code>positions</code> 索引文档的 <code>id</code> 和 <code>term</code> 的词频以及 <code>term</code> 的位置信息。位置对于 <code>phrase</code> 这种短语查询很重要。默认情况下字段属性 <code>index:true</code> 都会使用 <code>positions</code>，数字使用的是 <code>docs</code>；</li>
<li><code>offsets</code> 在 <code>positions</code> 的索引基础上增加了开始字符以及结束字符的偏移量，偏移量对于 <code>unified highlighter</code> 高亮（默认的高亮方式）来说可以加速高亮。</li>
</ul>
<h2 id="6-tips"><a href="#6-tips" class="headerlink" title="6.  tips"></a>6.  tips</h2><ul>
<li><p>集群的 <code>settings</code> 设置优先级顺序为： <code>transient &gt; persistent &gt; elasticsearch.yml</code>；</p>
</li>
<li><p><code>indices.query.bool.max_clause_count</code> 限制了单次查询的字段数量，默认为 <code>1024</code>；</p>
</li>
<li><p><code>fielddata</code> 用于开启  <code>text</code>  类型字段的聚合；</p>
</li>
<li><p><code>script</code> 小技巧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过 random 获取随机数</span><br><span class="line">Random random = new Random();</span><br><span class="line">ctx._source.age = random.nextInt(100);</span><br><span class="line"></span><br><span class="line">// 取当前日期、时间戳</span><br><span class="line">ctx._source.birthday = new Date();</span><br><span class="line">ctx._source.birthday = new Date().getTime();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><img src="/images/202104/jane.png" alt="Alt"></p>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes集群组件介绍</title>
    <url>/2019/07/20/kubernetes%E9%9B%86%E7%BE%A4%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>一个<code>Kubernetes</code>集群，通常是由多个工作节点<code>Worker Node</code>加上一个集群控制者<code>Master</code>，以及集群状态存储系统<code>etcd</code>组成。</p>
<h4 id="Master-Node"><a href="#Master-Node" class="headerlink" title="Master Node"></a>Master Node</h4><p><code>Master</code>节点主要由负责 <code>API</code> 服务的<code>apiserver</code>、负责容器编排的<code>controller-manager</code>、以及负责调度的<code>scheduler</code>组成。整个集群的持久化数据，由<code>apiserver</code>处理后，交由<code>etcd</code>进行管理。</p>
<ul>
<li><p><code>API server</code>负责<code>Restful</code>风格的<code>kubernetes API</code>，负责接收、响应、校验发入集群的所有<code>REST</code>请求。</p>
</li>
<li><p><code>Controller Manager</code> 负责维护集群的状态，包括很多资源的控制器，是保证 <code>Kubernetes</code>声明式 <code>API</code> 工作的大脑，比如故障检测、自动扩展、滚动更新等。<a id="more"></a></p>
</li>
<li><p><code>Scheduler</code>负责管理集群内各节点的资源状态。创建<code>Pod</code>时，根据合适的资源做出调度决策。在创建<code>Pod</code>的<code>Events</code>中可以看到，第一个<code>Event</code>便是<code>Schedule</code>。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe pod image-sign-deployment-59948dd446-8n8l7</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  108s  default-scheduler  Successfully assigned default/image-sign-deployment-59948dd446-8n8l7 to node2</span><br><span class="line">  Normal  Pulled     107s  kubelet, node2     Container image &quot;image-sign&quot; already present on machine</span><br><span class="line">  Normal  Created    107s  kubelet, node2     Created container image-sign</span><br><span class="line">  Normal  Started    106s  kubelet, node2     Started container image-sign</span><br></pre></td></tr></table></figure>
<h4 id="Worker-Node"><a href="#Worker-Node" class="headerlink" title="Worker Node"></a>Worker Node</h4><p>在<code>worker Node</code>中，最重要的则是<strong>kubelet</strong>，<strong>它所负责的是与容器运行时打交道（如docker项目）</strong>。他们交互所依赖的，是一个称作<code>CRI</code>的远程调用接口，这个接口定义了容器运行时的各项核心操作。如启动一个容器所需的所有参数。  </p>
<p>也正是因为<code>CRI</code>的存在，<code>kubernetes</code>并不关系用户部署的容器运行时是<code>Docker</code>亦或是其它的（但默认的是<code>Docker</code>），只要这个容器运行时能运行标准的镜像，它就能通过实现<code>CRI</code>接入到<code>Kubernetes</code>中。  </p>
<p>具体的容器运行时，像<code>Docker</code>则一般通过<code>OCI</code>这个容器运行时规范，与底层的<code>Linux</code>操作系统进行交互。即：将<code>CRI</code>请求翻译成对<code>Linux</code>系统的调用，操作系统的<code>NameSpace</code>和<code>CGroups</code>等。</p>
<p>此外，<strong>kubelet 还通过 gRPC 协议同一个叫作 Device Plugin 的插件进行交互</strong>。这个插件，是 <code>Kubernetes</code> 项目用来管理 <code>GPU</code> 等宿主机物理设备的主要组件，也<strong>是基于 Kubernetes 项目进行机器学习训练、高性能作业支持等工作必须关注的功能</strong>。</p>
<p><strong>kubelet 的另一个重要功能，则是调用网络插件和存储插件为容器配置网络和持久化存储</strong>。这两个插件与 <code>kubelet</code> 进行交互的接口，分别是 <code>CNI（Container Networking Interface）</code>和 <code>CSI（Container Storage Interface）</code>。</p>
<p>而<code>kube-proxy</code>，它所负责的是能够按需为<code>Service</code>资源对象创建<code>iptables</code>或<code>ipvs</code>规则。从而捕获访问当前访问<code>Service</code>的请求，将其转发至正确的<code>Pod</code>对象</p>
<h3 id="系统组件图"><a href="#系统组件图" class="headerlink" title="系统组件图"></a>系统组件图</h3><p><img src="/images/kubernetes-component.png" alt="image"></p>
<h4 id="核心附件"><a href="#核心附件" class="headerlink" title="核心附件"></a>核心附件</h4><p><code>kubernetes</code>还需要依赖一组称为“附件”的组件来提供完整的功能。这些组件通常由第三方提供，运行在<code>kubernetes</code>集群上。</p>
<ul>
<li><p><code>CoreDNS</code> 在<code>Kubernetes</code>集群中调度运行提供<code>DNS</code>服务的<code>Pod</code>，同一集群中的其他<code>Pod</code>可使用此<code>DNS</code>服务实现<code>service name</code>到 <code>cluster IP</code>的解析 。<code>DNS</code>服务是<code>Kubernetes</code>赖以实现服务发现的核心组件之一，默认情况下只会创建一个<code>DNS Pod</code>，在生产环境中我们需要对<code>coredns</code>进行扩容。 有两种方式：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">手动扩容 kubectl –namespace=kube-system scale deployment coredns –replicas=</span><br><span class="line">使用 DNS Horizontal Autoscaler</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Kubernetes Dashboard</code>： 一个<code>Web UI</code>,用于管理<code>kubernetes</code>集群中应用，以及集群自身。</p>
</li>
<li><p><code>Ingress Controller</code>： 暂时没学到相关内容。之后再来补充。</p>
</li>
</ul>
<p><img src="/images/modeganqing.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab-ci、cd初步使用及踩坑</title>
    <url>/2019/12/21/gitlab-ci%E3%80%81cd%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><p>CI全称为<code>Continuous Integration</code>代表持续集成的意思，通俗来说就是持续的自动构建（单元测试、打包等）。</p>
<p>CD全称为<code>Continuous Deployment</code>代表持续交付的意思，在代码构建完成后自动部署上线。</p>
<h3 id="gitlab-ci-cd"><a href="#gitlab-ci-cd" class="headerlink" title="gitlab-ci/cd"></a>gitlab-ci/cd</h3><p>基于<code>gitlab</code>的一套<code>ci/cd</code>工具<a id="more"></a></p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><h3 id="1-ci文件配置"><a href="#1-ci文件配置" class="headerlink" title="1.ci文件配置"></a>1.ci文件配置</h3><p><code>gitlab-ci</code>是<code>gitlab</code>自带的功能，只需在项目的根目录添加一个<code>.gitlab-ci.yml</code>的文件名即可。例如我所使用的这个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stages:</span><br><span class="line">    - build</span><br><span class="line">    - qbjsonar</span><br><span class="line"></span><br><span class="line">build-job:</span><br><span class="line">    stage: build</span><br><span class="line">    only: </span><br><span class="line">        - dev</span><br><span class="line">    script:</span><br><span class="line">        - cd zhsfsjfw/ &amp;&amp; pwd</span><br><span class="line">        - mvn clean package</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sonar-job:</span><br><span class="line">    stage: qbjsonar</span><br><span class="line">    only: </span><br><span class="line">        - dev</span><br><span class="line">    script:</span><br><span class="line">        - echo &apos;准备对`qbj`项目代码做sonar的质量检查！</span><br><span class="line">        - cd zhsfsjfw/</span><br><span class="line">        - mvn compile</span><br><span class="line">        - mvn sonar:sonar -Dsonar.host.url=http://172.16.34.102:9000 -Dsonar.login=497a0e0e2fc07f64c4b54edc17bb47dfa251ba34</span><br><span class="line"></span><br><span class="line">在上述这个`yml`文件中</span><br></pre></td></tr></table></figure>
<ul>
<li><code>stages</code>为具体步骤，名称均为自定义。</li>
<li><code>only</code>代表只对<code>dev</code>分支进行<code>ci/cd</code>操作，其余分支不触发</li>
<li><code>script</code>代表具体执行的脚本</li>
</ul>
<p>在有了这个文件之后，<code>gitlab</code>便会去寻找与之绑定的<code>gitlab-runner</code>(即具体执行<code>script</code>的所在服务器)。</p>
<h3 id="安装runner"><a href="#安装runner" class="headerlink" title="安装runner"></a>安装runner</h3><p>这里我是用的是<code>docker</code>来运行<code>gitlab-runner</code>，命令为各处都能搜索到的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run -d --name gitlab-runner --restart always \</span><br><span class="line">    -v /srv/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure>
<p>运行成功后<code>runner</code>就安装成功了，接下来需要配置与<code>gitlab-ci</code>的连接信息，进入容器进行注册：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it gitlab-runner gitlab-ci-multi-runner register</span><br><span class="line">...</span><br><span class="line">输入你搭建的gitlab地址:</span><br><span class="line">http://gitlab.hoppou.com</span><br><span class="line">输入gitlab-ci的token：</span><br><span class="line">（此处需要访问gitlab，找到项目的Settings，拿到相应的token值）</span><br><span class="line">输入runner的描述：</span><br><span class="line">测试runner</span><br><span class="line">输入runner的tag：</span><br><span class="line">mytag</span><br><span class="line">输入runner的执行器，包含docker，shell等多种执行器：</span><br><span class="line">shell</span><br></pre></td></tr></table></figure>
<p>完成之后，重启<code>runner</code>使注册生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart gitlab-runner</span><br></pre></td></tr></table></figure>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>可以看到，我的<code>gitlab-ci</code>文件中，使用了<code>mvn</code>命令进行打包操作，而<code>runner</code>镜像本身是没有<code>java</code>环境及<code>maven</code>环境的。所以会出现以下情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Running with gitlab-runner 12.5.0 (577f813d)</span><br><span class="line">  on 测试runner Z6hhKYEA</span><br><span class="line">Using Shell executor...</span><br><span class="line">Running on cf7b491f673d...</span><br><span class="line">Fetching changes with git depth set to 50...</span><br><span class="line">Initialized empty Git repository in /home/gitlab-runner/builds/Z6hhKYEA/0/CDSFXZ/SF_SFXZ_OUTSOURCING/fy_scqbj_zhsfsjfw/.git/</span><br><span class="line">Created fresh repository.</span><br><span class="line">From http://gitlab.thunisoft.com/CDSFXZ/SF_SFXZ_OUTSOURCING/fy_scqbj_zhsfsjfw</span><br><span class="line"> * [new branch]      dev        -&gt; origin/dev</span><br><span class="line">Checking out c6ae4335 as dev...</span><br><span class="line">Skipping object checkout, Git LFS is not installed.</span><br><span class="line"></span><br><span class="line">Skipping Git submodules setup</span><br><span class="line">$ cd zhsfsjfw/ &amp;&amp; pwd</span><br><span class="line">/home/gitlab-runner/builds/Z6hhKYEA/0/CDSFXZ/SF_SFXZ_OUTSOURCING/fy_scqbj_zhsfsjfw/zhsfsjfw</span><br><span class="line">$ mvn clean package</span><br><span class="line">bash: line 79: mvn: command not found</span><br><span class="line">ERROR: Job failed: exit status 1</span><br></pre></td></tr></table></figure>
<p>这里<strong>最好的方式，还是基于<code>runner</code>镜像，编写一个<code>dockerfile</code></strong>，将<code>java</code>和<code>maven</code>环境安装到<code>runner</code>中 </p>
<p>（不过我发现的太晚了，又不想动手写<code>dockerfile</code>…..）</p>
<p>于是我想了个骚方法- -。启动容器时，将<code>java</code>和<code>maven</code>的文件夹挂载到容器中去，于是我的启动命令变成了这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always  \</span><br><span class="line">-v /home/volume/jdk1.8.0_211:/usr/local/jdk1.8.0_211 \</span><br><span class="line">-v /home/volume/apache-maven-3.6.3:/usr/local/apache-maven-3.6.3 \</span><br><span class="line">--env JAVA_HOME=/usr/local/jdk1.8.0_211 \</span><br><span class="line">--env MAVEN_HOME=/usr/local/apache-maven-3.6.3 \</span><br><span class="line">--env PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin \</span><br><span class="line">--privileged=true gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure>
<p>好像起初一看没什么问题？一番操作后，还是报错找不到<code>mvn</code>命令。于是进入到容器中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it gitlab-runner /bin/sh</span><br><span class="line"># env</span><br><span class="line">HOSTNAME=8014398ff403</span><br><span class="line">HOME=/root</span><br><span class="line">MAVEN_HOME=/usr/local/apache-maven-3.6.3</span><br><span class="line">TERM=xterm</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">DEBIAN_FRONTEND=noninteractive</span><br><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_211</span><br><span class="line">PWD=/</span><br></pre></td></tr></table></figure>
<p>原来容器内部的<code>PATH</code>环境变并未发生更改，具体原因我猜测是<code>docker run</code>命令中使用的<code>$JAVA_HOME/bin</code>等并没有作为字符串传到容器中去，命令解析时是以宿主机的环境变量为准，而我宿主机并未配置该环境变量。</p>
<p>在我直接按照如下方式写的时候，是可以起效的：（不过谁会愿意这么些呢。。。又臭又长）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- env PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/jdk1.8.0_211/bin:/usr/local/apache-maven-3.6.3/bin</span><br></pre></td></tr></table></figure></p>
<p>于是我<strong>去掉了对PATH变量的赋值</strong>，修改<code>gitlabc-ci</code>文件为如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stages:</span><br><span class="line">    - build</span><br><span class="line">    - qbjsonar</span><br><span class="line"></span><br><span class="line">build-job:</span><br><span class="line">    stage: build</span><br><span class="line">    only: </span><br><span class="line">        - dev</span><br><span class="line">    script:</span><br><span class="line">        - cd zhsfsjfw/ &amp;&amp; pwd</span><br><span class="line">        - $MAVEN_HOME/bin/mvn clean package</span><br><span class="line">    tags: </span><br><span class="line">        - mytag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sonar-job:</span><br><span class="line">    stage: qbjsonar</span><br><span class="line">    only: </span><br><span class="line">        - dev</span><br><span class="line">    script:</span><br><span class="line">        - echo &apos;准备对`qbj`项目代码做sonar的质量检查！</span><br><span class="line">        - cd zhsfsjfw/</span><br><span class="line">        - $MAVEN_HOME/bin/mvn compile</span><br><span class="line">        - $MAVEN_HOME/bin/mvn sonar:sonar -Dsonar.host.url=http://172.16.34.102:9000 -Dsonar.login=497a0e0e2fc07f64c4b54edc17bb47dfa251ba34</span><br><span class="line">    tags: </span><br><span class="line">        - mytag</span><br></pre></td></tr></table></figure>
<p>除<code>script</code>的命令修改之外，可以看到我还添加了<code>tags</code>标签，这里匹配的是注册<code>runner</code>时，自己填写的<code>tag</code>。可以在<code>gitlab</code>的<code>settings</code>页面进行修改。</p>
<p>如果不想配置<code>tags</code>，可以进入<code>settings --&gt; CI/CD --&gt; Runners Settings</code>,找到启用的<code>runner</code> –&gt; 编辑：</p>
<p><img src="/images/201912/gitlab-runner-runonnoTag.png" alt="image"></p>
<p>若<code>yml</code>没有指定<code>tags</code>，<code>settings</code>中也没有勾选该配置，<strong>那么任务会一直处于<code>pending</code>状态</strong>，提示找不到<code>runner</code>。</p>
<p>最后再提一下关于<code>docker</code>命令中 <code>--privileged=true</code>,起初我没有添加该配置- -，虽然可以找到<code>mvn</code>命令了，但<code>ci</code>报错提示没有权限。虽然容器中默认是用的<code>root</code>用户，但这个<code>root</code>只具有容器内部的<code>root</code>权限，针对挂载的目录，他并不能操作宿主机的文件，加上<code>--privileged=true</code>后就可以了。</p>
<p>另：<code>ci</code>发送指令给<code>runner</code>时是自己创建了一个名为<code>gitlab-runner</code>的用户(并非<code>root</code>),所以如果有别的权限问题，可以考虑将文件移动到 <code>/home/gitlab-runner</code>下操作，即可解决。</p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>painless script的使用</title>
    <url>/2021/06/14/painless%20script%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Painless</code> 是一种简单、安全的脚本语言，专为与 <code>Elasticsearch</code> 一起使用而设计。它是 <code>Elasticsearch</code> 的默认脚本语言，可以安全地用于内联和存储脚本。</p>
<ul>
<li>高性能：运行速度非常快；</li>
<li>安全性：具有方法调用/字段粒度的细粒度白名单；</li>
<li>变量和参数可以使用显示类型或动态的可变类型；</li>
<li>语法：扩展自 <code>java</code> 语法，使用方便；</li>
<li>优化：专为 <code>elasticsearch</code> 设计</li>
</ul>
<p>使用场景：<code>script_score</code>、<code>script_fields</code>、<code>update_by_query</code>、<code>update</code>、<code>pipeline</code> 以及 <code>script</code> 聚合等等。<a id="more"></a></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>总的来说， <code>painless</code> 的语法与 <code>java</code> 基本一致，常规的条件判断 <code>if</code>、<code>for</code> 循环、<code>while</code>、新建对象 <code>new</code> 等用法都是一样的，下面主要记录了一些有区别，以及特殊的地方</p>
<h3 id="取值方式"><a href="#取值方式" class="headerlink" title="取值方式"></a>取值方式</h3><p>对 <code>painless</code> 来说，文档的数据一般存储在 <code>ctx</code>、<code>ctx._source</code>、<code>doc</code> 里，取值方式类似 <code>javascript</code> 的方式，通过 <code>.fieldname</code> 或者 <code>[&#39;fieldname&#39;]</code> 取值均可。</p>
<p>根据常用的 <code>API</code> ，可以大致分为以下几个：</p>
<ul>
<li><code>script_score</code> 、 <code>script_field</code>、<code>sort</code>、<code>filter</code> 等存储在 <code>doc</code> 中，查询需要使用 <code>doc[&#39;field&#39;].value</code> 或者 <code>params[&#39;_source&#39;][&#39;field&#39;]</code> 来取值；</li>
<li><code>_update_by_query</code>、<code>reindex</code> 等存储在 <code>ctx._source</code> 中，需要使用 <code>ctx._source.field</code> 取值；</li>
<li><code>ingest pipeline</code> 存储在 <code>ctx</code> 中，直接使用 <code>ctx.field</code> 取值；</li>
<li>特例： <code>foreach processor</code> 遍历处理器，需要使用 <code>_ingest._value</code> 来取值</li>
</ul>
<p>详情可参考 <a href="https://www.elastic.co/guide/en/elasticsearch/painless/7.2/painless-contexts.html" target="_blank" rel="noopener">painless context</a>, 需要注意的是 <code>params[&#39;_source&#39;][&#39;field&#39;]</code> 这种取值方式在 <code>painless</code> 的文档中没有明确说明，需参考在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/search-request-script-fields.html" target="_blank" rel="noopener"> script_fields 中的说明</a></p>
<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><table>
<thead>
<tr>
<th>if</th>
<th>else</th>
<th>while</th>
<th>do</th>
<th style="text-align:left">for</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>in</strong></td>
<td><strong>continue</strong></td>
<td><strong>break</strong></td>
<td><strong>return</strong></td>
<td style="text-align:left"><strong>new</strong></td>
</tr>
<tr>
<td><strong>try</strong></td>
<td><strong>catch</strong></td>
<td><strong>throw</strong></td>
<td><strong>this</strong></td>
<td style="text-align:left"><strong>instanceof</strong></td>
</tr>
</tbody>
</table>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li><p><code>for</code> 循环既可以使用普通的 <code>fori</code> 循环也可以使用 <code>for(int i : xxx)</code> 这种语法糖；</p>
</li>
<li><p>获取数组长度时，使用 <code>.length</code> 和 <code>.size()</code> 两种取值方式均可</p>
</li>
</ul>
<h3 id="日期操作"><a href="#日期操作" class="headerlink" title="日期操作"></a>日期操作</h3><p><code>painless</code> 会将 <code>mapping</code> 映射为 <code>date</code> 类型的字段当做 <code>zonedateTime</code> 来处理，因此支持 <code>getYear</code>，<code>getDayOfWeek</code>，<code>getMillis</code> 等操作，但在编写脚本时，省略掉了 <code>get</code> 前缀，只需要小写方法名称的其余部分，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET hockey/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script_fields&quot;: &#123;</span><br><span class="line">    &quot;birth_year&quot;: &#123;</span><br><span class="line">      &quot;script&quot;: &#123;</span><br><span class="line">        &quot;source&quot;: &quot;doc.born.value.year + &apos;,&apos; + doc.born.value.monthValue&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>出于正则表达式的性能原因，<code>painless</code> 中默认是禁用了的，需要在配置文件中开启：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script.painless.regex.enabled: true</span><br></pre></td></tr></table></figure></p>
<p>使用正则时需要以 <code>/</code>  符号作为正则的起始和结束标志，正则表达式写在斜线的中间部分，列如,匹配字符串是否以 <code>b</code> 开头：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST hockey/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;source&quot;: &quot;&quot;&quot;</span><br><span class="line">      if (ctx._source.last =~ /b/) &#123;</span><br><span class="line">        ctx._source.last += &quot;matched&quot;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ctx.op = &quot;noop&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="额外的动态类型-def"><a href="#额外的动态类型-def" class="headerlink" title="额外的动态类型 def"></a>额外的动态类型 def</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def dp = 1;</span><br><span class="line">def dr = new ArrayList();</span><br><span class="line">dr = dp;</span><br></pre></td></tr></table></figure>
<h3 id="painless-函数声明及运作方式"><a href="#painless-函数声明及运作方式" class="headerlink" title="painless 函数声明及运作方式"></a>painless 函数声明及运作方式</h3><p>以 <code>s.foo(a,b)</code> 调用为例，<code>painless</code> 在执行时会先获取到类 s 然后查找带有两个参数以及方法名为 <code>foo</code> 的方法进行调用，这种方式使得 <code>painless</code> 不像 <code>java</code> 那样支持重载，列如 <code>java</code> 中的 <code>Matcher</code> 类有两个方法 <code>group(int)</code> 和 <code>group(String)</code> ，由于他们的参数数量和方法名都相同，<code>painless</code> 将无法分辨，所以 <code>painless</code> 中使用 <code>group(int)</code> 和 <code>namedGroup(String)</code> 两个方法来进行区分</p>
<p><strong>函数声明:</strong></p>
<p>在调用方法前声明函数即可，在 <code>painless</code> 中的 <code>String</code> 类是不具备 <code>split</code> 函数的，如下的示例展示了一个自定义的 split 和使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST index_a/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;a&quot; : &quot;aaaa&quot;,</span><br><span class="line">  &quot;b&quot; : &quot;asdf,asgeg,geg,saeg&quot;</span><br><span class="line">&#125;</span><br><span class="line">POST index_a/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;&quot;&quot;</span><br><span class="line">    String[] split(String s, char d) &#123;                                   </span><br><span class="line">      int count = 0;</span><br><span class="line">      for (char c : s.toCharArray()) &#123;                                 </span><br><span class="line">          if (c == d) &#123;</span><br><span class="line">              ++count;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (count == 0) &#123;</span><br><span class="line">          return new String[] &#123;s&#125;;                                     </span><br><span class="line">      &#125;</span><br><span class="line">      String[] r = new String[count + 1];                              </span><br><span class="line">      int i0 = 0, i1 = 0;</span><br><span class="line">      count = 0;</span><br><span class="line">      for (char c : s.toCharArray()) &#123;                                 </span><br><span class="line">          if (c == d) &#123;</span><br><span class="line">              r[count++] = s.substring(i0, i1);</span><br><span class="line">              i0 = i1 + 1;</span><br><span class="line">          &#125;</span><br><span class="line">          ++i1;</span><br><span class="line">      &#125;</span><br><span class="line">      r[count] = s.substring(i0, i1);                                  </span><br><span class="line">      return r;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx._source.aaa = split(&apos;a,b,c&apos;,(char)&apos;,&apos;);</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="支持的API"><a href="#支持的API" class="headerlink" title="支持的API"></a>支持的API</h2><p><code>painless</code> 中支持的 <code>API</code> 可参考<a href="https://www.elastic.co/guide/en/elasticsearch/painless/7.2/painless-api-reference-shared.html" target="_blank" rel="noopener">这个地址</a></p>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql5.7-31 主从复制安装(windows)</title>
    <url>/2021/03/07/mysql5.7-31%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AE%89%E8%A3%85(windows)/</url>
    <content><![CDATA[<h4 id="准备两个MySQL服务实例"><a href="#准备两个MySQL服务实例" class="headerlink" title="准备两个MySQL服务实例"></a>准备两个MySQL服务实例</h4><blockquote>
<p>windows上可以用压缩版本，例如mysql-5.7.31-winx64.zip，解压文件夹再复制一份，添加my.ini配置文件。假设一个叫mysql-5.7.31-winx64，一个叫mysql-5.7.31-winx64-2，以为分别配置其为主和从</p>
</blockquote>
<h4 id="修改主mysql-5-7-31-winx64的my-ini"><a href="#修改主mysql-5-7-31-winx64的my-ini" class="headerlink" title="修改主mysql-5.7.31-winx64的my.ini"></a>修改主mysql-5.7.31-winx64的my.ini</h4><p>解压出来默认没有 <code>my.ini</code> 需要自己新建:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir = ./</span><br><span class="line">datadir = ./data</span><br><span class="line">port = 3316</span><br><span class="line">server_id = 16</span><br><span class="line"></span><br><span class="line">sql_mode=&quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;</span><br><span class="line">log_bin=mysql-bin</span><br><span class="line">binlog-format=Row</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="修改从mysql-5-7-31-winx64-2的my-ini"><a href="#修改从mysql-5-7-31-winx64-2的my-ini" class="headerlink" title="修改从mysql-5.7.31-winx64-2的my.ini"></a>修改从mysql-5.7.31-winx64-2的my.ini</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir = ./</span><br><span class="line">datadir = ./data</span><br><span class="line">port = 3326</span><br><span class="line">server_id = 26</span><br><span class="line"></span><br><span class="line">sql_mode=&quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;</span><br><span class="line">log_bin=mysql-bin</span><br><span class="line">binlog-format=Row</span><br></pre></td></tr></table></figure>
<h4 id="分别到相应目录执行初始化"><a href="#分别到相应目录执行初始化" class="headerlink" title="分别到相应目录执行初始化"></a>分别到相应目录执行初始化</h4><p>如果本机已经安装过 <code>3306</code>的 <code>mysql</code> ,可以直接使用 <code>mysqld</code>命令 (需要环境变量)。<code>--initialize-insecure</code> 表示不给 <code>root</code> 设置密码,否则会生成一个随机的密码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/mysqld.exe --defaults-file=my.ini --initialize-insecure</span><br></pre></td></tr></table></figure></p>
<h4 id="启动实例并连接"><a href="#启动实例并连接" class="headerlink" title="启动实例并连接"></a>启动实例并连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start ./bin/mysqld.exe</span><br></pre></td></tr></table></figure>
<p>使用 <code>powershell</code> 分别连接到主库和从库:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root  -h 127.0.0.1 -P3316</span><br><span class="line">mysql -u root  -h 127.0.0.1 -P3326</span><br></pre></td></tr></table></figure></p>
<h4 id="在主库执行"><a href="#在主库执行" class="headerlink" title="在主库执行"></a>在主库执行</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE USER 'repl'@'%' IDENTIFIED BY '123456';</span><br><span class="line">Query OK, 0 rows affected (0.11 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.10 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show master status;</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line">| mysql-bin.000002 |      747 |              |                  |                   |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>记录下 <code>show master status</code> 中 <code>file</code> 和 <code>position</code> 的值。</p>
<h4 id="在从库执行"><a href="#在从库执行" class="headerlink" title="在从库执行"></a>在从库执行</h4><p>根据在主库设置的用户名、密码、<code>file</code> 、<code>position</code> 修改如下的指令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO</span><br><span class="line">    MASTER_HOST=&apos;localhost&apos;,  </span><br><span class="line">    MASTER_PORT = 3316,</span><br><span class="line">    MASTER_USER=&apos;repl&apos;,      </span><br><span class="line">    MASTER_PASSWORD=&apos;123456&apos;,   </span><br><span class="line">    MASTER_LOG_FILE=&apos;mysql-bin.000002&apos;,</span><br><span class="line">    MASTER_LOG_POS=747;</span><br></pre></td></tr></table></figure></p>
<p>执行 <code>start slave</code>来启动主从复制，通过 <code>show slave status\G;</code> 查看从库状态:<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show slave status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State:</span><br><span class="line">                  Master_Host: localhost</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3316</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000002</span><br><span class="line">          Read_Master_Log_Pos: 747</span><br><span class="line">               Relay_Log_File: hoppo-relay-bin.000001</span><br><span class="line">                Relay_Log_Pos: 4</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000002</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB:</span><br><span class="line">              </span><br><span class="line">.................</span><br></pre></td></tr></table></figure></p>
<p>重点关注如下两行的值，需要为Yes才表示配置成功了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure></p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在主库执行<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database db;</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; use db</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; create table t1(id int);</span><br><span class="line">Query OK, 0 rows affected (0.17 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1(id) values(1),(2);</span><br><span class="line">Query OK, 2 rows affected (0.04 sec)</span><br></pre></td></tr></table></figure></p>
<p>在从库执行<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| Database           |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| information_schema |</span><br><span class="line">| db                 |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">use</span> db;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| Tables_in_db |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| t1           |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> t1;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>可以通过 <code>show master status\G</code>, <code>show slave status\G</code> 查看状态<br>可以能改过 <code>stop slave</code>, <code>start slave</code>来停止复制。</p>
<p><code>reset slave all</code> ,清除 <code>slave</code> 配置。</p>
<hr>
<p><img src="/images/202104/贝尔维尔.jpg" alt></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC 原理</title>
    <url>/2021/06/14/rpc%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="RPC-基本原理"><a href="#RPC-基本原理" class="headerlink" title="RPC 基本原理"></a>RPC 基本原理</h2><h3 id="RPC-是什么"><a href="#RPC-是什么" class="headerlink" title="RPC 是什么"></a>RPC 是什么</h3><p><code>RPC</code> 是远程过程调用（<code>Remote Procedure Call</code>）的缩写形式。</p>
<p><code>RPC</code> 的概念与技术早在 <code>1981</code> 年由 <code>Nelson</code> 提出。<code>1984</code> 年，<code>Birrell</code> 和 <code>Nelson</code> 把其<span style="color:red"><strong>用于支持异构型分布式系统间的通讯</strong></span>。<code>Birrell</code> 的 <code>RPC</code> 模型引入存根进程（<code>stub</code> ） 作为远程的本地代理，调用 <code>RPC</code> 运行时库来传输网络中的调用。<span style="color:red"><code>Stub</code> 和 <code>RPC runtime</code> 屏蔽了网络调用所涉及的许多细节</span>，特别是，参数的编码/译码及网络通讯是由 <code>stub</code> 和 <code>RPC runtime</code> 完成的，因此这一模式被各类 <code>RPC</code> 所采用。<a id="more"></a></p>
<h3 id="什么叫-RPC-呢？"><a href="#什么叫-RPC-呢？" class="headerlink" title="什么叫 RPC 呢？"></a>什么叫 RPC 呢？</h3><p><span style="color:red">简单来说，就是“像调用本地方法一样调用远程方法”</span>。如果我们的方法在本地，那么我们可以直接使用如下方式调用 <code>UserService</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserService service = new UserService();</span><br><span class="line">User user = service.findById(1);</span><br></pre></td></tr></table></figure>
<p>那有时候我们的方法实现类不在本地，对于分布式场景来说这种情况是很常见的，例如我现在使用的电影服务，需要调用用户服务的实现类。我们有以下几种办法：</p>
<ul>
<li>将用户服务的实现完全搬一份过来；</li>
<li>使用 <code>okHttp</code>、 <code>httpclient</code>、<code>restTemplate</code> 等工具自己远程去调用接口；</li>
<li>使用 RPC 。</li>
</ul>
<p>第一种方法显然不可取，而通过 <code>okhttp</code> 等工具需要我们自己来编写请求逻辑，且需要服务端提供相应的 <code>API</code> 接口才可。<br>使用 <code>RPC</code> 则只需要服务端提供实现类即可，不必要求有接口的开放。</p>
<p><code>RPC</code> 的使用伪代码大致如下：（<code>Rpcfx</code> 代指我们的 <code>RPC</code> 框架）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserService service = Rpcfx.create(UserService.class, url);</span><br><span class="line">User user = service.findById(1);</span><br></pre></td></tr></table></figure></p>
<p>那么，<code>RPC</code> 是怎么实现将本地调用的方法转为远程调用的呢？</p>
<h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><p><code>RPC</code> 的简化版原理如下图：（核心是代理机制）</p>
<p><img src="https://z3.ax1x.com/2021/06/30/RBrVB9.png" alt="RBrVB9.png"></p>
<p>具体的调用流程为：</p>
<ul>
<li>本地代理存根: <code>Stub</code>；</li>
<li>本地序列化反序列化；</li>
<li>网络通信；</li>
<li>远程序列化反序列化；</li>
<li>远程服务存根: <code>Skeleton</code>；</li>
<li>调用实际业务服务；</li>
<li>原路返回服务结果；</li>
<li>返回给本地调用方。</li>
</ul>
<p>简单的说，就是当本地发起调用后，<code>RPC</code> 使用动态代理将调用拦截下来，将要调用哪个类、哪个方法、以及方法参数进行序列化。然后通过 <code>HTTP</code> 或 <code>TCP</code> 协议发送到服务方，服务方通过<strong>服务查找</strong> ，取出具体要执行方法的实例。或者通过反射的方式来构建实例。最后将调用结果返回给客户端。</p>
<p>当然， <code>RPC</code> 框架需要特别注意异常处理、重试等机制。因为无论调用结果成功或失败，都需要将信息给到客户端来进行处理</p>
<h2 id="RPC-是如何设计的"><a href="#RPC-是如何设计的" class="headerlink" title="RPC 是如何设计的"></a>RPC 是如何设计的</h2><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>客户端与服务端需要共享什么东西？ </p>
<p>由于 <code>RPC</code> 是基于接口的远程调用，客户端和服务端需要<span style="color:red">共享接口和实体的定义</span>。注意，这里强调了是定义，而不是直接说的共享接口和实体。</p>
<p>对于 <code>java</code> 平台而言我们可以直接共享接口和定义。但是对于跨语言间的调用，系统之间就只能使用双方都能理解的接口和实体的描述文件来进行统一。比如 <code>WebService</code> 就通过 <code>WSDL</code> 来进行描述，各语言都能从中进行解析取到共享的内容。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>选择序列化方式也是 <code>RPC</code> 非常重要的一个决策点，我们通常会要求序列化框架用于以下特点：</p>
<ul>
<li>序列化后的数据最好是易于人类阅读的；</li>
<li>实现的复杂度是否足够低；</li>
<li>序列化和反序列化的速度越快越好；</li>
<li>序列化后的信息密度越大越好，也就是说，同样的一个结构化数据，序列化之后占用的存储空间越小越好；</li>
</ul>
<p>但事实上，没有任何一种序列化能同时满足这些要求，基于二进制的序列化实现结果小、传输快但是不易懂。基于文本的 <code>json</code> 和 <code>xml</code> 序列化很方便易懂，但是占用的内存势必更大。</p>
<p>不同的 <code>RPC</code> 框架在设计时都会偏向一些特定领域来进行实现，<code>trade off</code> 理论确实是万用的。</p>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>基于 <code>TCP</code> 协议的话效率高，性能相对来说会更好些，但 <code>TCP</code> 也有自己的缺点，当遇到一些额外需求时，我们无法自己定义对象头，针对性的对某些调用进行处理，而 <code>HTTP</code> 则支持这样的操作，扩展性会更强一些。</p>
<h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>在发送请求前，客户端需要知道服务提供方的地址，而这个地址通常使用注册中心的方式来进行管理。</p>
<p>注册中心需要负责服务的上线，通知客户端变动情况，下线处理等操作</p>
<h2 id="常见的-RPC-框架有哪些"><a href="#常见的-RPC-框架有哪些" class="headerlink" title="常见的 RPC 框架有哪些"></a>常见的 RPC 框架有哪些</h2><ul>
<li>非常经典的 <code>WebService</code>，基于 <code>HTTP</code> 协议 和 <code>XML</code> 序列化，跨平台的 <code>RPC</code>，非常完善，缺点是较为复杂，性能一般。（<code>XML</code> 描述比较冗余，解析比较消耗资源，<code>HTTP</code> 的效率较 <code>TCP</code> 也相对更低）；</li>
<li><code>dubbo</code>，在 <code>RPC</code> 基础上增加了服务治理，功能非常强大，目前还衍生出了 <code>dubbo-go</code>；</li>
<li><code>Feign</code> ，<code>SpringCloud</code> 体系基于 <code>RestTemplate</code> 实现的 <code>RPC</code>，只支持 <code>java</code>；</li>
<li><code>Hessian</code>，<code>Hessian</code> 自定义了一套二进制序列化化协议，在此基础上实现了 <code>RPC</code>，属于轻量级，跨平台类型；</li>
<li><code>gRPC</code> , <code>golang</code> 开发的新一代 <code>RPC</code> ；</li>
<li><code>Thrift</code>。</li>
</ul>
<h2 id="一个简单的-RPC-实现"><a href="#一个简单的-RPC-实现" class="headerlink" title="一个简单的 RPC 实现"></a>一个简单的 RPC 实现</h2><p>这里通过一个基于 <code>HTTP</code> + <code>JSON</code> 序列化 + <code>Java</code> 动态代理 + <code>Spring Bean</code> 查找（指的是，服务启动时将实现类注册为 <code>Bean</code> ，接收到请求时通过 <code>getBean</code>  获取实现类） </p>
<p>此实现没有路由、重试、负载均衡、集群相关的实现，仅用于加深理解，框架的整体调用流程图如下：</p>
<p><img src="https://z3.ax1x.com/2021/07/10/WpJHD1.png" alt="WpJHD1.png"></p>
<p>定义消费者的请求体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">public class RpcfxRequest &#123;</span><br><span class="line">  private String serviceClass;//接口的全限定名</span><br><span class="line">  private String method;// 方法名</span><br><span class="line">  private Object[] params;// 方法参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义服务提供者返回的响应体<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">public class RpcfxResponse &#123;</span><br><span class="line">    private Object result; //请求结果</span><br><span class="line">    private boolean status;//状态码</span><br><span class="line">    private Exception exception;//异常信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义客户端创建代理类的入口 <code>Rpcfx.create</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Rpcfx &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        ParserConfig.getGlobalInstance().addAccept(&quot;io.demo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static &lt;T&gt; T create(final Class&lt;T&gt; serviceClass, final String url) &#123;</span><br><span class="line"></span><br><span class="line">        return (T) Proxy.newProxyInstance(Rpcfx.class.getClassLoader(), new Class[]&#123;serviceClass&#125;, new RpcfxInvocationHandler(serviceClass, url));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class RpcfxInvocationHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">        public static final MediaType JSONTYPE = MediaType.get(&quot;application/json; charset=utf-8&quot;);</span><br><span class="line"></span><br><span class="line">        private final Class&lt;?&gt; serviceClass;</span><br><span class="line">        private final String url;</span><br><span class="line"></span><br><span class="line">        public &lt;T&gt; RpcfxInvocationHandler(Class&lt;T&gt; serviceClass, String url) &#123;</span><br><span class="line">            this.serviceClass = serviceClass;</span><br><span class="line">            this.url = url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] params) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">            RpcfxRequest request = new RpcfxRequest();</span><br><span class="line">            request.setServiceClass(this.serviceClass.getName());</span><br><span class="line">            request.setMethod(method.getName());</span><br><span class="line">            request.setParams(params);</span><br><span class="line">            // 发送请求</span><br><span class="line">            RpcfxResponse response = post(request, url);</span><br><span class="line">            // 反序列化结果</span><br><span class="line">            return JSON.parse(response.getResult().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private RpcfxResponse post(RpcfxRequest req, String url) throws IOException &#123;</span><br><span class="line">            String reqJson = JSON.toJSONString(req);</span><br><span class="line">            System.out.println(&quot;req json: &quot;+reqJson);</span><br><span class="line"></span><br><span class="line">            OkHttpClient client = new OkHttpClient();</span><br><span class="line">            final Request request = new Request.Builder()</span><br><span class="line">                    .url(url)</span><br><span class="line">                    .post(RequestBody.create(JSONTYPE, reqJson))</span><br><span class="line">                    .build();</span><br><span class="line">            String respJson = client.newCall(request).execute().body().string();</span><br><span class="line">            System.out.println(&quot;resp json: &quot;+respJson);</span><br><span class="line">            return JSON.parseObject(respJson, RpcfxResponse.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义服务端查找实现类及调用的入口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RpcfxInvoker &#123;</span><br><span class="line"></span><br><span class="line">    private RpcfxResolver resolver;</span><br><span class="line"></span><br><span class="line">    public RpcfxInvoker(RpcfxResolver resolver)&#123;</span><br><span class="line">        this.resolver = resolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RpcfxResponse invoke(RpcfxRequest request) &#123;</span><br><span class="line">        RpcfxResponse response = new RpcfxResponse();</span><br><span class="line">        String serviceClass = request.getServiceClass();</span><br><span class="line">        // applicationContext.getBean(serviceClass);</span><br><span class="line">        Object service = resolver.resolve(serviceClass);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 反射调用</span><br><span class="line">            Method method = resolveMethodFromClass(service.getClass(), request.getMethod());</span><br><span class="line">            Object result = method.invoke(service, request.getParams());</span><br><span class="line">            </span><br><span class="line">            response.setResult(JSON.toJSONString(result, SerializerFeature.WriteClassName));</span><br><span class="line">            response.setStatus(true);</span><br><span class="line">            return response;</span><br><span class="line">        &#125; catch ( IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            // 异常</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            response.setException(e);</span><br><span class="line">            response.setStatus(false);</span><br><span class="line">            return response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Method resolveMethodFromClass(Class&lt;?&gt; klass, String methodName) &#123;</span><br><span class="line">        return Arrays.stream(klass.getMethods()).filter(m -&gt; methodName.equals(m.getName())).findFirst().get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端的实现类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User findById(int id) &#123;</span><br><span class="line">        return new User(id, &quot;test&quot; + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端设置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line">public class RpcfxServerApplication &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">	RpcfxInvoker invoker;</span><br><span class="line">	</span><br><span class="line">	@Bean</span><br><span class="line">	public RpcfxInvoker createInvoker(@Autowired RpcfxResolver resolver)&#123;</span><br><span class="line">		return new RpcfxInvoker(resolver);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Bean</span><br><span class="line">	public RpcfxResolver createResolver()&#123;</span><br><span class="line">		return new DemoResolver();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		SpringApplication.run(RpcfxServerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@PostMapping(&quot;/&quot;)</span><br><span class="line">	public RpcfxResponse invoke(@RequestBody RpcfxRequest request) &#123;</span><br><span class="line">		return invoker.invoke(request);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Bean(name = &quot;io.rpcfx.demo.api.UserService&quot;)</span><br><span class="line">	public UserService createUserService()&#123;</span><br><span class="line">		return new UserServiceImpl();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	class DemoResolver implements RpcfxResolver, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">        private ApplicationContext applicationContext;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public void setApplicationContext(ApplicationContext applicationContext) &#123;</span><br><span class="line">            this.applicationContext = applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public Object resolve(String serviceClass) &#123;</span><br><span class="line">            return this.applicationContext.getBean(serviceClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端调用方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class RpcfxClientApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        //通过create创建代理</span><br><span class="line">		UserService userService = Rpcfx.create(UserService.class, &quot;http://localhost:8080/&quot;);</span><br><span class="line">		User user = userService.findById(1);</span><br><span class="line">		System.out.println(&quot;find user id=1 from server: &quot; + user.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详细代码链接： <a href="https://gitee.com/zx-hoppo/rpcfx" target="_blank" rel="noopener">https://gitee.com/zx-hoppo/rpcfx</a></p>
<h2 id="RPC与服务化"><a href="#RPC与服务化" class="headerlink" title="RPC与服务化"></a>RPC与服务化</h2><p>在具体的分布式业务场景里，除了能够调用远程方法，我们还需要考虑以下内容</p>
<ul>
<li>1、多个相同服务如何管理？</li>
<li>2、服务的注册发现机制？</li>
<li>3、如何负载均衡，路由等集群功能？</li>
<li>4、熔断，限流等治理能力。</li>
<li>5、重试等策略</li>
<li>6、高可用、监控、性能等等。</li>
</ul>
<p>而这些点都与分布式服务化息息相关。虽然 <code>RPC</code> 的定义非常简单，仅代指隐藏调用过程而已，但现阶段的 <code>RPC</code> 框架早已不局限于此了。</p>
<p>在实际应用中，简单的系统间调用一般都不会使用 <code>RPC</code>，因为无论是系统间接口和实体定义信息的共享还是维护注册信息等等，都会涉及到代码修改，相对来说更加的重量级一些。 有时候直接通过 <code>httpclient</code> 或者 <code>restTemplate</code> 这样的工具类发送请求会简单很多。</p>
<p><strong>tips：</strong> </p>
<ul>
<li>1.<code>RPC</code> 和直接使用接口调用的应用场景不同，<code>RPC</code> 更适用于大型的分布式治理场景，而 <code>http</code> 接口调用对于简单的系统交互来说，更加方便快捷；</li>
<li>2.<code>RPC</code> 和 <code>HTTP</code> 不能进行比较，两者完全是不同的东西，我们只能说 <code>RPC</code> 可以使用 <code>HTTP</code> 来作为调用双方的通信协议；</li>
<li>3.<code>Rest</code> 接口算不算 <code>RPC</code> ? 答：如果在 <code>client</code> 端给远程的 <code>rest</code> 封装好了 <code>service</code> 之类的调用方法就算（比如说 <code>feign</code>），否则就不算。</li>
</ul>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>从回收算法理解JVM（一）</title>
    <url>/2021/10/31/%E4%BB%8E%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3JVM(%E4%B8%80)/</url>
    <content><![CDATA[<p>提到 <code>JVM</code> 的话大家会想到什么呢？是它的内存区域划分，各种 <code>GC</code> 收集器？又或者是垃圾回收算法？常见的 <code>JVM</code> 参数？</p>
<p>这些问题可能大家已经耳熟能详了。但大家是否有思考过为什么会有多种回收算法，他们分别适应什么样的场景，有什么优劣性质。他们是<strong>如何解决跨代引用</strong>，<strong>如何处理业务线程与 <code>GC</code> 线程的并发</strong>等等。本篇文章会从回收算法入手，逐个分析这些问题。</p>
<a id="more"></a>
<h2 id="评价-设计一个垃圾回收算法时应该考虑哪些因素？"><a href="#评价-设计一个垃圾回收算法时应该考虑哪些因素？" class="headerlink" title="评价/设计一个垃圾回收算法时应该考虑哪些因素？"></a>评价/设计一个垃圾回收算法时应该考虑哪些因素？</h2><p>在谈论垃圾回收算法时，我们通常会从以下几个方面来进行判断（时间复杂度会正影响停顿时长）：</p>
<ul>
<li>分配的效率</li>
<li>回收的效率</li>
<li>是否产生内存碎片</li>
<li>空间利用率</li>
<li>是否停顿（停顿时长）</li>
<li>时间复杂度</li>
<li>实现的复杂度</li>
</ul>
<h2 id="如何判断对象是否可回收？"><a href="#如何判断对象是否可回收？" class="headerlink" title="如何判断对象是否可回收？"></a>如何判断对象是否可回收？</h2><ul>
<li>引用计数法<ul>
<li>统计每一个对象被引用的次数，每引用一次计数加一，取消引用时计数减一（写屏障）。如果为 <code>0</code>，就释放该对象</li>
<li>并发场景下，对引用计数的修改需要与对象指针同步，通常需要加锁、或者非常复杂的无锁算法（对象指针和 <code>count</code> 计数都需要原子操作，单变量还好，双变量就会更复杂）</li>
<li>连锁式回收问题：原本以为只需要回收 <code>1</code> 个对象，结果关联的引用计数也是 <code>1</code>，减 <code>1</code> 后都变成了 <code>0</code>，导致一次回收很多对象，停顿时间不可控</li>
<li><strong>循环引用问题（主要问题）</strong></li>
<li><strong>优点：实现简单，能立即回收</strong>。一个对象的引用计数归零的那一刻即是它成为垃圾的那一刻，同时也是它被回收的那一刻。</li>
</ul>
</li>
<li>根节点枚举（ 又称<code>GCRoots</code>）：通过一系列名为 <code>GCRoots</code> 的对象作为起始点，从这个被称为 <code>GCRoots</code> 的对象开始，根据引用关系的图向下搜索，如果一个对象到 <code>GCRoots</code> 没有任何引用链相连时，则说明此对象可回收</li>
</ul>
<p><code>JVM</code> 选用的方法是根节点枚举的方式，单说概念的话，会让我们觉得难以理解，哪些对象属于 <code>GCRoots</code> 呢？书中（《深入理解 <code>java</code> 虚拟机》）给我们的定义是：当前正在运行的方法中参数以及局部变量、静态变量、常量，<code>syncronized</code> 的持有者等。（<strong>还有跨代引用</strong>，后面详细解释）</p>
<p>在下面的图中 <code>for</code> 循环创建了四个对象 <code>MyInst(0)---&gt;MyInst(4)</code>，每一次循环结束，变量 <code>mi</code> 都会指向一个堆中的一个新对象，此时的 <code>mi</code> 就是根对象</p>
<p><img src="http://cdn.processon.com/6173b7d00e3e7416bde08362?e=1634977248&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:BaYfgjsUGl7jgICX8TI-HRI5JUA=" alt="image-20211025173320188"></p>
<h2 id="jvm-中常见的垃圾回收算法"><a href="#jvm-中常见的垃圾回收算法" class="headerlink" title="jvm 中常见的垃圾回收算法"></a>jvm 中常见的垃圾回收算法</h2><h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法 Mark-Sweep"></a>标记-清除算法 Mark-Sweep</h3><p>最早，也是最基础的垃圾回收算法，分为标记和清除两个阶段：第一阶段先标记出需要回收的对象，第二阶段将被标记的对象进行统一回收。</p>
<ul>
<li>使用链表管理空闲内存，分配时从链表中取满足大小的内存，回收时将垃圾对象占用的空间交还给链表（<strong>所以这种分配方式也叫做空闲列表</strong>）</li>
<li>有内存碎片</li>
<li>总体的空间利用率较高</li>
<li>不需要更改对象的地址，可以实现并发标记和清除—–&gt; 这也是 <code>ConcurrentMarkSweep</code> 的来源</li>
<li>如果垃圾对象很多，那么整体的执行效率会比较低—–&gt; 适用于垃圾对象较少的场景</li>
</ul>
<p><img src="http://cdn.processon.com/6194cf00e401fd06e68903ce?e=1637145872&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:cmOwfoaaxQ353Dc8QC29bT-QPZM=" alt="回收前"></p>
<p><img src="http://cdn.processon.com/6194cf0d07912906e6a9cdf4?e=1637145885&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:PmYnAGdSEUvDWCp3b0TsHmIHtXE=" alt="回收后"></p>
<h3 id="复制算法-Copy"><a href="#复制算法-Copy" class="headerlink" title="复制算法 Copy"></a>复制算法 Copy</h3><p>标记-复制算法，简称复制算法。为了解决标记清除在面对大量垃圾对象时的困境，一种名为 “半区复制” 的思想被提了出来，它将整个内存区域分为大小相同的两块,一个称为 <code>From</code>，一个称为 <code>To</code>，每次只使用 <code>From</code> 区域进行分配，当内存用完了，就<strong>将存活的对象拷贝到 <code>To</code> 上，然后交换 <code>From</code> 和 <code>To</code></strong></p>
<p><img src="http://cdn.processon.com/6176badb7d9c08459fb1d0f9?e=1635174635&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:HJqgbf8M4R_UufuZ9ylLm_ljlvM=" alt="image"></p>
<ul>
<li>分配时在空闲区域中有一个 <code>top</code> 指针，每次分配内存时，都将 <code>top</code> 指针向右移动对象所申请大小相等的距离（<strong>这种分配方式又称为碰撞指针</strong>）<a href="http://cdn.processon.com/6120a14ae401fd5228f33987?e=1629531994&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:ZKB-R782s1QzQLeImvysfhrO5kQ=" target="_blank" rel="noopener">碰撞指针示意图</a></li>
<li>没有内存碎片</li>
<li>浪费一半的内存空间</li>
<li>移动对象时，需要修改对象地址，会产生停顿</li>
</ul>
<h4 id="那这时候就产生了一个问题：移动对象，必然会导致对象的内存地址发生变动，那么移动后，对象是怎么找到在堆中对象的新内存地址的呢？"><a href="#那这时候就产生了一个问题：移动对象，必然会导致对象的内存地址发生变动，那么移动后，对象是怎么找到在堆中对象的新内存地址的呢？" class="headerlink" title="那这时候就产生了一个问题：移动对象，必然会导致对象的内存地址发生变动，那么移动后，对象是怎么找到在堆中对象的新内存地址的呢？"></a>那这时候就产生了一个问题：移动对象，必然会导致对象的内存地址发生变动，那么移动后，对象是怎么找到在堆中对象的新内存地址的呢？</h4><p><strong>方案一：引入中间层</strong></p>
<p>当我们引用对象时，实际上使用的是中间指针，由中间指针帮我们去定位具体的对象地址（<strong>这种方式其实就是句柄的方式</strong>。每次移动对象时，都维护一次中间指针），缺点在于每次访问对象属性都变成了两次访存，有一定程度的性能退化（ps：万能的中间层）</p>
<p><img src="http://cdn.processon.com/6176c51a5653bb7318d4078c?e=1635177259&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:_zS3Hyao5v4RJiVDA4BL4jvz8IY=" alt="image"></p>
<blockquote>
<p>我们知道，在 jvm 虚拟机中，栈上存放的是 reference 引用，实际的对象是存储在堆中的。而《java虚拟机规范》里只规定了它是指向对象的一个引用，并没有定义这个引用应该使用何种方式去定位堆中的对象，所以对象的访问方式由虚拟机的具体实现而定，常规的有句柄、直接指针两种方式。 Hotspot 选择的是直接指针的方式。<a href="http://md.demojie.com/img/20200207163301.jpg" target="_blank" rel="noopener">句柄示意图</a></p>
</blockquote>
<p><strong>方案二：forwarding指针</strong></p>
<p>由于 <code>HotSpot</code> 使用的是直接指针的方式，为了解决对象地址的移动问题，它在对象的对象头中引入了 <code>forwarding</code> 指针（除此之外对象头中我们常见的内容还包括 <code>hashcode</code>、对象分代年龄、锁标记位这几个）</p>
<p>它的原理是，在 <code>GC</code> 线程移动对象的地址时，将对象头里的 <code>forwarding</code> 指针指向拷贝后的内存地址，栈上的 <code>Referrence</code> 根据引用找到原对象时，发现门上贴了一个新的地址，于是就将引用更新到新的地址去 </p>
<p><img src="http://cdn.processon.com/6176c7af07912943ddfa2bb7?e=1635177919&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:hcAH0JB5s_tjJMeL_Oe7rB3kub0=" alt="image"></p>
<h4 id="针对复制算法的优化"><a href="#针对复制算法的优化" class="headerlink" title="针对复制算法的优化"></a>针对复制算法的优化</h4><p>由于 “半区复制” 过于浪费空间，空出一半的空间未免太过可惜，再加上复制算法本身的特性——-&gt; <strong>只适合存活对象较少的场景</strong>。</p>
<p>于是就有了对于复制算法的优化（也就是现在的年轻代回收）：</p>
<p><code>HotSpot</code> 将整个年轻代划分为了 <code>Eden</code>， <code>Survivor0</code> 和 <code>Survivor1</code> 三个区域，使用时将 <code>Eden + S0</code> 一起作为 <code>From</code> ，剩下的 <code>S1</code> 作为 <code>To</code> 区域（空闲），每完成一次年轻代的 <code>GC</code> 之后， <code>S0</code> 和 <code>S1</code> 就进行交换，轮流作为 <code>To</code> 区域（同时将对象的年龄 <code>+1</code> ）。这样一来 <code>Survivor</code> 空间的浪费就可以减少了。配置 <code>Survivor</code> 空间的大小是由 <code>JVM</code> 参数控制的，例如：<code>-XX:SurvivorRatio=8</code> 代表 <code>Eden:S0:S1=8:1:1</code>（默认） ，空间率用率直接提升到了 <code>90%</code></p>
<p><img src="http://cdn.processon.com/6177be1963768912b568f9bb?e=1635241001&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:pGUgoEhcTcJuGQHSji8QQKJ0_yo=" alt="image"></p>
<p>大家可以思考一个小问题：如果回收时发现 <code>To</code> 空间不够了会怎么办？</p>
<h3 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法 Mark-Compact"></a>标记-整理算法 Mark-Compact</h3><p>在标记阶段完成后（<strong>标记阶段，是所有追踪式垃圾回收算法（引用计数不属于）的共同特征</strong>），先将存活对象向内存的某一方进行靠拢整理（这个步骤会改变对象的地址），然后清理掉边界以外的区域。这种方式带来的优劣，将前两者结合到了一起</p>
<ul>
<li>如果移动对象？那么存活对象过多时，更新对象的引用就已经是个极为负重的操作了</li>
<li>如果像标记-清除那样，完全不整理内存碎片，又会导致严重的内存碎片问题。内存的分配回收是最频繁的操作，甚至没有之一，进而导致应用的吞吐量下降</li>
<li>如果不移动对象，那么停顿时间会更短</li>
<li>如果移动对象，那么应用的整体吞吐量会更高</li>
</ul>
<p>在常见的垃圾回收器中，<code>java8</code> 中默认的关注吞吐量的 <code>ParallelOld</code> 是基于标记整理的，而关注停顿时间的 <code>CMS</code> 是基于标记清除的。<br>（当然，<code>CMS</code> 虽然 <code>95%</code> 的时间是使用标记-清除。但在内存碎片过多的时候，还是会再使用标记-整理收集一次）</p>
<blockquote>
<p>标记整理算法的处境在 ZGC 和 Shenandoah 出现之前其实挺尴尬的，因为每次都去整理内存对于停顿时间来说是个硬伤，而在它们出现之后，对象复制阶段也可以并发了—&gt;所以才有了所谓的停顿时间在 10ms 以内</p>
</blockquote>
<h2 id="分代回收思想"><a href="#分代回收思想" class="headerlink" title="分代回收思想"></a>分代回收思想</h2><p>分代思想来源于两个假说：</p>
<ul>
<li>①大对数对象都是朝生夕灭的；</li>
<li>②熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ul>
<p>在这两个假说之下，<code>JVM</code> 一般将堆分为年轻代和老年代两个部分，对象创建时都在新生代中进行分配（例外：大对象直接进入老年代），每次垃圾回收时都有大量对象被回收，少数存活的对象被放入 <code>Survivor</code> 区域。当经过数次 <code>GC</code> 后仍然存活的对象，就晋升到老年代中（即分代年龄，默认是大于 <code>15</code> 时晋升）</p>
<p><strong>那基于前面的分析我们可以知道，<code>Copy</code> 算法适用于存活对象少的情况,而 <code>Mark-Sweep</code> 更适用于存活对象多的情况，所以对于存活时间短的对象，我们倾向于使用复制算法，而对于存活时间长的对象，我们更倾向使用标记-清除类型的算法。所以在业界中年轻代通常使用复制算法，老年代使用标记清除。</strong></p>
<p>分代思想使得不同的回收算法能在自己擅长的场景下进行工作，将各自的优势都结合起来，看似是非常好的一种方式，但同时呢它也带来了新的问题——&gt; <strong>跨代引用</strong></p>
<p><img src="http://cdn.processon.com/615e4df75653bb45b2c27eb4?e=1633573896&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:hInVl4KWw_Uo26eXVNKkv6e34kw=" alt="image"></p>
<p>假设现在要进行一次只局限于年轻代的回收，但新生代中新创建的对象完全有可能被老年代引用，为了找出年轻代中的存活对象，不得不将老年代也扫描一次来保证可达性分析的正确性。。毕竟任何一个存活对象被错误回收都是重大事故</p>
<p>到这里大家会发现一个问题，如果我真这么做了，那还分代干什么呢？于是乎，第三个假说诞生了：③ 跨代引用假说：跨代引用相对同代引用来说，仅占极少数。</p>
<blockquote>
<p>虽然写的是假说，但它其实是真的- -。（雾）</p>
</blockquote>
<h3 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h3><p>为了避免因为极少数的跨代引用而去扫描整个老年代，<code>JVM</code> 虚拟机在年轻代引入了 <code>Remember Set</code>（记忆集，<strong>可以理解为一种数据结构</strong>）的概念。垃圾回收器通过记忆集来判断，非收集区域是否存在指向收集区域的指针（<strong>说人话，当 <code>GC</code> 进行年轻代收集时，老年代属于非收集区域，通过记忆集可以判断是否存在指向了年轻代的跨代引用</strong>），根据记忆集的记录精度，分为了字长精度、对象精度、卡精度（又称为 <code>Card Table</code>）三种</p>
<p>堆中的对象数量非常庞大，所以为每个字长，或者对象都去记录跨代引用是不符合实际的，<code>HotSpot</code> 选择的方式是卡精度进行记录，以 <code>512</code> 字节的内存块为一个区域进行记录，可以理解为下面这个样子</p>
<p><img src="http://cdn.processon.com/617813e807912943ddfd5ae7?e=1635262968&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Z8tHSZjifgZKESrxR9jYR8KooWI=" alt="image"></p>
<p>老年代的 <code>A</code> 对象存在跨代引用，那么将老年代所在的内存块进行标记，<strong><code>CardTable</code> 本质上是一个位图</strong>，当需要进行回收时，就会把这块区域的对象也加入到 <code>GCRoots</code> 中</p>
<blockquote>
<p>记忆集的维护是通过写屏障来完成的（这里使用的是写后屏障来更新卡表），后续会详细介绍什么是写屏障</p>
</blockquote>
<h3 id="GC停顿与并发"><a href="#GC停顿与并发" class="headerlink" title="GC停顿与并发"></a>GC停顿与并发</h3><p>在复制算法和标记-整理中，对象的地址都会发生变化，最简单的办法是让业务线程全部停下来，等回收器把对象地址全部调整好了以后再工作，这就是 <code>GC</code> 停顿产生的原因。（新版的 <code>ZGC</code> 和 <code>Shenandoah</code> 已经利用读屏障实现了整理过程与用户线程的并发执行）</p>
<p>为了减少 <code>GC</code> 停顿，我们可以在标记阶段，让业务线程不要停下来。这意味着 <code>GC Mark</code> 和业务线程在同时工作，也就是并发（<code>Concurrent</code>）的 <code>GC</code> 算法。</p>
<blockquote>
<p>注意区别并发和并行的区别，Concurrent 指的是 GC 和业务线程同时工作，而 Parallel 指的是多个 GC 线程同时工作。</p>
</blockquote>
<p>以下是 <code>CMS</code> 收集器的工作示意图</p>
<p><img src="http://cdn.processon.com/61781d7c0e3e7416bde8b192?e=1635265420&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:bU1Jco3rgfK-T9PsZPqnM4UrCSM=" alt="image"></p>
<p>小问题： 为什么要做并发，不使用并发会有什么问题（从堆大小来考虑）？</p>
<p>使用并发虽然解决了停顿问题，但是新问题又双叒来了！！！，如果业务线程和 <code>GC</code> 线程并发工作的话，就会存在 <code>GC</code> 正在进行 <code>GCRoots</code> 枚举，但是呢，业务线程把对象的引用关系给修改了。那这样就会导致标记出来的结果不正确，明明是垃圾没回收到，我还需要用的对象，你给我回收了?</p>
<blockquote>
<p>初始标记、以及 Remark 阶段需要停顿，且 Remark 并不是指重新扫描，仅扫描在并发标记阶段修改了引用的对象</p>
</blockquote>
<h3 id="三色标记法-写屏障"><a href="#三色标记法-写屏障" class="headerlink" title="三色标记法 + 写屏障"></a>三色标记法 + 写屏障</h3><p>为了保证对象不被错误回收， <code>GCRoots</code> 的遍历必须要在一个能保障一致性的快照上进行。在理解这个原理时，通常会引入“三色标记”作为工具来辅助推导</p>
<blockquote>
<p>需要注意的是，三色并不是指真的要给对象一个颜色属性，而是一种为了把问题说清楚而引出来的抽象概念，它在不同的 <code>GC</code> 算法中代表着不同的状态</p>
</blockquote>
<ul>
<li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过；</li>
<li>灰色：表示对象已经被垃圾收集器访问过，但该对象至少还有一个引用没有被扫描过；</li>
<li>白色：表示对象尚未被垃圾收集器访问过，在可达性分析的初始阶段，所有对象都是白色的，<strong>在分析结束后仍处于白色的对象则表示不可达</strong>；</li>
</ul>
<p><img src="http://cdn.processon.com/617822091efad44894fe0f7f?e=1635266586&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:CjRx3fuo0mjFd9weOOJNv5yJYFg=" alt="image"></p>
<p>由于 <code>GC</code> 线程在遍历过程中会给对象标记颜色，但同时业务线程也有可能更改引用关系，这样一来就可能会导致两种结果：</p>
<ul>
<li>本来已经是垃圾的对象被误标为了存活，虽然不好，但其实只是产生了部分浮动垃圾，还算可以接受，下次 <code>GC</code> 收集掉就好了</li>
<li>本来是存活的对象被误标为了垃圾，这就是重大问题了，势必会导致程序错误（主要解决这个问题）</li>
</ul>
<h4 id="三色标记的漏标问题：发生在当黑色对象修改引用指向白色对象时"><a href="#三色标记的漏标问题：发生在当黑色对象修改引用指向白色对象时" class="headerlink" title="三色标记的漏标问题：发生在当黑色对象修改引用指向白色对象时"></a>三色标记的漏标问题：发生在当黑色对象修改引用指向白色对象时</h4><p>如下图所示，此时黑色对象修改了引用，直接指向 <code>C</code>, 同时 <code>B</code> 指向 <code>C</code> 的引用也断开（<strong>两个条件</strong>），由于黑色对象 <code>A</code> 所有的引用都已经遍历结束了，这就会导致可达性分析结束之后 <code>C</code> 仍然处于白色状态，最后被当作垃圾错误回收。</p>
<p><img src="http://cdn.processon.com/61796a52f346fb01b914a46d?e=1635350626&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:bmFkF_JRiYsXZqzwC581s-Uzv7c=" alt="image"></p>
<blockquote>
<p>所谓的两个条件是指：①黑色对象直接指向白色对象；②灰色对象到该白色对象的引用被删除</p>
</blockquote>
<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>出现对象消失的情况，仅在上述所说的两个条件均满足时才会产生存活对象消失的情况，所以要解决并发标记只需要破坏这两个条件的其中一个即可。</p>
<p>在这里需要先引出两种三色不变性的定义：</p>
<ul>
<li>强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li>
<li>弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</li>
</ul>
<p><strong>解决方式一：往前进（满足强三色不变性）</strong></p>
<p><code>Dijkstra</code> 提出的写屏障：把白色对象直接标灰，在实现时其实不用管引用的出发点A是什么颜色，可以直接将未标记的对象置灰（简单地说，就是当需要修改黑色对象的引用以指向白色对象之前，直接将白色对象置灰，破坏的是条件①）</p>
<p>缺点<br><img src="http://cdn.processon.com/61796ad3e401fd6d2b1cdaab?e=1635350755&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:-hNAdh9sk8Yn1xAWRH29gFMYwPA=" alt="image"></p>
<blockquote>
<p>通过这个图可以意识到，写屏障其实是虚拟机层面 “对引用类型赋值” 这个动作的 AOP ，他可以在修改某个对象的应用前，或者修改引用之后触发，前面提到的维护跨代引用卡表，使用的就是写后屏障（在赋值之后触发，将卡表的对应位置置为1或0）</p>
</blockquote>
<p><strong>解决方式二：往后退(满足弱三色不变性)</strong></p>
<p>把黑色对象还原回灰色状态，重新进行遍历<br><img src="http://cdn.processon.com/61796b1507912943dd00d100?e=1635350821&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Cx0rt-6S7e-JwLo1bS-WWLwD6-8=" alt="image"></p>
<h4 id="CMS的做法—-gt-增量更新"><a href="#CMS的做法—-gt-增量更新" class="headerlink" title="CMS的做法—&gt;增量更新"></a>CMS的做法—&gt;增量更新</h4><p><code>CMS</code> 本质上使用的其实是往后退的方法，但是它的巧妙之处在于，它并不是直接开倒车（雾），而是将修改了黑色–&gt;白色引用的卡表区域进行标记。下图中，黑色对象 <code>A</code> 在修改引用指向白色对象 <code>B</code> 的时候，会把 <code>cardTable</code> 对应的区域置为灰色（中间那个），这样一来 <code>cardTable</code> 就有了两个作用：①维护跨代引用；②标记灰色节点</p>
<p><img src="http://cdn.processon.com/61797cb50e3e7416bdec7aa5?e=1635355333&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:I96u_S-du4ZW7JyyKmPaIf1bF-Q=" alt="image"></p>
<p>现在回想一下，当发生年轻代 <code>GC</code> 时，会将卡表中有标记的位置也加入到 <code>GCRoots</code> ，如果某个 <code>card</code> 中没有找到跨代引用指针，就不需要在下一次回收中扫描该区域，此时该 <code>card</code> 对应的标记会被清空！！那这样一来就会影响到 <code>cardTable</code> 的第二个功能—&gt;灰色节点标记被年轻代回收给清除了。</p>
<p>为了解决 <code>cardTable</code> 功能冲突问题，<code>HotSpot</code> 在 <code>CMS</code> 上打了一个补丁—-&gt; 即 <code>mod union table</code> ,每次进行年轻代回收时，如果某个标记位置要被清空，那么将 <code>cardTable</code> 上标记的位置转移到 <code>mod union table</code></p>
<blockquote>
<p>虽然复用 cardTable 提高了写屏障的性能，但这样一来 cardTable 同时承担着两个职责，导致互相影响</p>
</blockquote>
<p><code>CMS</code> 的粗糙点： </p>
<ul>
<li>内存碎片过多时，需要一次全局整理，停顿会比较长</li>
<li>和对象 <code>A</code> 在同一个区域的 <code>D</code> 对象即使已经没有对象引用它了，<code>CMS</code> 仍然会认为他是存活对象，导致浮动垃圾的产生。</li>
<li>需要和业务线程同时工作，所以不能等空间不够了才回收，需要留出足够的空间给业务线程做内存分配，<code>CMS</code>的启动百分比配置：<code>-XX:CMSInitiatingOccupancyFraction</code></li>
</ul>
<p><a href="https://www.jdon.com/51811" target="_blank" rel="noopener">为什么Concurrent Mark Sweep被弃用了？</a></p>
<h2 id="分区-GC-简单介绍"><a href="#分区-GC-简单介绍" class="headerlink" title="分区 GC (简单介绍)"></a>分区 GC (简单介绍)</h2><p>对于分代 <code>GC</code> 来说，对象都集中在一起，不管是回收老年代还是年轻代，垃圾(存活)对象的多少会直接影响 <code>GC</code> 停顿的时间，停顿时间相对来说是不可控的。</p>
<p>为了使 <code>GC</code> 停顿时间可控，分区 <code>GC</code> 的思想被提了出来，它将整个堆内存划分为多个区域 （<code>Region</code>），每个区域都可以根据需要，扮演新生代的 <code>Eden</code> 空间、<code>Survivor</code> 空间或者老年代空间（<code>G1 GC</code>）</p>
<p><img src="http://cdn.processon.com/617caf491efad41d03f49e0f?e=1635564889&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:wR_iBYcT2nxHTGmmbk64s41U6Nc=" alt="image"></p>
<h3 id="分区GC-带来的新问题"><a href="#分区GC-带来的新问题" class="headerlink" title="分区GC 带来的新问题"></a>分区GC 带来的新问题</h3><p>分区 <code>GC</code> 带来了停顿时间可控的好处，例如 <code>G1 GC</code> 可以设置 <code>JVM</code> 参数 <code>-XX:MaxGCPauseMillis=80</code> 代表停顿时间控制在 <code>80ms</code> 左右，回收器在工作时，会尽力保证停顿时间接近该值。</p>
<p>分区 <code>GC</code> 的新问题：</p>
<ul>
<li>1.如何维护跨区引用</li>
<li>2.如何合理地选择回收区域<ul>
<li>根据停顿时间要求反向估算，</li>
<li>优先回收垃圾更多的区域—&gt; <code>Garbige First</code> 的由来</li>
</ul>
</li>
<li>3.仍需要考虑分代问题，<code>Region</code> 所扮演的角色是可以相互转换的</li>
<li>4.大对象分配问题</li>
</ul>
<h3 id="G1是如何解决跨区引用的"><a href="#G1是如何解决跨区引用的" class="headerlink" title="G1是如何解决跨区引用的"></a>G1是如何解决跨区引用的</h3><p>总体思想与维护跨代引用类似→<strong>使用写屏障维护卡表</strong>。我们现在知道，所谓的写屏障其实就是在更改对象之间的引用关系的时候，通过额外做一些事情来维护相关信息。前面提到的引用计数、维护 <code>cardTable</code> 都是写屏障的应用，但<code>G1</code> 的写屏障相对复杂，它需要解决以下两个问题：</p>
<p><strong>问题①：并发标记阶段的删除写屏障（解决漏标问题）</strong></p>
<p><img src="http://cdn.processon.com/617d5df01efad41d03f587eb?e=1635609601&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:VAKe-7b7M6lkphgg22DuJ577Ips=" alt="image"></p>
<p><code>G1</code>在进行三色标记时，使用的是删除法—&gt;当开始 <code>GCRoots</code> 遍历后,如果某个对象的引用关系被删除时，会将对象置灰。现在回想一下垃圾对象是如何产生的—-&gt;当一个对象的所有引用都被删除时，它才会被标记为垃圾，这样一来，删除写屏障的存在使得在并发标记之后才产生的垃圾都会被认为是存活对象，这就好比在并发标记开始时对堆内存拍了个快照，在这一瞬间存活的对象，都会被标记为存活，也就是 <strong>SATB(原始快照)</strong> 的由来</p>
<blockquote>
<p>为了提高性能。G1 不会在每次删除都去维护写屏障（标记），而是将引用被删除的对象记录在 SATB队列中。每个业务线程都有自己的本地 SATB队列，最后再由 GC 线程来维护（标记）这些对象</p>
</blockquote>
<p><strong>问题②：维护跨区引用</strong></p>
<p>维护跨区引用与维护跨代引用的原理是相同的，区别在于分代 <code>GC</code>只需要维护一个大卡表（整个区域对应一个），但到了分区 <code>GC</code> 中，回收部分的区域需要知道哪些 <code>Region</code> 存在跨区引用，那么记忆集也需要改变，</p>
<p><strong>G1 为每个 Region (区域)都维护了自己的专属记忆集（这也导致 G1 需要占用更多内存，至少需要堆内存的 10%-20% 来维护收集器的正常工作）</strong></p>
<blockquote>
<p>因为 G1 的整个内存区域分为很多个 Region，对于下方左侧的图来说，与 Region1 存在跨区引用的只有 Region2、Region3 而已，如果使用通用记忆集，就会增加很多不必要的查找，所以 G1 实际使用的是右边的方式，每个 Region 都有自己的专属记忆集</p>
</blockquote>
<p><img src="http://cdn.processon.com/61cacd2c079129360c590e93?e=1640684348&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:sZwXOegb-gXH_vKbxH5AIfyth6c=" alt></p>
<p>根据每个 <code>region</code> 跨代引用的多少，专属记录集还分为稀疏表、细粒度表和粗粒度表三种。</p>
<h3 id="如何选择回收区域"><a href="#如何选择回收区域" class="headerlink" title="如何选择回收区域"></a>如何选择回收区域</h3><p><code>G1</code> 内部维护了一个停顿预测模型，计算出每个 <code>Region</code> 所需要花费的回收时间，平均值，标准偏差等。</p>
<h3 id="大对象的处理方式"><a href="#大对象的处理方式" class="headerlink" title="大对象的处理方式"></a>大对象的处理方式</h3><p><code>G1</code> 在进行分区时，会有一种 <code>Humongous</code> 的特殊区域存在，当一个对象的大小超过了一个 <code>Region</code> 容量的一半则认为是大对象，此时会将这些对象存放到多个连续的 <code>Humongous Region</code> 中（<code>G1</code> 的大多数行为都将此区域作为老年代来处理）</p>
<h2 id="JVM中的垃圾回收算法"><a href="#JVM中的垃圾回收算法" class="headerlink" title="JVM中的垃圾回收算法"></a>JVM中的垃圾回收算法</h2><table>
<thead>
<tr>
<th>名称</th>
<th>算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>ParallelGC</td>
<td>copy-based</td>
<td></td>
</tr>
<tr>
<td>Parallel Old</td>
<td>Mark-Compaction</td>
</tr>
<tr>
<td>G1 GC</td>
<td>copy-based</td>
</tr>
<tr>
<td>CMS</td>
<td>Concurrent Mark Sweep</td>
</tr>
<tr>
<td>ParNew</td>
<td>copy-based</td>
</tr>
</tbody>
</table>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/57db02feaca4" target="_blank" rel="noopener">CMS 垃圾收集算法</a></li>
<li><a href="https://www.zhihu.com/question/62000722" target="_blank" rel="noopener">golang里gc相关的write barrier(写屏障）是个什么样的过程或者概念？</a></li>
<li><a href="https://www.jdon.com/51811" target="_blank" rel="noopener">为什么Concurrent Mark Sweep被弃用了？</a></li>
<li>《深入理解java虚拟机第三版》</li>
<li><a href="https://time.geekbang.org/column/intro/100094901?tab=comment" target="_blank" rel="noopener">编程高手必学的内存知识</a></li>
</ul>
]]></content>
      <categories>
        <category>深入java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>从回收算法理解JVM（二）</title>
    <url>/2022/03/22/%E4%BB%8E%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3JVM(%E4%BA%8C)/</url>
    <content><![CDATA[<p>在上一次的《从回收算法理解JVM》 中只是简单的提到了分区 <code>GC</code>，本篇文章针对 <code>G1</code> 做了进一步的总结，并解释了无停顿 <code>GC</code> 的部分实现原理<a id="more"></a></p>
<h2 id="G1-在并发标记和记忆集维护中的优化"><a href="#G1-在并发标记和记忆集维护中的优化" class="headerlink" title="G1 在并发标记和记忆集维护中的优化"></a>G1 在并发标记和记忆集维护中的优化</h2><h3 id="并发标记中的优化"><a href="#并发标记中的优化" class="headerlink" title="并发标记中的优化"></a>并发标记中的优化</h3><p>介绍三色标记漏标时曾说过 <code>CMS</code> 选择的即不是前进法也不是后退法，而是复用了卡表 <code>card Table</code>，这种方式可以复用 <code>cardTable</code> 的代码逻辑是其中一个原因，另外还有一个重要原因是写屏障是需要业务线程来完成的，并且写屏障本身的效率不高，容易导致性能问题。</p>
<p><code>G1</code> 在使用删除写屏障时也考虑到了这个问题，并发标记开始后，如果识别到对象的引用关系被删除，那么业务线程会将需要标记为灰色的对象丢入到本地的 <code>SATB</code> 队列中（每个业务线程都有自己的 <code>SATB</code> 队列），然后由 <code>GC</code> 线程在合适的时机去做标记。</p>
<p>如果本地 <code>SATB</code> 队列放满了。就会将对象转移到全局的 <code>SATB</code> 集合中，然后申请一个空的 <code>SATB</code>，如下所示：</p>
<p><img src="http://cdn.processon.com/61cac30663768964cae88a95?e=1640681750&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:1GClBPbikrhPFmSriwmFT1IT4NU=" alt="image"></p>
<p>在这种维护方式下，业务线程无需关心对象的标记操作，减轻了写屏障的负担，效率更高。</p>
<h3 id="记忆集优化"><a href="#记忆集优化" class="headerlink" title="记忆集优化"></a>记忆集优化</h3><p><strong>①记忆集的维护时机</strong></p>
<p>上一篇文章介绍过，因为 <code>G1</code> 的整个内存区域分为很多个 <code>Region</code>，为了避免通用记录集导致的很多不必要查找，<code>G1</code> 实际使用的是专属记忆集的方式，即每个 <code>Region</code> 都有自己的专属记忆集。</p>
<p><img src="http://cdn.processon.com/61cacd2c079129360c590e93?e=1640684348&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:sZwXOegb-gXH_vKbxH5AIfyth6c=" alt="image"></p>
<p><code>G1</code> 在维护记忆集时依旧是使用写屏障，并且使用到了本地 <code>SATB</code> 队列相似的方式。写屏障只负责将需要记录到 <code>Rset</code> 中的内容写入到 <code>DirtyCardQueue</code> 中，最后再由特殊的 <code>GC</code> 线程（<strong>又称为 Refine 线程</strong>）来完成 <code>Rset</code> 的写入操作</p>
<p><img src="http://cdn.processon.com/61cace2e079129360c5914a8?e=1640684607&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:6wnQ76E1f9V7cKqha0Vn6oNI7zY=" alt="image"></p>
<p><strong>②记忆集的存放形式</strong></p>
<p>对于一个 <code>Region</code> 来说，它的记忆集可能会因为引用关系比较多，而变得很大。根据另一个 <code>Region</code> 对这个 <code>Region</code> 的引用数量，可以分为少、中、多三种情况。针对这三种情况，有三种不同的数据结构来应对，<strong>分别是稀疏表、细粒度表和粗粒度表</strong>。三种表之间的关系是不断粗化的，如下图所示：</p>
<p><img src="http://cdn.processon.com/61cad84963768964cae91206?e=1640687193&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:JaQiVfiNNmqmu-q7bu6wBNZB84E=" alt="image"></p>
<h2 id="关于安全点的补充"><a href="#关于安全点的补充" class="headerlink" title="关于安全点的补充"></a>关于安全点的补充</h2><p>当 <code>GC</code> 线程需要进行 <code>STW</code> 时，会等待所有业务线程都运行到最近的安全点，我们知道，标记根对象 <code>GCRoot</code> 是追踪式回收算法必须的阶段， <code>GC</code> 线程在寻找 <code>GCRoot</code> 时并不会从头查找整个上下文和全局的引用位置去做遍历，因为这样做的效率太低了，而且根对象的标记时间也会随着数量变长。所以在 <code>HotSpot</code> 中借助了一种名叫 <code>oopMap</code> 的辅助结构来记录根对象。</p>
<p>对于静态数据来说，编译器会在解释阶段将 <code>oopMap</code> 维护进去。而对于运行中动态产生的对象。<code>JIT</code> 解释器会负责将它维护到 <code>oopMap</code> 中。</p>
<p> <strong>所以说 oopmap 的作用，就是避免直接查找根对象</strong>，但是这里有个新问题就是，运行时可以改变 <code>oopMap</code> 的指令太多了。不太可能每个地方都去维护一次 <code>oopmap</code>。</p>
<p> 所以 <code>HotSpot</code> 仅在一些关键地方来统一维护 <code>oopMap</code> ，这些地方就被称为安全点 <code>safe point</code> 。 这些特定的位置主要在： </p>
<ul>
<li>1、循环的末尾 </li>
<li>2、方法临返回前 / 调用方法的call指令后 </li>
<li>3、可能抛异常的位置</li>
</ul>
<h2 id="Pauseless-GC-是如何实现的"><a href="#Pauseless-GC-是如何实现的" class="headerlink" title="Pauseless  GC 是如何实现的"></a>Pauseless  GC 是如何实现的</h2><p>介绍完前面的 <code>CMS</code> 、 <code>G1</code> 等收集器之后可以发现，在原有的思想下，我们已经把能够实现与业务线程并发工作的地方都做了并发处理了。只剩下复制（<code>G1</code> 中称为转移）对象的地址时，仍然需要 <code>STW</code> 。下面我们看看 <code>HotSpot</code> 中无暂停 <code>GC</code> 的代表 <code>ZGC</code> 是如何做的。（并不是真的说完全无暂停，在进行 <code>GCRoot</code> 标记时还是需要停下来的）</p>
<p><code>ZGC</code> 和 <code>G1</code> 的思想很相似，它们都使用将存活对象拷贝到空闲区域的方式进行回收，<code>ZGC</code> 也将整个对区域划分为多个小块，回收时也会优先选择一部分区域，而它最主要的区别在于，<strong>ZGC 可以实现并发的活跃对象对象复制</strong>，而这依赖于两个技术：<strong>读屏障+染色指针</strong></p>
<p>在了解读屏障和染色指针之前，我们需要复习一下计算机基础知识→什么是虚拟地址，以及什么是物理地址。</p>
<p><strong>首先，物理地址指的是我们 PC 上的那根内存条</strong>，例如我的内存条为 <code>8G</code> ，那么它所能存储的地址就是从 <code>0~8G</code>。在原始时期，程序员想要对数据进行读写操作都得操作物理内存，这就导致每个数据的地址分配在什么地方、如何合理地进行内存划分、如何保证数据的正确性，都需要编程人员来管理，效率十分低下。为了解决这个问题，<code>CPU</code> 的设计人员 基于<strong>局部性原理</strong>进行了一层虚拟化，这就是虚拟内存。这样一来，我们编写程序时就只需要操作虚拟内存就可以了。</p>
<p><code>CPU</code> 内部通过内存映射单元（<code>MMU</code>）为我们自动完成虚拟内存到物理内存的映射关系，大致如下：</p>
<blockquote>
<p>图中的物理空间即我们的内存条，上面的可分配空间并不一定是连续的.而虚拟空间则是根据进程划分，每个进程都对应这一个虚拟空间</p>
</blockquote>
<p><img src="http://cdn.processon.com/61b9b4ff7d9c0868e0234f9c?e=1639564047&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:AIU83Sh69qfrU2r8OD2g69HFl-A=" alt="image"></p>
<p>这里有几个重要的知识点需要掌握：</p>
<ul>
<li>1.<code>CPU</code> 为<strong>每个进程</strong>都虚拟化了同样大小的虚拟内存空间</li>
<li>2.虚拟内存是有大小的，例如 <code>32</code> 位系统是 <code>2^32</code> ,也就是 <code>4G</code> 大小。而 <code>64</code> 系统只使用了低 <code>48</code> 位，大小为 <code>2^48</code>，即 <code>256T</code></li>
<li>3.虽然虚拟内存很大，但要实际使用这些内存，还是需要分配在物理内存上能使用。</li>
</ul>
<p>虚拟内存与物理内存的映射可以用人数和酒店的房间数来做类比，酒店只有 <code>100</code> 间房，在 <code>100</code> 天之内可以住 <code>10000</code> 人，而同时住房的→只有 <code>100</code> 人。（所以如果需要申请的内存超出了 <code>100</code>，就会发生 <code>OOM</code> ）</p>
<h3 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h3><p>在 <code>CMS</code> 和 <code>G1</code> 中都用到了写屏障（<code>write barrier</code>）来解决漏标问题，而 <code>ZGC</code> 中则使用到了与之相对的读屏障（<code>read barrier</code>）技术。</p>
<p>当业务线程触发访问动作时，如果该对象正在转移过程中，那么访问该对象的原地址。如果对象已经转移完成，那么则访问该对象的新地址。<strong>read barrier 用于判断该对象是否已经转移完成</strong></p>
<p><img src="http://cdn.processon.com/61ceb5c6e401fd7a538eef7c?e=1640940502&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:QbMOQ0ktySYbuQnC_LJftq2Zkic=" alt="image"></p>
<p>如上图所示，线程 <code>a</code> 访问时对象 <code>A</code> 还没有完成地址转移，所以访问的是原地址，当线程 <code>b</code> 访问时，对象已经转移完成了，此时就会触发 <code>write barrier</code> 访问转移后的 <code>A&#39;</code> 新地址</p>
<p><strong>对于一个常规的程序来说，对象的读操作数量通常都会高于写操作的数量，所以读屏障对性能的要求更高，为了解决这个问题，ZGC 使用了染色指针</strong></p>
<h3 id="染色指针"><a href="#染色指针" class="headerlink" title="染色指针"></a>染色指针</h3><p>前面说到，在 <code>64</code> 位机器上，<code>CPU</code> 为每个进程都虚拟化了 <code>256T</code> 大小的虚拟地址，而我们的程序是用不了这么大内存的，于是 <code>ZGC</code> 将虚拟地址的第 <code>42-45</code> 四个位置作为标记位，把 <code>0-41</code> 位的地址留给程序作为堆空间来使用（依然还能使用 <code>4T</code>）</p>
<p><img src="http://cdn.processon.com/61cec002f346fb0692ae44b6?e=1640943122&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Ibwk-R6T4w1i3Kee_7CgMrZi8XA=" alt="image"></p>
<p><code>ZGC</code> 将不同的标记位置为 <code>1</code>，用于代表对象所处的不同状态，目前包括 <code>Marked0</code>、<code>Marked1</code>、<code>Remapped</code>、<code>Finalizable</code> 四个状态，我们只需关注前三个状态即可，<code>Finalizable</code> 说的是 与弱引用有关(我也没去细看，忽略忽略)，<strong>我们需要关注的重点是，不管这个标记位的值是什么，它们都指向的是同一个物理地址</strong>，为什么要这么做呢？</p>
<p>试想一下，在以前如果我们要在对象上存储一些额外的、只供收集器或者虚拟机本身使用的数据，<strong>通常会在对象头中增加额外的存储字段</strong>。例如对象的  <code>Hashcode</code>、分代年龄、<code>forwarding</code> 指针、锁标记位等等。这种记录方式在有对象访问的场景下是很自然流畅的，不会有什么额外负担。<strong>但是如果对象存在被移动的可能性，在不知道是否能成功访问到对象的情况下，甚至是不访问对象，但是却希望得知该对象的某些信息的情况下，对象头中的信息就排不上用场了，</strong> 于是乎，<code>ZGC</code> 把主意打在了对象的虚拟地址上。</p>
<p>下面为染色指针技术带来的一些优势总结：</p>
<ul>
<li>1.有了染色指针的支持后，无需直接访问对象，就可以根据地址的标记位判断是否发生了迁移，也就解决了读屏障的性能问题。并且，一旦某个 <code>Region</code> 中的存活对象被移走之后，原来的 <code>Region</code> 就能够释放和重用；</li>
<li>2.可以减少收集过程中内存屏障的使用数量，在此之前写屏障的目的通常是为了记录对象引用的变动情况，而现在可以直接维护在指针中，并且目前 <code>ZGC</code> 没有使用任何写屏障，一部分是指针带来的优势，另一部分是 <code>ZGC</code> 目前还不支持分代收集，不存在跨代引用。</li>
<li>3.这种类似的使用地址位进行标记的方式，可以作为一种扩展的存储结构来记录更多的一些信息，以便日后进一步提高性能。</li>
</ul>
<p><strong>下面来看看 ZGC 的回收流程</strong>：</p>
<p>在 <code>GC</code> 线程开始工作前，所有的对象都处于 <code>Remapped</code> 状态，经过 <code>GCRoot</code> 标记之后，会把存活对象的状态标记修改为 <code>Marked0</code> 状态，仍然处于 <code>Remapped</code> 状态的对象则会被当做垃圾对象。在这个过程中<strong>新产生的对象也像 G1 那样，均当做存活对象处理</strong>。</p>
<p><strong>正因为不同标记位指向的是同一个物理地址，所以，从地址上业务线程就能够判断出该对象是否发生了转移</strong></p>
<p><img src="http://cdn.processon.com/61ced38a5653bb069fede1eb?e=1640948122&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:iCEHRsH2KBfOEBrQ0m-5ZQRD-cs=" alt="image"></p>
<p>标记结束后，接下来 <code>GC</code> 线程会把存活对象转移到空闲区域，并为他们分配新的地址空间，此时会涉及到对象的移动。这个过程总体分为以下两个步骤：</p>
<ul>
<li>选择一个区域 ，将其中存活的对象，迁移到另一个区域</li>
<li>将这些存活对象，放到 <code>forwarding table</code> 中（记录了对象的新地址）</li>
</ul>
<p><img src="http://cdn.processon.com/61ced31b07912973efb1eceb?e=1640948012&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:PEDSV-sTJbjq1D3RbMT2kxgSxt0=" alt="image"></p>
<p>由于业务线程访问对象的时机不确定</p>
<ul>
<li>如果访问时还没有完成转移（还处于 <code>Marked0</code> 状态），则业务线程会主动完成转移操作（也称为“自愈”过程），并将信息维护到 <code>forwarding table</code> 中。</li>
<li>如果已经完成了转移，则直接去 <code>forwarding table</code> 中查找映射，修改引用即可</li>
</ul>
<p><img src="http://cdn.processon.com/61ced3327d9c083657b28482?e=1640948035&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:6KqZulgZIyAJsQyAO5__YuKIu7M=" alt="image"></p>
<p><strong>那 Marked1 状态是什么时候使用的呢？</strong></p>
<p>还记得年轻代，区域划分中的 <code>S0</code> 和 <code>S1</code> 两个 <code>survicor</code> 区域么- -，<code>Marked0</code> 与 <code>Marked1</code> 的关系与它们类似，会在每一次 <code>GC</code> 时互换身份。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>周志明-《深入理解java虚拟机第三版》</li>
<li>海纳-《编程高手必学的内存知识》</li>
</ul>
]]></content>
      <categories>
        <category>深入java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis插件开发</title>
    <url>/2019/11/30/mybatis%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="Mybatis整体工作流程介绍"><a href="#Mybatis整体工作流程介绍" class="headerlink" title="Mybatis整体工作流程介绍"></a>Mybatis整体工作流程介绍</h2><p>一个标准的<code>mybatis</code>查询通常如下所示,此处不考虑整合<code>spring</code>，总体思想是类似的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectAll() throws IOException &#123;</span><br><span class="line">    Reader reader = null;</span><br><span class="line">    SqlSession sqlSession = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">        sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        List&lt;Country&gt; countryList = sqlSession.selectList(&quot;selectAll&quot;);</span><br><span class="line">        printCountryList(countryList);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (reader != null)</span><br><span class="line">            reader.close();</span><br><span class="line">        if (sqlSession != null)</span><br><span class="line">            sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>获取<code>Mybatis</code>的配置文件，内部通过<code>ClassLoader</code>加载文件流，这一步需要对<code>Classloader</code>有一定的理解<a id="more"></a></li>
<li>创建<code>SqlSessionFactory</code>, 通过JDK内部的w3c解析配置文件的内容，封装到<code>Configration</code>对象中，最后通过<code>Configuration</code>来创建<code>DefaultSqlSessionFactory</code>.</li>
<li>通过<code>SqlSessionFactory</code>创建<code>SqlSession</code>对象</li>
<li>不同的<code>executor</code>内部的查询方法不同，分为<code>BatchExecutor</code>，<code>ReuseExecutor</code>，<code>SimpleExecutor</code>以及<code>CachingExecutor</code></li>
<li><code>executor</code>的<code>query</code>方法将真正的查询交给具体实现类的<code>doQuery</code>来执行</li>
<li><code>doquery</code>中会使用到的<code>StatementHandler</code>用于封装处理<code>jdbc</code>的<code>statement</code>，<code>ResultHandler</code>用于处理结果集。最后将结果返回为一个<code>List&lt;Object&gt;</code>，<code>selectOne</code>调用的还是<code>SelectList</code>,只是在取结果集的时候，返回了第一个元素。</li>
</ul>
<h4 id="工作流程图："><a href="#工作流程图：" class="headerlink" title="工作流程图："></a>工作流程图：</h4><p><img src="/images/mybatis.png" alt="image"></p>
<h2 id="源码体现方式"><a href="#源码体现方式" class="headerlink" title="源码体现方式"></a>源码体现方式</h2><h4 id="openSession："><a href="#openSession：" class="headerlink" title="openSession："></a>openSession：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//打开对应数据源的Session</span><br><span class="line">//ExecutorType包含三种SIMPLE,REUSE,BATCH(分别对应三种Executor)，level为事务级别，autocommit自动提交</span><br><span class="line"> private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      //获取数据源相关信息</span><br><span class="line">      final Environment environment = configuration.getEnvironment();</span><br><span class="line">      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      </span><br><span class="line">      //根据execTyoe创建对应的Executor（工厂模式）,具体代码见下方</span><br><span class="line">      final Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); // may have fetched a connection so lets call close()</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取Executor"><a href="#获取Executor" class="headerlink" title="获取Executor"></a>获取Executor</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//根据executorType创建执行器</span><br><span class="line">public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    executorType = executorType == null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    if (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      executor = new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">      executor = new CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    //这里的PluginAll()方法，即执行executor下的拦截器，后面会提到</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>相关Handler</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    //pluginAll</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    return parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span><br><span class="line">      ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    //pluginAll</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    return resultSetHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    //pluginAll</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    return statementHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>pluginAll</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//拦截器链，该类维护了一个实现Interceptor的集合，调用pluginAll时，会依次调用对应的拦截器。</span><br><span class="line">public class InterceptorChain &#123;</span><br><span class="line"></span><br><span class="line">  private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  public Object pluginAll(Object target) &#123;</span><br><span class="line">    for (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插件-拦截器-开发"><a href="#插件-拦截器-开发" class="headerlink" title="插件(拦截器)开发"></a>插件(拦截器)开发</h2><p>说是插件，其实就是类似拦截器一般的功能。在<code>Mybatis</code>中，可以插入拦截器的地方有以下几个:</p>
<ul>
<li>executor （拦截执行器）</li>
<li>parameterHandler (拦截参数)</li>
<li>ResultSetHandler (拦截结果集)</li>
<li>StatementHandler (拦截sql构建)</li>
</ul>
<table>
<thead>
<tr>
<th>拦截位置</th>
<th>拦截内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>Executor</td>
<td>query、update、flushStatements、commit、rollback、getTransaction、close、isClosed</td>
</tr>
<tr>
<td>ParameterHandler</td>
<td>getParameterObject、setParameters</td>
</tr>
<tr>
<td>ResultSetHandler</td>
<td>handleResultSets、handleCursorResultSets、handleOutputParameters</td>
</tr>
<tr>
<td>StatementHandler</td>
<td>prepare、parameterize、batch、update、query</td>
</tr>
</tbody>
</table>
<p>在之前的<code>newExecutor</code>方法，以及各种<code>handler</code>处理器的地方提到过<code>PluginAll</code>方法，其实就是对应的这几个位置。</p>
<h3 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h3><p><strong>Mybatis插件通过实现拦截器接口Interceptor来完成</strong>，原接口如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Interceptor &#123;</span><br><span class="line">    Object intercept(Incocation invocation) throws Throwable;</span><br><span class="line">    </span><br><span class="line">    Object plugin(Object target);</span><br><span class="line">    </span><br><span class="line">    void setProperties(Properties properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setProperties</code>主要是给拦截器提供参数用的，使用方式简单，此处不再介绍。</p>
<p>再来看<code>plugin</code>方法，其参数为<code>target</code>，即拦截器所要拦截的对象。前面说到<code>InterceptorChain</code>维护了一个<code>Interceptor</code>的集合，这里的<code>plugin</code>方法实际是在对应的拦截位置，由<code>InterceptorChain</code>进行循环调用时触发。实现类直接通过如下方式使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object plugin(Object target) &#123;</span><br><span class="line">    return Plugin.wrap(target, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>plugin.warp()</code>方法会自动判断<strong>拦截器的签名</strong>(接下来会介绍到)和被拦截的接口是否匹配，在两者一致的情况下会通过动态代理拦截该对象（如拦截器的签名为<code>query</code>，那么在调用<code>query</code>方法时会被拦截）。</p>
<p><code>intercept</code>方法则是拦截器执行拦截逻辑的地方，其参数类型为<code>Invocation</code>，可以从中获取到很多反射相关的信息,如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    </span><br><span class="line">    //getArgs返回的是被拦截方法的参数，这里取第一个参数MappedStatement</span><br><span class="line">    MappedStatement mappedStatement = (MappedStatement)invocation.getArgs()[0];</span><br><span class="line">    String sqlId = mappedStatement.getId();</span><br><span class="line">    //代理对象</span><br><span class="line">    Object target = invocation.getTarget():</span><br><span class="line">    //方法名</span><br><span class="line">    String methodName = invocation.getMethod().getName();</span><br><span class="line">    //获取以上信息后.............在此处完成业务需求(如参数处理，驼峰映射等)</span><br><span class="line">    </span><br><span class="line">   //最后通过invocation.proceed()返回结果</span><br><span class="line">   //本质上proceed()方法是调用了method.invoke(target,args)</span><br><span class="line">    return invocation.proceed();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="拦截器签名"><a href="#拦截器签名" class="headerlink" title="拦截器签名"></a>拦截器签名</h3><p>在自定义拦截器的过程中，实现<code>Interceptor</code>只表示声明了一个拦截器，但该<strong>拦截器实际在什么位置使用则需要拦截器签名来进行定义</strong>。</p>
<p>使用<code>@Intercepts</code>和签名注解<code>@Signature</code>来配置拦截器所要拦截的方法。</p>
<p><code>@Intercepts</code>注解中的属性是一个<code>@Signature</code>签名数组，可以在同一个拦截器中同时拦截不同的接口和方法，使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//以拦截参数处理器ParameterHandler的setParameters为例</span><br><span class="line">@Intercepts(&#123;@Signature(type = ParameterHandler.class, method = &quot;setParameters&quot;, </span><br><span class="line">    args = &#123;PreparedStatement.class&#125;)&#125;)</span><br></pre></td></tr></table></figure>
<p><code>@Signature</code>包含三个属性：</p>
<ul>
<li>type：设置拦截的接口，即<code>Executor</code>,<code>ParameterHandler</code>,<code>ResultSetHandler</code>,<code>StatementHandler</code>四者中的一个</li>
<li>method：设置拦截接口中的方法名，根据前面表格中的对应关系来。</li>
<li>args：设置拦截方法的参数类型数组，通过方法名和参数类型可以确定唯一一个方法。</li>
</ul>
<p>参考刘增辉老师的<code>《Mybatis从入门到精通》</code>，接下来例举一些较为常用的被拦截方法和接口</p>
<p><strong>（可先看后面的实例，回头再来理解各接口的拦截签名）</strong></p>
<h4 id="拦截Executor接口"><a href="#拦截Executor接口" class="headerlink" title="拦截Executor接口"></a>拦截Executor接口</h4><p><code>Executor</code>接口包含的几个方法：</p>
<ul>
<li>int update(MappedStatedment ms,Object Parameter) throws SQLException<blockquote>
<p>该方法会拦截所有的<code>INSERT、UPDATE、DELETE</code>操作，对应的签名为：</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatedment.class,Object.class&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><e> List<e> query(MappedStatedment ms,Object parameter,RowBounds rowBounds,ResultHandler resultHandler) throws SQLException</e></e></p>
<blockquote>
<p>该方法用于拦截所有的<code>SELECT</code>查询方法，一般是最常被拦截的方法，对应的签名为：：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatedment.class,Object.class,RowBounds.class,ResultHandler.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>void commit(boolean required) throws SQLException</p>
<blockquote>
<p>该方法只在通过<code>sqlsession</code>调用<code>commit</code>方法时才被调用，接口方法对应的签名为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = Executor.class, method = &quot;commit&quot;, args = &#123;boolean.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>void rollback(boolean required) throws SQLException</p>
<blockquote>
<p>该方法只在通过<code>sqlsession</code>调用<code>rollback</code>方法时才被调用，接口方法对应的签名为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = Executor.class, method = &quot;rollback&quot;, args = &#123;boolean.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>除以上之外，还有<code>getTransaction</code>、<code>isClosed</code>、<code>close</code>、<code>flushStatements</code>、<code>queryCursor</code>等方法可以拦截，但是即应用不常见，此处略过。</p>
<h4 id="拦截ParameterHandler接口"><a href="#拦截ParameterHandler接口" class="headerlink" title="拦截ParameterHandler接口"></a>拦截ParameterHandler接口</h4><p><code>ParameterHandler</code>接口的方法很少，只有以下两个</p>
<ul>
<li><p>Object getParameterObject()</p>
<blockquote>
<p>该方法只在执行存储过程处理出参的时候被调用，接口对应的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = ParameterHandler.class, method = &quot;getParameterObject&quot;, args = &#123;&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>void setParameters(PreparedStatement var1) throws SQLException</p>
<blockquote>
<p>该方法在设置SQL参数时被调用，接口对应的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = ParameterHandler.class, method = &quot;setParameters&quot;, args = &#123;PreparedStatedment.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="拦截ResultSetHandler"><a href="#拦截ResultSetHandler" class="headerlink" title="拦截ResultSetHandler"></a>拦截ResultSetHandler</h4><p><code>ResultSetHandler</code>接口包含如下三个方法：</p>
<ul>
<li><p><e> List<e> handleResultSets(Statement var1) throws SQLException</e></e></p>
<blockquote>
<p>该方法会拦截除存储过程及返回值类型为<code>Cursor&lt;T&gt;</code>以外的查询方法，对应的签名为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = ResultSetHandler.class, method = &quot;handleResultSets&quot;, args = &#123;Statement.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><e> Cursor<e> handleCursorResultSets(Statement var1) throws SQLException</e></e></p>
<blockquote>
<p>3.4.0新增方法，拦截返回值类型为<code>Cursor&lt;T&gt;</code>的方法，对应的签名为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = ResultSetHandler.class, method = &quot;handleCursorResultSets&quot;, args = &#123;Statement.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>void handleOutputParameters(CallableStatement var1) throws SQLException</p>
<blockquote>
<p>该方法在使用存储过程处理出参时被调用，对应的签名为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = ResultSetHandler.class, method = &quot;handleOutputParameters&quot;, args = &#123;CallableStatement.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="拦截StatementHandler接口"><a href="#拦截StatementHandler接口" class="headerlink" title="拦截StatementHandler接口"></a>拦截StatementHandler接口</h3><ul>
<li><p>Statement prepare(Connection var1, Integer var2) throws SQLException</p>
<blockquote>
<p>在数据库执行前被调用，优于当前接口中的其他方法，对应的签名为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = StatementHandler.class, method = &quot;prepare&quot;, args = &#123;Connection.class,Integer.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>void parameterize(Statement var1) throws SQLException</p>
<blockquote>
<p>在<code>prepare</code>方法之后执行，用于处理参数，对应的签名为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = StatementHandler.class, method = &quot;parameterize&quot;, args = &#123;Statement.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>void batch(Statement var1) throws SQLException</p>
<blockquote>
<p>在全局设置配置<code>defaultExecutorType=&quot;Batch&quot;</code>时，操作数据库会执行该方法，对应的签名为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = &#123;Statement.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><e> List<e> query(Statement var1, ResultHandler var2) throws SQLException</e></e></p>
<blockquote>
<p>执行<code>SELECT</code>方法时被调用，对应的签名为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class,ResultHandler.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><e> Cursor<e> queryCursor(Statement var1) throws SQLException</e></e></p>
<blockquote>
<p>3.4.0新增方法，在返回值类型为<code>Cursor&lt;T&gt;</code>的查询中被调用，对应的签名为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Signature(type = StatementHandler.class, method = &quot;queryCursor&quot;, args = &#123;Statement.class&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="拦截器实例"><a href="#拦截器实例" class="headerlink" title="拦截器实例"></a>拦截器实例</h3><p>这里先介绍一个刘增辉老师书本上的例子，再介绍一个项目中实际使用到的场景。</p>
<h4 id="下划线转驼峰插件"><a href="#下划线转驼峰插件" class="headerlink" title="下划线转驼峰插件"></a>下划线转驼峰插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * MyBatis Map 类型下划线 Key 转小写驼峰形式</span><br><span class="line"> *</span><br><span class="line"> * @author liuzenghui</span><br><span class="line"> */</span><br><span class="line"> //返回值类型为Map，映射字段中的下划线为驼峰，由于是对返回值做拦截，所以这里签名指定ResultSetHandler</span><br><span class="line"> //方法为handleResultSets，处理除存储过程和返回值为Cursor以外的所有结果</span><br><span class="line">@Intercepts(</span><br><span class="line">    @Signature(type = ResultSetHandler.class, method = &quot;handleResultSets&quot;, args = &#123;Statement.class&#125;)</span><br><span class="line">)</span><br><span class="line">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">public class CameHumpInterceptor implements Interceptor &#123;</span><br><span class="line">    </span><br><span class="line">	@Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        //先执行得到结果，再对结果进行处理</span><br><span class="line">        List&lt;Object&gt; list = (List&lt;Object&gt;) invocation.proceed();</span><br><span class="line">        for(Object object : list)&#123;</span><br><span class="line">        	//如果结果是 Map 类型，就对 Map 的 Key 进行转换</span><br><span class="line">            if(object instanceof Map)&#123;</span><br><span class="line">                processMap((Map)object);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理 Map 类型</span><br><span class="line">     *</span><br><span class="line">     * @param map</span><br><span class="line">     */</span><br><span class="line">    private void processMap(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">        Set&lt;String&gt; keySet = new HashSet&lt;String&gt;(map.keySet());</span><br><span class="line">        for(String key : keySet)&#123;</span><br><span class="line">        	//大写开头的会将整个字符串转换为小写，如果包含下划线也会处理为驼峰</span><br><span class="line">        	if((key.charAt(0) &gt;= &apos;A&apos; &amp;&amp; key.charAt(0) &lt;= &apos;Z&apos;) || key.indexOf(&quot;_&quot;) &gt;= 0)&#123;</span><br><span class="line">        		Object value = map.get(key);</span><br><span class="line">        		map.remove(key);</span><br><span class="line">        		map.put(underlineToCamelhump(key), value);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将下划线风格替换为驼峰风格</span><br><span class="line">     *</span><br><span class="line">     * @param inputString</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String underlineToCamelhump(String inputString) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        boolean nextUpperCase = false;</span><br><span class="line">        for (int i = 0; i &lt; inputString.length(); i++) &#123;</span><br><span class="line">            char c = inputString.charAt(i);</span><br><span class="line">            if(c == &apos;_&apos;)&#123;</span><br><span class="line">            	if (sb.length() &gt; 0) &#123;</span><br><span class="line">                    nextUpperCase = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	if (nextUpperCase) &#123;</span><br><span class="line">                    sb.append(Character.toUpperCase(c));</span><br><span class="line">                    nextUpperCase = false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    sb.append(Character.toLowerCase(c));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">    	return Plugin.wrap(target, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="项目中所用到的例子"><a href="#项目中所用到的例子" class="headerlink" title="项目中所用到的例子"></a>项目中所用到的例子</h4><p>拦截<code>Executor</code>接口的<code>update</code>和<code>query</code>方法，对添加了自定义注解<code>@DefaultParamsInsert</code>的方法方法进行默认参数追加。</p>
<p>(这里的作用类似于新增一条记录时。默认加上录入人id、行政区划、单位等)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Intercepts(&#123;@Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;),</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;query&quot;,</span><br><span class="line">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span><br><span class="line">public class ParamsInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CommonUtil commonUtil;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;system.xzqh&#125;&quot;)</span><br><span class="line">    private String xzqh;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        //从invocation获取需要的信息</span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement)invocation.getArgs()[0];</span><br><span class="line">        String sqlId = mappedStatement.getId();</span><br><span class="line">        String runMethod = &quot;&quot;;</span><br><span class="line">        if (sqlId.indexOf(&apos;.&apos;) &gt; -1) &#123;</span><br><span class="line">            runMethod = sqlId.substring(sqlId.lastIndexOf(&apos;.&apos;) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        String className = sqlId.substring(0, sqlId.lastIndexOf(&apos;.&apos;));</span><br><span class="line">        String methodName = invocation.getMethod().getName();</span><br><span class="line">        Method[] method = Class.forName(className).getMethods();</span><br><span class="line">        //进行逻辑处理</span><br><span class="line">        for (Method m : method) &#123;</span><br><span class="line">            // 找到需注入默认值的接口方法，即添加了自定义注解@DefaultParamsInsert的方法</span><br><span class="line">            Annotation annotation = m.getAnnotation(DefaultParamsInsert.class);</span><br><span class="line">            if (annotation != null &amp;&amp; StringUtils.equals(methodName, &quot;update&quot;) &amp;&amp; m.getName().equals(runMethod)) &#123;</span><br><span class="line">                Object parameter = invocation.getArgs()[1];</span><br><span class="line">                // 注入对象值</span><br><span class="line">                setProperty(parameter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return invocation.proceed();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * ParamsInterceptor</span><br><span class="line">     *</span><br><span class="line">     * @description 设置需要侵入的key-value</span><br><span class="line">     * @param obj 注入值的对象</span><br><span class="line">     */</span><br><span class="line">    private void setProperty(Object obj) &#123;</span><br><span class="line">        if (obj != null &amp;&amp; commonUtil != null) &#123;</span><br><span class="line">            User user = commonUtil.getCurrentUser();</span><br><span class="line">            Corp corp = commonUtil.getCurrentCorp();</span><br><span class="line">            if (user != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (BeanUtils.getProperty(obj, &quot;ccjr&quot;) == null) &#123;</span><br><span class="line">                        BeanUtils.setProperty(obj, &quot;ccjr&quot;, user.getId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (BeanUtils.getProperty(obj, &quot;csjly&quot;) == null) &#123;</span><br><span class="line">                        BeanUtils.setProperty(obj, &quot;csjly&quot;, xzqh);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (BeanUtils.getProperty(obj, &quot;ccorp&quot;) == null) &#123;</span><br><span class="line">                        BeanUtils.setProperty(obj, &quot;ccorp&quot;, user.getCorpId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (BeanUtils.getProperty(obj, &quot;cdept&quot;) == null) &#123;</span><br><span class="line">                        BeanUtils.setProperty(obj, &quot;cdept&quot;, user.getDeptId());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.warn(&quot;设置需要侵入的key-value error&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @see org.apache.ibatis.plugin.Interceptor#setProperties(java.util.Properties)</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">        // Interceptor 接口默认方法</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上です。</p>
]]></content>
      <categories>
        <category>深入java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>向着ECE努力</title>
    <url>/2021/04/05/%E5%90%91%E7%9D%80ECE%E5%8A%AA%E5%8A%9B/</url>
    <content><![CDATA[<p>果然一个人的学习自制力是很差的，趁着这次官方团购优惠报名了ECE认证。算是以考代学逼自己一把。</p>
<p>未来的两个月内会坚持每天打卡，记录下认证准备的过程~，目前的大致目标如下：</p>
<ul>
<li>4月熟悉官方文档，复习考点知识及相关原理</li>
<li>5月模拟题演练、实战记录</li>
<li>6月再巩固一小短时间，月内拿下认证（7月之后的考试版本就升级了）。</li>
</ul>
<hr>
<p>明日香 –&gt; <a id="more"></a></p>
<p><img src="/images/202104/asuka.jpg" alt="Alt"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>倒排索引---联合查询加速</title>
    <url>/2021/04/24/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95---%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<h2 id="1-位图与布隆过滤器"><a href="#1-位图与布隆过滤器" class="headerlink" title="1. 位图与布隆过滤器"></a>1. 位图与布隆过滤器</h2><p>位图通常用于状态检索，通过与或操作来判断，检索效率为 <code>O(1)</code>。相比数组而言，虽然检索效率相同，但可以减小内存占用，一个 <code>2^32=40亿</code> 的位图占用为 <code>512M</code>，同样的情况下数组在使用 <code>boolean</code> 类型时内存占用为位图的 <code>8</code> 倍，而使用 <code>int32</code> 时占用为 <code>4</code> 字节，内存占用是位图的 <code>32</code> 倍；</p>
<a id="more"></a>
<p>由于位图所使用的单元已经是最小的单位 <code>bit</code>，为了再次缩小位图空间，想到的办法是压缩数据（<code>Hash</code>之后再存储），缩小元素个数。但是压缩数据势必会引起 <code>Hash</code> 冲突，压缩的越小，冲突越大。于是又回到了 <code>Hash</code> 冲突解决法： 开放寻址、链式 <code>Hash</code> ；</p>
<p>链式 <code>Hash</code> 无法减小空间（<code>why？</code>），而开放寻址有一种优化策略：“双散列”。其原理是使用多个 <code>Hash</code> 函数分别求 <code>Hash</code> 值，得到多个下标，将对应的下标位置均置为 <code>1</code> ，而这其实就是 “布隆过滤器” 的设计思想，通过多个下标来判断，就减小了 <code>Hash</code> 冲突，当然也带来一个问题 —&gt; 布隆过滤器的删除，需要通过计数器，或者定时重建才行，不能直接将对应位置置为 <code>0</code>；</p>
<p>同样的，“布隆过滤器” 也有自己的缺点：即使任何两个元素的哈希值不冲突，而且我们查询对象的 <code>k</code> 个位置的值都是 <code>1</code>，查询结果为存在，这个结果也可能是错误的。<strong>这也称为是布隆过滤器的错误率</strong>（通常来说，误判可以当成实际存在来处理，大部分情况是不影响业务的。例如用户注册时，需要检测用户名是否已存在，已存在的话需要更换用户名重新注册）</p>
<p><span style="color:red">布隆过滤器图示：</span></p>
<p><img src="/images/202104/bloomfilter.png" alt="bloomfilter.png"></p>
<p><span style="color:red">位图是只有一个特殊的哈希函数，且没有被压缩长度的布隆过滤器。</span></p>
<h2 id="2-倒排索引"><a href="#2-倒排索引" class="headerlink" title="2. 倒排索引"></a>2. 倒排索引</h2><p>与倒排索引概念相对应的概念称为正排索引，也就是我们常规的数据库存储方式，以 <code>id</code> 对应一整行数据。当我们给定一个 <code>id</code> 时可以很快地找到该列，但如果给定的是某个字段中的词，正排索引只能一行一行到遍历，使用 <code>Like</code> 查找。当文档数据特别多，字段也特别多的时候，正排索引的查找效率就不行了，于是就有了倒排索引。根据关键字创建对应的文档索引，查找时直接根据关键词定位到数据本身。</p>
<p>倒排索引中的关键字 （<code>key</code>）的集合也称为 <strong>字典（<code>Dictionary</code>）</strong>，而 key 后面对应的文档集合也称为<strong>记录列表（<code>posting_list</code>）</strong>，倒排索引常见于各种全文检索场景中。</p>
<h3 id="2-1-倒排索引的创建"><a href="#2-1-倒排索引的创建" class="headerlink" title="2.1 倒排索引的创建"></a>2.1 倒排索引的创建</h3><p>倒排索引的创建步骤大致如下：</p>
<ul>
<li><ol>
<li>给每个文档进行唯一编号，对数据进行排序（<code>why？</code>），然后开始遍历文档；</li>
</ol>
</li>
<li><ol start="2">
<li>解析每个文档中的关键字，按照 &lt; 关键字，id，关键字位置&gt; 的结构进行存储，存储关键词位置的原因主要是组合查询时，通常需要判断多个关键词的位置是否足够接近来获取相关性算分（&lt; 关键字，id，关键字位置&gt;只是最基础的信息，为了加快检索速度，通常存储的内容更多）；</li>
</ol>
</li>
<li><ol start="3">
<li>将关键字作为 <code>key</code> 存入 <code>Hash</code> 表，如果 <code>posting_list</code> 已经存在则在后面追加文档，否则，新建一个 <code>posting_list</code>；</li>
</ol>
</li>
<li><ol start="4">
<li>重复 <code>2、3</code> 的步骤，处理完所有文档，完成倒排索引的创建，最后的数据存储结构图可以参考如下图例：</li>
</ol>
</li>
</ul>
<p><img src="/images/202104/倒排索引.png" alt="倒排索引.png"></p>
<h3 id="2-2-倒排索引的查询"><a href="#2-2-倒排索引的查询" class="headerlink" title="2.2 倒排索引的查询"></a>2.2 倒排索引的查询</h3><p>如果只是查询单个关键字在哪些文档中出现，直接以查询的关键字作为 <code>key</code>，得到的 <code>posting_list</code> 就是需要的结果了，但是如果需要查询同时包含关键词<code>A</code>，以及关键词 <code>B</code> 的文档时，就需要想办法获取两个 <code>posting_list</code> 中的公共元素。</p>
<p>假设 <code>posting_list A，B</code> 都是没有排序的链表，那么在寻找公共元素时，必须挨个比对  <code>A ,B</code> 两个链表中的每一个元素，这样查找的复杂度为 <code>O(m*n)</code>，如果是排好序的链表，那查找速度就变为 <code>O(m+n)</code> 了</p>
<p>归并的执行过程为，通过指针 <code>p1，p2</code> 分别指向链表 <code>A,B</code> 的第一个元素，比对是否相等，此时有以下三种情况：</p>
<ol>
<li>如果相等则直接放入结果集，<code>p1</code> 和 <code>p2</code> 分别向后移动；</li>
<li>如果 <code>p1 &gt; p2</code> ，那么将 <code>p2</code> 指针向后移动，<code>p1</code> 保持位置不变；</li>
<li>如果 <code>p1 &lt; p2</code> ，那么将 <code>p1</code> 指针向后移动，<code>p2</code> 保持位置不变；</li>
</ol>
<p>重复该步骤，直到 <code>p1</code> 或 <code>p2</code> 到达链表尾部。</p>
<h2 id="3-利用跳表加速倒排"><a href="#3-利用跳表加速倒排" class="headerlink" title="3. 利用跳表加速倒排"></a>3. 利用跳表加速倒排</h2><p>使用跳表存储 <code>posting_list</code> 时，可以按照如下方式判断：</p>
<p>如果 <code>A</code> 中的当前元素小于 <code>B</code> 中的当前元素，我们就以 <code>B</code> 中的当前元素为 <code>key</code>，在 <code>A</code> 中快速往前跳；如果 <code>B</code> 中的当前元素小于 <code>A</code> 中的当前元素，我们就以 <code>A</code> 中的当前元素为 <code>key</code>，在 <code>B</code> 中快速往前跳。如此一来，中间的很多元素就可以忽略掉，进一步提升了查找速度。</p>
<p><span style="color:red">跳表结构图示：</span></p>
<p><img src="/images/202104/skiplist.jpg" alt="skiplist.jpg"></p>
<p>常见的开源检索框架大多都使用到了这种方式。</p>
<h2 id="4-利用-Hash、位图加速倒排"><a href="#4-利用-Hash、位图加速倒排" class="headerlink" title="4. 利用 Hash、位图加速倒排"></a>4. 利用 Hash、位图加速倒排</h2><p>回到起点再试想一下。查找 <code>A , B</code> 中的公共元素，其实就是判断 <code>A</code> 是否在 <code>B</code> 中存在，<span style="color:red"><code>hash</code> 加速适用于求交集时，一个集合特别大(A)，另一个相对比较小(B)</span></p>
<p>那么我们可以提前将 <code>A</code> 中的元素映射为 <code>Hash</code> 表，然后对 <code>B</code> 中的原始逐个进行 <code>Hash</code> 查找即可，<span style="color:red">但前提是必须提前分析好，需要把哪些 <code>posting_list</code> 映射为 <code>Hash</code> 表，需要进行映射的数据不能进行频繁变动，不然就没有意义了</span>，同时原始的 <code>posting_list</code> 也必须保留，不然就取不到原始数据了。</p>
<p>位图是特殊的 <code>Hash</code> 结构，所以也是同样的道理。但适应场景有所不同：使用位图时，需要把所有的 posting_list 都转为位图，然后通过位运算来判断，同时具有以下局限性：</p>
<ul>
<li>位图法仅适用于只存储 <code>ID</code> 的简单的 <code>posting list</code>。如果 <code>posting list</code> 中需要存储复杂的对象，就不适合用位图来表示 <code>posting list</code> 了。</li>
<li>位图法仅适用于 <code>posting list</code> 中元素稠密的场景。对于 <code>posting list</code> 中<strong>元素稀疏的场景，使用位图的运算和存储开销反而会比使用链表更大</strong>。</li>
<li>虽然位图只需要用 <code>1</code> 个 <code>bit</code> 就能表示元素是否存在，但每个 <code>posting list</code> 都需要表示完整的对象空间。假设有 <code>2^32</code> 数量的文档，哪怕一个关键词只对应两个 <code>id</code> ，申请位图时也需要完整的 <code>2^32 bit</code> 的空间，只不过对应位置上全是 <code>0</code> 而已，这个占用高达 <code>512M</code>。</li>
</ul>
<p>成熟的工业界系统中，为了解决位图的空间消耗问题，经常会使用一种压缩位图的技术 <code>Roaring Bitmap</code> 来代替位图，诸如各大数据库、<code>Lucene</code> 等。 </p>
<h2 id="5-Roaring-Bitmap"><a href="#5-Roaring-Bitmap" class="headerlink" title="5. Roaring Bitmap"></a>5. Roaring Bitmap</h2><p><code>Roaring Bitmap</code> 是位图设计的另类思想，它将一个 <code>32</code> 位的整数划分为高 <code>16</code> 位和低 <code>16</code> 位。对于高 <code>16</code> 位，<code>Roaring Bitmap</code> 将它存储在一个 <strong>有序数组（变长）</strong> 中，每一个数字代表一个 “桶” ，而低 <code>16</code> 位存储的是一个 <code>2^16</code> 的位图，每个 “桶”  都对应着一个位图。</p>
<p><span style="color:red">Roaring bitMap 图示：</span></p>
<p><img src="/images/202104/roaringbitmap.jpg" alt="roaringbitmap.jpg"></p>
<p>当需要进行查找时，先通过二分查找获取到 “桶” 的位置 <code>O(logn)</code> ，再在位图中进行与或操作 <code>O(1)</code>，牺牲些许查找性能的同时，带来的好处是位图空间压缩</p>
<p>还是以一个关键词对应两个 <code>id</code> 为例，使用位图时必须申请全量空间 <code>2^32 bit = 512M</code> ; 而使用 <code>Roaring bitmap</code>时只需要申请两个桶（高位计算结果相同的话只需要一个）4字节（<code>short</code> 类型占两字节），低位的位图占用仅为 <code>2^16=8k</code></p>
<p><strong>所以Roaring Bitmap的总体思想，其实就是将不存在的桶的位图空间“全部”（<s>并不是</s>）省去这样的方式，来节省存储空间的</strong></p>
<p>提到位图时也说过，当元素稀疏时，使用位图(<span style="color:red">Bitmap Container</span>)的占用反而会比链表高，<code>Roaring Bitmap</code> 基于这个思想，当低位存储的内容少于 <code>4096</code> 时，使用变长的有序数组(<span style="color:red">Array Container</span>)来存储，大于 <code>4096</code> 之后才采用位图。</p>
<h4 id="为什么是4096"><a href="#为什么是4096" class="headerlink" title="为什么是4096"></a>为什么是4096</h4><p><code>Roaring Bitmap</code> 使用的是 <code>short</code> 类型的数组，每个元素为 <code>2</code>字节，当元素达到 <code>4096</code> 时，内存占用为 <code>8k</code>，与 <code>2^16</code> 的位图占用相当，所以选择的界限为 <code>4096</code></p>
<p><span style="color:red"><code>roaringbitmap</code> 并不能保证一定压缩空间，极端情况下会恢复为位图</span></p>
<p><a href="https://github.com/RoaringBitmap/RoaringBitmap" target="_blank" rel="noopener"> Roaring Bitmap仓库地址在这里~~ </a></p>
<h4 id="Lucene-的-RoaringDocIdSet-流程图"><a href="#Lucene-的-RoaringDocIdSet-流程图" class="headerlink" title="Lucene 的 RoaringDocIdSet 流程图"></a>Lucene 的 RoaringDocIdSet 流程图</h4><p><img src="/images/202104/RoaringDocIdSet.png" alt="RoaringDocIdSet.png"></p>
<p>图中的 <code>block</code> 其实就是所谓的 “桶”。</p>
<h2 id="6-联合查询加速法"><a href="#6-联合查询加速法" class="headerlink" title="6. 联合查询加速法"></a>6. 联合查询加速法</h2><h3 id="6-1-调整次序法，适用于多个-posting-list-集合数量差距较明显的场景"><a href="#6-1-调整次序法，适用于多个-posting-list-集合数量差距较明显的场景" class="headerlink" title="6.1 调整次序法，适用于多个 posting_list 集合数量差距较明显的场景"></a>6.1 调整次序法，适用于多个 posting_list 集合数量差距较明显的场景</h3><p>假设通过多个关键词联合查询，得到了三个 <code>posting_list A,B,C</code>；集合中包含的元素数量分别为 <code>2，20，40</code> 并且包含关系为 <code>A &lt; B &lt; C</code>。已知普通链表求交集的复杂度为 <code>O（m+n）</code>；同样是求三个集合交集的话</p>
<ul>
<li>先计算<code>（A ∩ B）</code>得到结果后再 <code>∩ C</code> 的复杂度为  <code>(20+2)=22</code>；得到的交集结果为 <code>2</code>， 再计算 <code>(40+2)=42</code> ，总计 <code>64</code> </li>
<li>先计算<code>（B ∩ C）</code> 得到结果后再 <code>∩ A</code> 的复杂度为 <code>（40+20）=60</code>；得到的交集结果为 <code>20</code>，再计算 <code>（20+2）=22</code>，总计 <code>82</code></li>
</ul>
<p>当然，调整次序法满足交换律，例如： <code>A∩（B∪C）= （A∩B）∪（A∩C）</code></p>
<h3 id="6-2-快速多路归并"><a href="#6-2-快速多路归并" class="headerlink" title="6.2 快速多路归并"></a>6.2 快速多路归并</h3><p>适用于元素数量差距不明显的场景，利用跳表的性质，快速跳过多个元素，加快多路归并的效率；</p>
<h3 id="6-3-预先组合法"><a href="#6-3-预先组合法" class="headerlink" title="6.3 预先组合法"></a>6.3 预先组合法</h3><p>例如经常查 <code>A+B+C</code>，那么可以组合 <code>posting_list</code> ，使其对应的 <code>key</code> 为 <code>A+B+C</code>；</p>
<h3 id="6-4-缓存法加速"><a href="#6-4-缓存法加速" class="headerlink" title="6.4 缓存法加速"></a>6.4 缓存法加速</h3><p>例如 <code>elasticsearch</code> 中的 <code>filter</code> 的运用</p>
<hr>
<p><img src="/images/202104/三藏.jpg" alt="Alt"></p>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>我来了，我的博客</title>
    <url>/2018/09/04/%E6%88%91%E6%9D%A5%E4%BA%86%EF%BC%8C%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>很久之前，在学习github的使用时就有了搭建这个个人博客的想法，虽说按照教程，早早地就已经搭建好了这个博客，  但是随着毕业季、入职工作等一系列的事情，也没有好好的静下心来整理。<br>现如今工作也稳定下来了，一年多的时间不长不短，也是时候总结一下自己了。从小到大没有写日志习惯的我，估计写出来的东西，也只有自己能看看吧（笑），权当做给自己做个笔记，记录些工作中和生活中的小事吧。</p>
<p>现在，第一步，先给我的hexo换个主题吧~</p>
<hr>
<p>第一次用markdown，语法还是挺奇怪的，不太习惯（雾）<br><a id="more"></a><br><img src="/images/2018-09-04.png" alt="Alt"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>使用kubeadm安装kubernetes 1.15版本</title>
    <url>/2019/07/14/%E4%BD%BF%E7%94%A8kubeadm%E5%AE%89%E8%A3%85kubernetes1.15%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="1-1-系统配置"><a href="#1-1-系统配置" class="headerlink" title="1.1 系统配置"></a>1.1 系统配置</h3><p>准备两台机器，关闭防火墙(这里列举的node1为192.168.110.130，node2为131)，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /etc/hosts</span><br><span class="line">192.168.110.130 node1</span><br><span class="line">192.168.110.131 node2</span><br></pre></td></tr></table></figure>
<p><code>systemctl stop firewalld</code> 或按照<a href="https://note.youdao.com/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/independent/install-kubeadm/</a>说明，开放端口。</p>
<p><strong>关闭selinux，然后reboot重启</strong><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setenforce 0                     ---- 0关闭，1启用</span><br><span class="line">vi /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure></p>
<p>创建/etc/sysctl.d/k8s.conf文件，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure>
<!--more-->
<p>执行命令使修改生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modprobe br_netfilter             ----该指令用于向内核中加载/移除模块</span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf    ----从指定文件加载系统参数</span><br></pre></td></tr></table></figure>
<h3 id="1-2-kube-proxy开启ipvs的前置条件"><a href="#1-2-kube-proxy开启ipvs的前置条件" class="headerlink" title="1.2 kube-proxy开启ipvs的前置条件"></a>1.2 kube-proxy开启ipvs的前置条件</h3><p><strong>kube-proxy是kubernetes重要的组件，它的作用是虚拟出一个VIP，保证VIP无论后台服务（pod，Endpoint）如何变更都保持不变，起到一个负载均衡的功能</strong>。<br>kube-proxty有三种模式ipvs、userspace、iptables三种，这里安装时使用ipvs模式（IP VirtualServer），所以需要为它加载以下的内核模块：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip_vs</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_wrr</span><br><span class="line">ip_vs_sh</span><br><span class="line">nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>
<p>在所涉及的kubernetes节点（这里仅有node1，node2），执行以下脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line">#!/bin/bash</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>
<p>上述脚本创建了/etc/sysconfig/modules/ipvs.modules文件，保证在节点重启后能自动加载所需模块。 使用 lsmod | grep -e ip_vs -e nf_conntrack_ipv4命令，可以查看是否已经正确加载所需的内核模块。<br>另外，还需要确保各节点已经安装了ipset软件包（一般情况系统都已经自带了） yum install ipset，为了方便查看ipvs的代理规则，最好也安装一下管理工具ipvsadm，yum install ipvsadm。<br>如果以上前提条件不满足，则即使kube-proxy的配置开启了ipvs模式，也会退回到iptables模式。  </p>
<h3 id="1-3-安装docker"><a href="#1-3-安装docker" class="headerlink" title="1.3 安装docker"></a>1.3 安装docker</h3><p>安装docker的yum源:（已安装过且版本匹配的可以跳过）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>查看最新的Docker版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list docker-ce.x86_64  --showduplicates |sort -r</span><br><span class="line"></span><br><span class="line">docker-ce.x86_64            3:18.09.7-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.7-3.el7                    @docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.6-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.5-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.4-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.3-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.2-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.1-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.0-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.3.ce-3.el7                   docker-ce-stable</span><br></pre></td></tr></table></figure>
<p>Kubernetes 1.15当前支持的docker版本列表是1.13.1, 17.03, 17.06, 17.09, 18.06, 18.09。 这里在各节点安装docker的18.09.7版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">yum install -y --setopt=obsoletes=0 \</span><br><span class="line">  docker-ce-18.09.7-3.el7 </span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
<p>确认一下iptables filter表中FOWARD链的默认策略(pllicy)为ACCEPT。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -nvL</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 263 packets, 19209 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">    0     0 DOCKER-USER  all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line">    0     0 DOCKER-ISOLATION-STAGE-1  all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line">    0     0 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">    0     0 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">    0     0 ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">    0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>
<p><strong>如果有不匹配的，请使用 iptables -P FORWARD ACCEPT 修改过来</strong></p>
<h3 id="1-4-修改docker-cgroup-driver为systemd"><a href="#1-4-修改docker-cgroup-driver为systemd" class="headerlink" title="1.4 修改docker cgroup driver为systemd"></a>1.4 修改docker cgroup driver为systemd</h3><p>根据文档<a href="https://note.youdao.com/" target="_blank" rel="noopener">CRI installation</a>中的内容，对于使用systemd作为init system的Linux的发行版，使用systemd作为docker的cgroup driver可以确保服务器节点在资源紧张的情况更加稳定，因此这里修改各个节点上docker的cgroup driver为systemd。</p>
<p><strong>创建或修改/etc/docker/daemon.json(这里很重要，错了就有坑)</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p>
<p><strong>重启docker并设置开机启动（没有设置开机启动初始化时会失败）</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">docker info | grep Cgroup</span><br><span class="line">Cgroup Driver: systemd</span><br></pre></td></tr></table></figure>
<h2 id="2-使用kubeadm部署kubernetes"><a href="#2-使用kubeadm部署kubernetes" class="headerlink" title="2 使用kubeadm部署kubernetes"></a>2 使用kubeadm部署kubernetes</h2><h3 id="2-1-安装kubeadm和kubelet"><a href="#2-1-安装kubeadm和kubelet" class="headerlink" title="2.1 安装kubeadm和kubelet"></a>2.1 安装kubeadm和kubelet</h3><p>下面在各节点安装kubeadm和kubelet，这里涉及访问google，<strong>需要科学上网。</strong>（我试着找过阿里云镜像地址，但是并不能用……..）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg</span><br><span class="line">        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>执行如下指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line">... </span><br><span class="line">已安装:</span><br><span class="line">  kubeadm.x86_64 0:1.15.0-0   kubectl.x86_64 0:1.15.0-0   kubelet.x86_64 0:1.15.0-0  </span><br><span class="line"></span><br><span class="line">作为依赖被安装:</span><br><span class="line">  cri-tools.x86_64 0:1.13.0-0              kubernetes-cni.x86_64 0:0.7.5-0             </span><br><span class="line"></span><br><span class="line">完毕！</span><br></pre></td></tr></table></figure>
<p>从安装结果可以看出还安装了cri-tools, kubernetes-cni的依赖</p>
<p>Kubernetes 1.8开始要求关闭系统的Swap，如果不关闭，默认配置下kubelet将无法启动。 关闭系统的Swap方法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>
<p>修改 /etc/fstab 文件，注释掉 SWAP 的自动挂载，使用free -m确认swap已经关闭。 swappiness参数调整，修改/etc/sysctl.d/k8s.conf添加下面一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.swappiness=0</span><br></pre></td></tr></table></figure>
<p><strong>执行sysctl -p /etc/sysctl.d/k8s.conf使修改生效</strong>。<br>因为这里本次用于测试两台主机上还运行其他服务，关闭swap可能会对其他服务产生影响，所以这里修改kubelet的配置去掉这个限制。 使用kubelet的启动参数–fail-swap-on=false去掉必须关闭Swap的限制，修改/etc/sysconfig/kubelet，加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KUBELET_EXTRA_ARGS=--fail-swap-on=false</span><br></pre></td></tr></table></figure>
<h3 id="2-2-使用kubeadm-init初始化集群"><a href="#2-2-使用kubeadm-init初始化集群" class="headerlink" title="2.2 使用kubeadm init初始化集群"></a>2.2 使用kubeadm init初始化集群</h3><p>在各节点开机启动kubelet服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable kubelet.service</span><br></pre></td></tr></table></figure>
<p>使用kubeadm config print init-defaults可以打印集群初始化默认的使用的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 1.2.3.4</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: /var/run/dockershim.sock</span><br><span class="line">  name: localhost.localdomain</span><br><span class="line">  taints:</span><br><span class="line">  - effect: NoSchedule</span><br><span class="line">    key: node-role.kubernetes.io/master</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns:</span><br><span class="line">  type: CoreDNS</span><br><span class="line">etcd:</span><br><span class="line">  local:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: k8s.gcr.io</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.14.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">scheduler: &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>从默认的配置中可以看到，可以使用imageRepository定制在集群初始化时拉取k8s所需镜像的地址。基于默认配置定制出本次使用kubeadm初始化集群所需的配置文件kubeadm.yaml(新建，任意位置下都行，advertiseAddress改成你的ip即可)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.110.128</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  taints:</span><br><span class="line">  - effect: PreferNoSchedule</span><br><span class="line">    key: node-role.kubernetes.io/master</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.15.0</span><br><span class="line">networking:</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br></pre></td></tr></table></figure>
<p>在开始初始化集群之前可以使用kubeadm config images pull预先在各个节点上拉取所k8s需要的docker镜像。</p>
<p>接下来使用kubeadm初始化集群，选择node1作为Master Node，在node1上执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm init --config kubeadm.yaml --ignore-preflight-errors=Swap,NumCPU</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">[init] Using Kubernetes version: v1.15.0</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">	[WARNING NumCPU]: the number of available CPUs 1 is less than the required 2</span><br><span class="line">	[WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &apos;kubeadm config images pull&apos;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[certs] Generating &quot;front-proxy-ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/server&quot; certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [localhost.localdomain localhost] and IPs [192.168.110.128 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/peer&quot; certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [localhost.localdomain localhost] and IPs [192.168.110.128 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [localhost.localdomain kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.110.128]</span><br><span class="line">[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;sa&quot; key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 22.501928 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config-1.15&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node localhost.localdomain as control-plane by adding the label &quot;node-role.kubernetes.io/master=&apos;&apos;&quot;</span><br><span class="line">[mark-control-plane] Marking the node localhost.localdomain as control-plane by adding the taints [node-role.kubernetes.io/master:PreferNoSchedule]</span><br><span class="line">[bootstrap-token] Using token: fbd9w8.6j1yjer52w2po3q4</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.110.130:6443 --token luxlja.y8td78jdh7immmfd \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:ab640c9f8a8497c23bb91454e4734a6642aaa3c6b622c0158a94a8b5ab29bb85</span><br></pre></td></tr></table></figure>
<p>运行该指令时，kubernetes会检查环境是否符合要求，诸如cpu核心数不能小于2，我这里的虚拟机只分配了一个核心，所以–ignore-preflight-errors中加上了NumCPU忽略掉了，否则会启动不成功。<br>上面记录了完成的初始化输出的内容，根据输出的内容基本上可以看出手动初始化安装一个Kubernetes集群所需要的关键步骤。 其中有以下关键内容：</p>
<ul>
<li>[kubelet-start] 生成kubelet的配置文件”/var/lib/kubelet/config.yaml”</li>
<li>[certs]生成相关的各种证书</li>
<li>[kubeconfig]生成相关的kubeconfig文件</li>
<li>[control-plane]使用/etc/kubernetes/manifests目录中的yaml文件创建apiserver、controller-manager、scheduler的静态pod</li>
<li>[bootstraptoken]生成token记录下来，后边使用kubeadm join往集群中添加节点时会用到</li>
<li><p>下面的命令是配置常规用户如何使用kubectl访问集群：<strong>（这里必须执行，master和worker都需要）</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后给出了将节点加入集群的命令</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.110.130:6443 --token luxlja.y8td78jdh7immmfd \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:ab640c9f8a8497c23bb91454e4734a6642aaa3c6b622c0158a94a8b5ab29bb85</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>查看一下集群状态，确认个组件都处于healthy状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get cs</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">NAME                 STATUS    MESSAGE             ERROR</span><br><span class="line">controller-manager   Healthy   ok                  </span><br><span class="line">scheduler            Healthy   ok                  </span><br><span class="line">etcd-0               Healthy   &#123;&quot;health&quot;:&quot;true&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>集群初始化如果遇到问题，可以使用下面的命令进行清理：(没问题的直接跳过)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm reset</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">rm -rf /var/lib/cni/</span><br></pre></td></tr></table></figure>
<h3 id="2-3-安装Pod-Network"><a href="#2-3-安装Pod-Network" class="headerlink" title="2.3 安装Pod Network"></a>2.3 安装Pod Network</h3><p>接下来安装flannel network add-on：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/k8s/</span><br><span class="line">cd ~/k8s</span><br><span class="line">curl -O https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">kubectl apply -f  kube-flannel.yml</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-amd64 created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-arm64 created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-arm created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-ppc64le created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-s390x created</span><br></pre></td></tr></table></figure>
<p>如果Node有多个网卡的话,需要修改kube-flannel.yml，为flanneld启动参数加上 <code>–-iface=&lt;iface-name&gt;</code><br>（kubectl apply -f  kube-flannel.yml对应安装flannel，同样的，如果安装出现问题需要重装，请使用kubectl delete -f  kube-flannel.yml删除后再尝试。）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">containers:</span><br><span class="line">      - name: kube-flannel</span><br><span class="line">        image: quay.io/coreos/flannel:v0.11.0-amd64</span><br><span class="line">        command:</span><br><span class="line">        - /opt/bin/flanneld</span><br><span class="line">        args:</span><br><span class="line">        - --ip-masq</span><br><span class="line">        - --kube-subnet-mgr</span><br><span class="line">        - --iface=ens33</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>检查master状态为Ready  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">NAME                    STATUS   ROLES    AGE   VERSION</span><br><span class="line">localhost.localdomain   Ready    master   75m   v1.15.0</span><br></pre></td></tr></table></figure>
<p>使用kubectl get pod –all-namespaces -o wide确保所有的Pod都处于Running状态。<br>(如果有其它状态的，请检查selinux关闭后需要重启)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kube-system</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">NAME                                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-5c98db65d4-f9jrh                        1/1     Running   0          79m</span><br><span class="line">coredns-5c98db65d4-w6cpx                        1/1     Running   0          79m</span><br><span class="line">etcd-localhost.localdomain                      1/1     Running   1          78m</span><br><span class="line">kube-apiserver-localhost.localdomain            1/1     Running   1          78m</span><br><span class="line">kube-controller-manager-localhost.localdomain   1/1     Running   1          78m</span><br><span class="line">kube-flannel-ds-amd64-dqv67                     1/1     Running   0          20m</span><br><span class="line">kube-proxy-c7cwv                                1/1     Running   1          79m</span><br><span class="line">kube-scheduler-localhost.localdomain            1/1     Running   1          78m</span><br></pre></td></tr></table></figure>
<h3 id="2-4-测试集群DNS是否可用"><a href="#2-4-测试集群DNS是否可用" class="headerlink" title="2.4 测试集群DNS是否可用"></a>2.4 测试集群DNS是否可用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl run curl --image=radial/busyboxplus:curl -it</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">kubectl run --generator=deployment/apps.v1beta1 is DEPRECATED and will be removed in a future version. Use kubectl create instead.</span><br><span class="line">If you don&apos;t see a command prompt, try pressing enter.</span><br><span class="line">[ root@curl-5cc7b478b6-r997p:/ ]$</span><br></pre></td></tr></table></figure>
<p>上述命令就是进入容器的意思，如果命令卡住了，尝试docker exec 该镜像也可以看到效果。进入容器后执行nslookup kubernetes.default确认解析正常:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nslookup kubernetes.default</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      kubernetes.default</span><br><span class="line">Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local</span><br></pre></td></tr></table></figure>
<h3 id="2-5-向Kubernetes集群中添加Node节点"><a href="#2-5-向Kubernetes集群中添加Node节点" class="headerlink" title="2.5 向Kubernetes集群中添加Node节点"></a>2.5 向Kubernetes集群中添加Node节点</h3><p>下面将node2这个主机添加到Kubernetes集群中（node2不需要执行kubeadm init），在node2上执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.110.130:6443 --token luxlja.y8td78jdh7immmfd \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:ab640c9f8a8497c23bb91454e4734a6642aaa3c6b622c0158a94a8b5ab29bb85</span><br></pre></td></tr></table></figure>
<p>随后在node1节点上运行kubectl get nodes即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">NAME    STATUS   ROLES    AGE     VERSION</span><br><span class="line">node1   Ready    master   4m36s   v1.15.0</span><br><span class="line">node2   Ready    &lt;none&gt;   69s     v1.15.0</span><br></pre></td></tr></table></figure>
<h3 id="2-6-kube-proxy开启ipvs"><a href="#2-6-kube-proxy开启ipvs" class="headerlink" title="2.6 kube-proxy开启ipvs"></a>2.6 kube-proxy开启ipvs</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl edit cm kube-proxy -n kube-system</span><br></pre></td></tr></table></figure>
<p>找到如下部分的配置内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">metricsBindAddress: 127.0.0.1:10249</span><br><span class="line">mode: &quot;ipvs&quot;                             #默认是空的，修改为ipvs</span><br><span class="line">nodePortAddresses: null</span><br><span class="line">oomScoreAdj: -999</span><br><span class="line">portRange: &quot;&quot;</span><br><span class="line">resourceContainer: /kube-proxy</span><br></pre></td></tr></table></figure>
<p>运行如下指令，会将之前的kube-proxy pod删除然后重新创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kube-system | grep kube-proxy | awk &apos;&#123;system(&quot;kubectl delete pod &quot;$1&quot; -n kube-system&quot;)&#125;&apos;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">pod &quot;kube-proxy-8xv5x&quot; deleted</span><br><span class="line">pod &quot;kube-proxy-skcbw&quot; deleted</span><br></pre></td></tr></table></figure>
<p>查看新创建的kube-proxy：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kube-system | grep kube-proxy</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">kube-proxy-7fsrg                1/1     Running   0          3s</span><br><span class="line">kube-proxy-k8vhm                1/1     Running   0          9s</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl logs kube-proxy-7fsrg  -n kube-system</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">I0703 04:42:33.308289       1 server_others.go:170] Using ipvs Proxier.</span><br><span class="line">W0703 04:42:33.309074       1 proxier.go:401] IPVS scheduler not specified, use rr by default</span><br><span class="line">I0703 04:42:33.309831       1 server.go:534] Version: v1.15.0</span><br><span class="line">I0703 04:42:33.320088       1 conntrack.go:52] Setting nf_conntrack_max to 131072</span><br><span class="line">I0703 04:42:33.320365       1 config.go:96] Starting endpoints config controller</span><br><span class="line">I0703 04:42:33.320393       1 controller_utils.go:1029] Waiting for caches to sync for endpoints config controller</span><br><span class="line">I0703 04:42:33.320455       1 config.go:187] Starting service config controller</span><br><span class="line">I0703 04:42:33.320470       1 controller_utils.go:1029] Waiting for caches to sync for service config controller</span><br><span class="line">I0703 04:42:33.420899       1 controller_utils.go:1036] Caches are synced for endpoints config controller</span><br><span class="line">I0703 04:42:33.420969       1 controller_utils.go:1036] Caches are synced for service config controller</span><br></pre></td></tr></table></figure>
<p>日志中打印出了Using ipvs Proxier，说明ipvs模式已经开启。</p>
<h3 id="3-移除节点"><a href="#3-移除节点" class="headerlink" title="3.移除节点"></a>3.移除节点</h3><p>如果需要从集群中移除node2这个Node执行下面的命令：</p>
<p>在master节点上执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl drain node2 --delete-local-data --force --ignore-daemonsets</span><br><span class="line">kubectl delete node node2</span><br></pre></td></tr></table></figure>
<p>在node2上执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm reset</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">rm -rf /var/lib/cni/</span><br></pre></td></tr></table></figure>
<p>在node1上执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete node node2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>常用设计模式---单例模式</title>
    <url>/2019/04/14/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例模式简单介绍"><a href="#单例模式简单介绍" class="headerlink" title="单例模式简单介绍"></a>单例模式简单介绍</h2><p>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类成为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
<h2 id="单例模式需要注意事项"><a href="#单例模式需要注意事项" class="headerlink" title="单例模式需要注意事项"></a>单例模式需要注意事项</h2><p>1.单例类的构造函数私有<br>2.提供一个自身的静态私有成员变量<br>3.提供一个公有的静态工厂方法<br><a id="more"></a></p>
<h2 id="模式结构图"><a href="#模式结构图" class="headerlink" title="模式结构图"></a>模式结构图</h2><p><img src="/images/19-4-14.png" alt="Alt"></p>
<h2 id="单例模式实例"><a href="#单例模式实例" class="headerlink" title="单例模式实例"></a>单例模式实例</h2><p>这里模拟实现一个居民身份证唯一的单例场景。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例类如下</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">IdCardNo</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    private <span class="keyword">static</span> IdCardNo instance = <span class="literal">null</span>;  </span><br><span class="line">    private <span class="built_in">String</span> no;  </span><br><span class="line">  </span><br><span class="line">    private IdCardNo() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public <span class="keyword">static</span> IdCardNo getInstance() &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> IdCardNo();  </span><br><span class="line">            instance.setNo(<span class="string">"No5000011113333"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public <span class="built_in">String</span> getNo() &#123;  </span><br><span class="line">        <span class="keyword">return</span> no;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    private <span class="keyword">void</span> setNo(<span class="built_in">String</span> no) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.no = no;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="单例的多种写法"><a href="#单例的多种写法" class="headerlink" title="单例的多种写法"></a>单例的多种写法</h2><p>上述场景中使用的是懒汉式写法，单例模式还有如下的几种写法<br><strong>饿汉式：</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    private <span class="keyword">static</span> EagerSingleton instance = <span class="keyword">new</span> EagerSingleton();  </span><br><span class="line">  </span><br><span class="line">    private EagerSingleton() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public <span class="keyword">static</span> EagerSingleton getInstance() &#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>饿汉式的写法可以保证<strong>线程安全</strong>，但从资源利用率角度来考虑，比懒汉式写法稍差。但懒汉式存在线程安全问题，所以接下来考虑多个线程同时<strong>首次</strong>引用单例的访问限制问题。<br><strong>双重检测的单例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//volatile禁止指令重排序，保证可见性  </span></span><br><span class="line">  private <span class="keyword">static</span> volatile Singleton instance;  </span><br><span class="line">  </span><br><span class="line">    private Singleton() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public <span class="keyword">static</span> Singleton getInstance() &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            synchronized (Singleton.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检测虽然解决了多线程的访问限制问题，但这个写法看起来着实不美观。那么我们还有没有别的写法呢？答案是有的。<br><strong>基于枚举的方式：</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public enum SingletonEnum &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    private Singleton instance = <span class="literal">null</span>;  </span><br><span class="line">  </span><br><span class="line">    private SingletonEnum() &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public Singleton getInstance() &#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单元素的枚举类<strong>可以保证单例的线程安全、序列化</strong>，除单元素枚举外，还有使用 <code>java</code> 内部类实现的方式。<br><strong>基于内部类实现单例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    private Singleton() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    private <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHandler</span> </span>&#123;  </span><br><span class="line">        private <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public <span class="keyword">static</span> Singleton getInstance() &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHandler.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    private <span class="built_in">Object</span> readResolve()&#123;  </span><br><span class="line">        System.out.println(<span class="string">"read resolve"</span>);  </span><br><span class="line">        <span class="keyword">return</span> SingletonHandler.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException, ClassNotFoundException &#123;  </span><br><span class="line">        Singleton instance = Singleton.getInstance();  </span><br><span class="line">  </span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"ser.out"</span>);  </span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));  </span><br><span class="line">        oos.writeObject(instance);  </span><br><span class="line">        oos.close();  </span><br><span class="line">  </span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));  </span><br><span class="line">        Singleton oIstance = (Singleton)ois.readObject();  </span><br><span class="line">        ois.close();  </span><br><span class="line">        System.out.println(oIstance == instance);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用静态内部类的优点是：<table><tr><td bgcolor="#D1EEEE">外部类加载时并不需要立即加载内部类，即当 <code>Singletonle</code> 被加载时，并不需要去加载 <code>SingletonHandler</code>，只有当 <code>getInstance()</code> 方法第一次被调用时，才会去初始化 <code>SingletonHandler</code>,同时初始化该类的静态变量 <code>instance</code> ,在确保线程安全的同时也延迟了单例的实例化.</td></tr></table></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个类模板，在整个系统中只允许产生一个实例叫做单例。单例有多种写法：懒汉式、饿汉式、双重检查、枚举、内部类。</p>
<ul>
<li>饿汉式不管用不用先创建出来，保证线程安全。</li>
<li>懒汉式延迟加载，有效利用资源不保证线程安全。</li>
<li>双重检测方式保证了懒汉式的线程安全问题。</li>
<li>单元素枚举可以同时保证线程安全和序列化。</li>
<li>内部类使用了 <code>jvm</code> 的类加载机制来保证线程安全和懒加载。</li>
<li>序列化和反序列化保证单例需要重写类的 <code>readResolve()</code> 方法</li>
</ul>
]]></content>
      <categories>
        <category>深入java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>我的live2d配置</title>
    <url>/2019/04/27/%E6%88%91%E7%9A%84live2d%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>给<code>hexo</code>加上<code>live2d</code>只能说是自己作为死宅的本能反应吧= =，在别人的网站上看过之后总是觉得羨ましい，然后到处找文章想给自己也加上，本来很简单的事情还用了大半天( <code>I very vegetables</code> )，这次把步骤写上来。也算做个备份吧，指不定那天忘了呢。</p>
<h3 id="hexo的官方插件"><a href="#hexo的官方插件" class="headerlink" title="hexo的官方插件"></a>hexo的官方插件</h3><p><code>hexo</code> 的官方有提供名为 <code>hexo-helper-live2d</code> 的插件使用如下安装命令就可以安装</p>
<blockquote>
<p>npm install –save hexo-helper-live2d</p>
</blockquote>
<p>随后在 <code>Hexo</code> 的 <code>_config.yml</code> 文件中添加如下配置(据说是可以配在主题的 <code>_config.yml</code> 中的，但是我没试过<code>orz</code>).<br>示例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line"> enable: <span class="literal">true</span>   </span><br><span class="line"> scriptFrom: local</span><br><span class="line"> pluginRootPath: live2dw/</span><br><span class="line"> pluginJsPath: lib/</span><br><span class="line"> pluginModelPath: assets/</span><br><span class="line"> tagMode: <span class="literal">false</span></span><br><span class="line"> debug: <span class="literal">false</span></span><br><span class="line"> model:</span><br><span class="line">   use: live2d-widget-model-wanko  <span class="comment">//启用的模型目录</span></span><br><span class="line"> display:</span><br><span class="line">   position: right</span><br><span class="line">   width: <span class="number">150</span></span><br><span class="line">   height: <span class="number">300</span></span><br><span class="line"> mobile:</span><br><span class="line">   show: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p> 这样一个默认的模型就配好了，默认是这样的:<br> <img src="/images/hexo-live2d-default.png" alt="hexo-default"></p>
<h3 id="添加互动："><a href="#添加互动：" class="headerlink" title="添加互动："></a>添加互动：</h3><p>默认的模型只有很简单的动画，在别人网站里看到的都是能互动对话的，经过查阅找到了大佬的教程<a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">把萌萌哒的看板娘抱回家</a>。  (到这里需要把之前配置文件中的 <code>live2d.enable</code> 修改为 <code>false</code> )<br>根据步骤来，<code>jquery</code>在主题中是已经存在的直接跳过，将项目下载下来，将<code>autoload.js</code>、 <code>live2d.min.js</code>、<code>waifu-tips.js</code>、<code>waifu-tips.json</code>、<code>waifu.css</code>这几个文件放入到<code>next</code>主题中<code>/source/js/src</code>目录下，也可以将<code>json</code>和<code>css</code>文件放到对于的目录下，但是需要改动下<code>autoload</code>中的路径，我这里偷懒直接放到一起了orz</p>
<pre><code>&lt;script src=&quot;/js/src/autoload.js&quot;&gt;&lt;/script&gt;
</code></pre><p>将上面这句放入到主题的<code>/layout/_layout.swing</code>中<code>body</code>标签的末尾，<code>autoload.js</code>的内容如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始加斜杠和不加是完全不同的路径,这里改为了我放置的相对路径</span></span><br><span class="line"><span class="keyword">const</span> live2d_path = <span class="string">"/js/src/"</span>;</span><br><span class="line"><span class="comment">//const live2d_path = "./";</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">"&lt;link&gt;"</span>).attr(&#123;<span class="attr">href</span>: live2d_path + <span class="string">"waifu.css"</span>, <span class="attr">rel</span>: <span class="string">"stylesheet"</span>, <span class="attr">type</span>: <span class="string">"text/css"</span>&#125;).appendTo(<span class="string">"head"</span>);</span><br><span class="line"><span class="comment">//waifu.css的绝对路径</span></span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">	url: live2d_path + <span class="string">"live2d.min.js"</span>,</span><br><span class="line">	dataType: <span class="string">"script"</span>,</span><br><span class="line">	cache: <span class="literal">true</span>,</span><br><span class="line">	<span class="keyword">async</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//live2d.min.js的绝对路径</span></span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">	url: live2d_path + <span class="string">"waifu-tips.js"</span>,</span><br><span class="line">	dataType: <span class="string">"script"</span>,</span><br><span class="line">	cache: <span class="literal">true</span>,</span><br><span class="line">	<span class="keyword">async</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//waifu-tips.js的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化看板娘，会自动加载指定目录下的waifu-tips.json</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	initWidget(live2d_path + <span class="string">"waifu-tips.json"</span>, <span class="string">"https://live2d.fghrsh.net/api"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//initWidget第一个参数为waifu-tips.json的绝对路径</span></span><br><span class="line"><span class="comment">//第二个参数为api地址（无需修改）</span></span><br><span class="line"><span class="comment">//api后端可自行搭建，参考https://github.com/fghrsh/live2d_api</span></span><br></pre></td></tr></table></figure></p>
<p>然后打开<code>waifu-tips.js</code>，在方法<code>initWidget</code>中将下面这句话移到方法的最前面，这样可以在关闭<code>live2d</code>后，刷新时重新加载。</p>
<pre><code>localStorage.removeItem(&quot;waifu-display&quot;);
</code></pre><h3 id="添加拖动"><a href="#添加拖动" class="headerlink" title="添加拖动"></a>添加拖动</h3><p>上述操作完成之后却发现一个问题，模型位置是固定的，不能拖动 - -。进一步了解之后，自定义的编写了如下的拖动方法(放在了<code>waifu-tips.js</code>中)<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    绘制图片坐标</span></span><br><span class="line">    <span class="keyword">var</span> X=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> Y=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//    js部分</span></span><br><span class="line">    <span class="keyword">var</span> divObj=<span class="built_in">document</span>.getElementById(<span class="string">"waifu"</span>);</span><br><span class="line">    <span class="keyword">var</span> moveFlag=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//区别moueseup与click的标志</span></span><br><span class="line">    <span class="keyword">var</span> clickFlag=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//    拖拽函数</span></span><br><span class="line">    divObj.onmousedown=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        moveFlag=<span class="literal">true</span>;</span><br><span class="line">        clickFlag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">var</span> clickEvent=<span class="built_in">window</span>.event||e;</span><br><span class="line">        <span class="keyword">var</span> mwidth=clickEvent.clientX-divObj.offsetLeft;</span><br><span class="line">        <span class="keyword">var</span> mheight=clickEvent.clientY-divObj.offsetTop;</span><br><span class="line">        <span class="built_in">document</span>.onmousemove=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            clickFlag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">var</span> moveEvent=<span class="built_in">window</span>.event||e;</span><br><span class="line">            <span class="keyword">if</span>(moveFlag)&#123;</span><br><span class="line">                divObj.style.left=moveEvent.clientX-mwidth+<span class="string">"px"</span>;</span><br><span class="line">                divObj.style.top=moveEvent.clientY-mheight+<span class="string">"px"</span>;</span><br><span class="line"><span class="comment">////              将鼠标坐标传给Canvas中的图像</span></span><br><span class="line">                X=moveEvent.clientX-mwidth;</span><br><span class="line">                Y=moveEvent.clientY-mheight;</span><br><span class="line"><span class="comment">////              下面四个条件为限制div以及图像的活动边界</span></span><br><span class="line">                <span class="keyword">if</span>(moveEvent.clientX&lt;=mwidth)&#123;</span><br><span class="line">                    divObj.style.left=<span class="number">0</span>+<span class="string">"px"</span>;</span><br><span class="line">                    X=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">parseInt</span>(divObj.style.left)+divObj.offsetWidth &gt;=innerWidth)&#123;</span><br><span class="line">                    divObj.style.left=innerWidth - divObj.offsetWidth+<span class="string">"px"</span>;</span><br><span class="line">                    X=innerWidth - divObj.offsetWidth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(moveEvent.clientY&lt;=mheight)&#123;</span><br><span class="line">                    divObj.style.top=<span class="number">0</span>+<span class="string">"px"</span>;</span><br><span class="line">                    Y=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">parseInt</span>(divObj.style.top)+divObj.offsetHeight&gt;=innerHeight)&#123;</span><br><span class="line">                    divObj.style.top=innerHeight-divObj.offsetHeight+<span class="string">"px"</span>;</span><br><span class="line">                    Y=innerHeight-divObj.offsetHeight;</span><br><span class="line">                &#125;</span><br><span class="line">                divObj.onmouseup=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    moveFlag=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>整个过程就是这样了，以上です～(｡-_-｡)。<br>tips：</p>
<blockquote>
<p>在<code>waifu-tips.js</code>中<code>waifu-tool</code>里有几个写好的模块，可以自定义添加或删除，每个<code>span</code>对应一个功能<br><code>initmodel</code>方法里有默认的加载模型，可以将随机更换注释掉，选择喜欢的固定模型<br><code>waifu-tips.json</code>中包含了触发条件（选择器的事件）和触发时显示的文字，也可以自定义</p>
</blockquote>
]]></content>
      <categories>
        <category>另一个次元</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列总结</title>
    <url>/2021/07/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-消息队列的应用场景："><a href="#1-消息队列的应用场景：" class="headerlink" title="1.消息队列的应用场景："></a>1.消息队列的应用场景：</h2><ul>
<li>解耦：将不同的系统之间解耦开来，比如说我有一个上游的订单系统，订单完成之后，我需要操作 <code>A</code>库存系统、<code>B</code>用户系统 来进行扣库存、增加会员积分等等操作。现在 <code>A,B</code> 子系统都需要来对接我的执行结果。不解耦的话，需要在订单的代码里编码来执行。如果 <code>A,B</code> 发生需求变更的话就会改动订单系统的代码。而使用消息队列之后，就不需要关心下游系统的具体逻辑了，由 <code>A,B</code> 自行通过订阅的方式来进行逻辑处理。</li>
<li>异步：（事件驱动）同步执行流程时间长，或者说用户并不关心邮件发送成不成功，只要购买成功就可以了。</li>
<li>削峰（限流）：这个只有在大并发场景才会用到，如果我的请求非常多，那么我可能会把请求先放到消息队列中，去排一下队，避免把应用直接压垮。这里其实会牵扯到有关联性其它问题，比如说：<a id="more"></a><ul>
<li>如何设计一个秒杀系统</li>
<li><code>ELK</code> 架构中为什么不直接从 <code>logstash —&gt; Elasticsearch</code>  而是要  <code>Logstash —&gt; Kafka —&gt; Elasticsearch</code></li>
</ul>
</li>
</ul>
<h3 id="消息队列总览图"><a href="#消息队列总览图" class="headerlink" title="消息队列总览图"></a>消息队列总览图</h3><p><img src="https://z3.ax1x.com/2021/07/22/W0bC2n.png" alt></p>
<p>## </p>
<h2 id="2-消息队列重难点："><a href="#2-消息队列重难点：" class="headerlink" title="2.消息队列重难点："></a>2.消息队列重难点：</h2><h3 id="如何保证生产者只发送一次"><a href="#如何保证生产者只发送一次" class="headerlink" title="如何保证生产者只发送一次"></a>如何保证生产者只发送一次</h3><p>这个问题其实很难做到，或者说没办法做到，在分析问题前可以拆解为两个小问题：</p>
<ul>
<li>如何保证消息一定发出去了？</li>
<li>如何保证只发了一次？</li>
</ul>
<p>对于第一点，可以使用重试或者使用分布式事务（分布式事务本身又是一个大坑），重试超过一定次数，需要考虑人手工介入。</p>
<p>对于第二点，通常是不限制生产者的发送次数，在消费端通过幂等来解决。</p>
<h3 id="如何保证消费者一定消费成功"><a href="#如何保证消费者一定消费成功" class="headerlink" title="如何保证消费者一定消费成功"></a>如何保证消费者一定消费成功</h3><p>重试 + <code>ACK</code> 机制，消费成功后，发送 <code>ACK</code> 进行确认。</p>
<h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><ul>
<li>至多一次，消息至多只消费一次，有可能没有消费成功，适用于日志类型的数据允许丢失的场景</li>
<li>至少一次，消息最少也会消费一次，存在重复消费的可能，需根据业务情况考虑，是否需要做幂等操作</li>
<li><p>恰好一次，最严苛的语义，不多不少执行一次。这个其实挺难保证的，需要业务来进行辅助解决</p>
</li>
<li><p>超时、重试、幂等</p>
</li>
</ul>
<p>通常情况下的应用中，<code>80%+</code> 的消息数据都会是恰好发送一次，恰好也被消费一次的状态。</p>
<h3 id="重复消费的场景："><a href="#重复消费的场景：" class="headerlink" title="重复消费的场景："></a>重复消费的场景：</h3><ul>
<li><p>从生产者到消息中间件之间，生产者可能重复发送。例如生产者发送过程中出现超时，因此生产者不确定自己是否发出去了，重试</p>
</li>
<li><p>消息中间件到消费者，也可能超时。即消息中间件不知道消费者消费消息了没有，那么重试就会引起重复消费，这里又分为两种子情况：</p>
<ul>
<li>消息传输到消费者的时候超时</li>
<li>消费后，进行 <code>ACK</code> 确认时超时</li>
</ul>
</li>
</ul>
<p><span style="color:red">而解决重复消费问题的方案就是保证幂等。</span>（当然有些场景下的数据重复消费并不会造成影响，可以不用处理）</p>
<h2 id="3-如何解决幂等"><a href="#3-如何解决幂等" class="headerlink" title="3.如何解决幂等"></a>3.如何解决幂等</h2><ul>
<li>根据消息内容的业务特征去重，例如根据 <code>id</code> 去重。<ul>
<li>去重方式可以选择数据库唯一索引或者 <code>Redis</code> ，这种方案属于先检查数据库是否唯一索引冲突，或者<code>Redis</code> 是否存在某个 <code>key</code> （<code>check +do something</code>）</li>
<li>延伸问题：如果使用 <code>check + dosomething</code> 会有几率出现并发问题。检查之前没有，检查之后出现了该 <code>key</code> 值。</li>
</ul>
</li>
</ul>
<h2 id="4-消息顺序问题"><a href="#4-消息顺序问题" class="headerlink" title="4.消息顺序问题"></a>4.消息顺序问题</h2><p><span style="color:red">通常来说，用了 mq 就不太会要求顺序，或者说只会要求局部有序</span></p>
<ul>
<li>从本质上来说，队列本身就是有序的，消息的顺序需要生产者、消费者互相来保证，中间件并没有所谓的重排序机制。</li>
<li><strong>生产者需要控制逻辑，A 成功之后才能发送 B </strong></li>
<li>消费者则不相同，一般来说，<code>mq</code> 中有一个 <code>offset</code> 机制，如果我消费失败了，我不发送 <code>ack</code> 确认的话，是不会消费下一条消息的</li>
<li>而对于中间件本身来说，由于一个 <code>topic</code> 或者说 <code>queue</code> 会分为多个 <code>partition</code> 分区，中间件只能保证某个分区的顺序，想要做到严格的顺序要求其实不适合使用中间件！！！！！。做同步处理他不香吗。</li>
</ul>
<h2 id="5-消息积压问题"><a href="#5-消息积压问题" class="headerlink" title="5.消息积压问题"></a>5.消息积压问题</h2><p>本质问题：生产者和消费者的效率不一致，消费者效率太慢，解决方法可以从两个方面来考虑：</p>
<ul>
<li>限制生产者速率（一般不会）</li>
<li>提高消费者的效率<ul>
<li>提高单条消费的效率</li>
<li>增加消费者数量</li>
<li>使用线程池来消费 <code>partition</code>，消费者组 <code>Group</code>，</li>
</ul>
</li>
</ul>
<p>除此之外，积压其实还得考虑是突然的积压（偶发，增加集群规模，先把东西保存下来，慢慢的都会消费完），还是业务增长而缓慢导致的不断积压（增加消费规模，说明容量预估就不正确，）</p>
<h2 id="6-如何实现延时消息"><a href="#6-如何实现延时消息" class="headerlink" title="6.如何实现延时消息"></a>6.如何实现延时消息</h2><ul>
<li>中间件是否支持延时<ul>
<li>（生产方投递到延时队列里）然后通过定时任务扫描，时间一到，定时发送</li>
<li>先发送到一个特殊队列，消费者先存储下来。等待一段时间，然后发送到真正的主题中。</li>
</ul>
</li>
<li>业务方程序控制</li>
<li>消费者程序控制</li>
</ul>
<h2 id="7-数据推送模式："><a href="#7-数据推送模式：" class="headerlink" title="7.数据推送模式："></a>7.数据推送模式：</h2><ul>
<li>推：服务端主动推，服务端压力大</li>
<li>拉：客户端主动拉，不够实时</li>
</ul>
<h2 id="8-消息队列的缺点（反直觉问题）"><a href="#8-消息队列的缺点（反直觉问题）" class="headerlink" title="8.消息队列的缺点（反直觉问题）"></a>8.消息队列的缺点（反直觉问题）</h2><ul>
<li>增加了系统复杂性</li>
<li>可用性降低</li>
<li>一致性难保证</li>
<li>升华主题：所有的中间件引入都会引入类似的问题</li>
</ul>
<h2 id="9-如何选择消息队列"><a href="#9-如何选择消息队列" class="headerlink" title="9.如何选择消息队列"></a>9.如何选择消息队列</h2><ul>
<li><code>trade off</code> 问题 ，需要看业务场景来考虑</li>
<li><p>看技术积累深度，团队内部的人员掌握程度如何</p>
</li>
<li><p>看维护难度、看社区成熟度。是否容易找到问题</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟题记录</title>
    <url>/2021/05/29/%E6%A8%A1%E6%8B%9F%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="分片分配"><a href="#分片分配" class="headerlink" title="分片分配"></a>分片分配</h2><h3 id="案例1：将索引-A-所有-shards-分配到-node1-索引-B-的所有-shards-分配到-node2-、-node3"><a href="#案例1：将索引-A-所有-shards-分配到-node1-索引-B-的所有-shards-分配到-node2-、-node3" class="headerlink" title="案例1：将索引 A 所有 shards 分配到 node1, 索引 B 的所有 shards 分配到 node2 、 node3"></a>案例1：将索引 A 所有 shards 分配到 node1, 索引 B 的所有 shards 分配到 node2 、 node3</h3><p>具体步骤：</p>
<ul>
<li>为三个节点分别设置不同的属性，假设 <code>node1</code> 为 <code>hot</code> ，<code>node2</code> 和 <code>node3</code> 均为 <code>warm</code></li>
<li>在 <code>node1</code> 的配置文件中增加 <code>node.attr.hot_waram: hot</code> 在 <code>node2</code> 和 <code>node3</code> 的配置文件中增加 <code>node.attr.hot_warm: warm</code> </li>
<li>依次重启集群中的节点</li>
</ul>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT index_a/_settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index.routing.allocation.require.hot_warm&quot;: &quot;hot&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT index_b/_settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index.routing.allocation.require.hot_warm&quot;: &quot;warm&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看分片的位置，以及重新分配的状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET _cat/shards/index_a?v</span><br><span class="line"></span><br><span class="line">GET _cat/shards/index_b?v</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">重点！！！想要取消设置，可以设置对应的项为空，例如： <code>index.routing.allocation.include.hot_warm:null</code></span></p>
<blockquote>
<p>exclude,include,require 的属性值均采用逗号分隔的字符串。不是数组！</p>
</blockquote>
<h3 id="案例2：-将索引-hamlet-设置为不允许分配在节点-node3-上"><a href="#案例2：-将索引-hamlet-设置为不允许分配在节点-node3-上" class="headerlink" title="案例2： 将索引 hamlet 设置为不允许分配在节点 node3 上"></a>案例2： 将索引 hamlet 设置为不允许分配在节点 node3 上</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT hamlet/_settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index.routing.allocation.exclude._name&quot;:&quot;node3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注： <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/allocation-filtering.html" target="_blank" rel="noopener"><code>_name</code> 是内置的节点属性，除_name之外还包括_ip、_host两个属性</a></p>
<h3 id="案例3：按照要求给节点设置属性-AZ"><a href="#案例3：按照要求给节点设置属性-AZ" class="headerlink" title="案例3：按照要求给节点设置属性 AZ"></a>案例3：按照要求给节点设置属性 AZ</h3><p>要求将 <code>node1</code> 和 <code>node2</code> 的属性设置为 <code>earth</code>、<code>node3</code> 设置为 <code>mars</code>。分片进行 <code>force awareness</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在node1和node2 中配置</span><br><span class="line">node.attr.AZ: earth</span><br><span class="line"></span><br><span class="line">#在node3中配置</span><br><span class="line">node.attr.AZ: mars</span><br></pre></td></tr></table></figure>
<p>新增如上配置，然后重启集群。添加如下设置即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;persistent&quot;:&#123;</span><br><span class="line">        &quot;cluster.routing.allocation.awareness.attributes&quot;: &quot;AZ&quot;,</span><br><span class="line">        &quot;cluster.routing.allocation.awareness.force.zone.values&quot;: &quot;earth,mars&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="单节点-RBAC-全流程配置"><a href="#单节点-RBAC-全流程配置" class="headerlink" title="单节点 RBAC 全流程配置"></a>单节点 RBAC 全流程配置</h2><p>在节点的 <code>elasticsearch.yml</code> 中开启 <code>xpack</code>，增加如下配置项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br></pre></td></tr></table></figure>
<p>重启 <code>elasticsearch</code> ，然后执行密码初始化的 <code>shell</code> :<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./elasticsearch-setup-passwords interactive</span><br></pre></td></tr></table></figure></p>
<p>这个 <code>shell</code> 只能执行一次，如果已经执行过，就只能用 <code>dsl</code> 或者在 <code>kibana</code> 界面中进行密码的修改了。</p>
<p>修改 <code>kibana</code> 中的以下配置项，并重启<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elasticsearch.username: &quot;elastic&quot;</span><br><span class="line">elasticsearch.password: &quot;123456&quot;</span><br></pre></td></tr></table></figure></p>
<p>在设置界面中按照要求配置 <code>user</code> 和 <code>role</code> 即可。</p>
<h2 id="date-histogram-pipeline-聚合"><a href="#date-histogram-pipeline-聚合" class="headerlink" title="date_histogram + pipeline 聚合"></a>date_histogram + pipeline 聚合</h2><p>先求每个月的平均值，然后找出平均值最大的那个月,需要注意是 <code>buckets_path</code> ，有个负数 <code>s</code>，练习时这里我犯了好几回错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET earthquake/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot;:0,</span><br><span class="line">    &quot;aggs&quot;:&#123;</span><br><span class="line">        &quot;month_aggs&quot;:&#123;</span><br><span class="line">            &quot;date_histogram&quot;:&#123;</span><br><span class="line">                &quot;field&quot;: &quot;magnitude&quot;,</span><br><span class="line">                &quot;calendar_interval&quot;: &quot;1M&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;aggs&quot;:&#123;</span><br><span class="line">                &quot;avg_aggs&quot;:&#123;</span><br><span class="line">                    &quot;avg&quot;:&#123;</span><br><span class="line">                        &quot;field&quot;: &quot;magnitude&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_avg_magnitude&quot;:&#123;</span><br><span class="line">            &quot;max_bucket&quot;:&#123;</span><br><span class="line">                &quot;buckets_path&quot;:&quot;month_aggs.avg_aggs&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ingest-数据处理"><a href="#ingest-数据处理" class="headerlink" title="ingest 数据处理"></a>ingest 数据处理</h2><h3 id="案例1：对数组进行处理-数据样例大致如下"><a href="#案例1：对数组进行处理-数据样例大致如下" class="headerlink" title="案例1：对数组进行处理,数据样例大致如下"></a>案例1：对数组进行处理,数据样例大致如下</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> POST test_005/_bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;tags&quot;:[&quot;ping pang&quot;, &quot;basket ball&quot;, &quot; foot bool &quot;]&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:2&#125;&#125;</span><br><span class="line">&#123;&quot;tags&quot;:[&quot; ping pang &quot;, &quot;gof bal&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p> 要求：去除字符串中的空格，增加一个新字段 <code>array_length</code>，值为数组 <code>tags</code> 的长度<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT _ingest/pipeline/my_pipeline</span><br><span class="line">&#123;</span><br><span class="line">    &quot;description&quot;:&quot;for practice&quot;,</span><br><span class="line">    &quot;processors&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;foreach&quot;:&#123;</span><br><span class="line">              &quot;field&quot;: &quot;tags&quot;,</span><br><span class="line">              &quot;processor&quot;:&#123;</span><br><span class="line">                  &quot;trim&quot;:&#123;</span><br><span class="line">                      &quot;field&quot;:&quot;_ingest._value&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;script&quot;:&#123;</span><br><span class="line">              &quot;source&quot;:&quot;&quot;&quot;</span><br><span class="line">              ArrayList list = ctx.tags;</span><br><span class="line">              ctx.array_length = list.size();</span><br><span class="line">              &quot;&quot;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST test_005/_update_by_query?pipeline=my_pipeline</span><br><span class="line">#验证结果</span><br><span class="line">GET test_005/_search</span><br></pre></td></tr></table></figure></p>
<h3 id="案例2：根据条件判断的结果，处理数据"><a href="#案例2：根据条件判断的结果，处理数据" class="headerlink" title="案例2：根据条件判断的结果，处理数据"></a>案例2：根据条件判断的结果，处理数据</h3><ul>
<li>设置 <code>pipeline</code> 名称为 <code>earthquakes_pipeline</code></li>
<li>将 <code>magnitude_type</code> 字段的值转为大写</li>
<li>如果字段中包含 <code>batch_number</code> 则将该值 <code>+1</code> ，否则将 <code>batch_number</code> 置为 <code>1</code>;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST earthquakes/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;batch_number&quot;: 999,</span><br><span class="line">  &quot;magnitude_type&quot;:&quot;abc&quot;</span><br><span class="line">&#125;</span><br><span class="line">POST earthquakes/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;magnitude_type&quot;:&quot;cde&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT _ingest/pipeline/earthquakes_pipeline</span><br><span class="line">&#123;</span><br><span class="line">    &quot;description&quot;:&quot;earth_quakes test&quot;,</span><br><span class="line">    &quot;processors&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;uppercase&quot;:&#123;</span><br><span class="line">            &quot;field&quot;:&quot;magnitude_type&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;script&quot;:&#123;</span><br><span class="line">            &quot;source&quot;:&quot;&quot;&quot;</span><br><span class="line">            if(ctx.batch_number == null)&#123;</span><br><span class="line">                ctx.batch_number = 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                ctx.batch_number +=1;</span><br><span class="line">            &#125;</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST earthquakes/_update_by_query?pipeline=earthquakes_pipeline</span><br><span class="line"></span><br><span class="line">GET earthquakes/_search</span><br></pre></td></tr></table></figure>
<h3 id="案例3：计算字符串长度并分割字符串为数组，最后-reindex-到新索引"><a href="#案例3：计算字符串长度并分割字符串为数组，最后-reindex-到新索引" class="headerlink" title="案例3：计算字符串长度并分割字符串为数组，最后 reindex 到新索引,"></a>案例3：计算字符串长度并分割字符串为数组，最后 reindex 到新索引,</h3><p>虽然 <code>reindex</code> 可以直接写 <code>script</code> ，但采用 <code>ingest</code> 实现更为稳妥一些<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT _ingest/pipeline/reindex_pipeline</span><br><span class="line">&#123;</span><br><span class="line">    &quot;description&quot;:&quot;for reindex test&quot;,</span><br><span class="line">    &quot;processors&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;script&quot;:&#123;</span><br><span class="line">            &quot;source&quot;: &quot;&quot;&quot;</span><br><span class="line">            ctx.content_length = ctx.title.length();</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;set&quot;:&#123;</span><br><span class="line">            &quot;field&quot;:&quot;split_title&quot;,</span><br><span class="line">            &quot;value&quot;:&quot;&#123;&#123;title&#125;&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;split&quot;:&#123;</span><br><span class="line">            &quot;field&quot;:&quot;split_title&quot;,</span><br><span class="line">            &quot;separator&quot;:&quot; &quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DELETE index_a</span><br><span class="line"></span><br><span class="line">POST index_a/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:&quot;foo bar&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST index_a/_update_by_query?pipeline=reindex_pipeline</span><br><span class="line"></span><br><span class="line">GET index_a/_search</span><br></pre></td></tr></table></figure></p>
<h3 id="案例4：-使用-分割字符串，并将分割后的结果存到三个不同的字段中"><a href="#案例4：-使用-分割字符串，并将分割后的结果存到三个不同的字段中" class="headerlink" title="案例4： 使用 . 分割字符串，并将分割后的结果存到三个不同的字段中"></a>案例4： 使用 . 分割字符串，并将分割后的结果存到三个不同的字段中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _ingest/pipeline/_simulate</span><br><span class="line">&#123;</span><br><span class="line">  &quot;pipeline&quot; : &#123;</span><br><span class="line">   &quot;description&quot;: &quot;split pipeline&quot;,</span><br><span class="line">  &quot;processors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;split&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;line_number&quot;,</span><br><span class="line">        &quot;separator&quot;: &quot;\\.&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;set&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;number_act&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;&#123;&#123;line_number.0&#125;&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      &quot;set&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;number_scene&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;&#123;&#123;line_number.1&#125;&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      &quot;set&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;number_line&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;&#123;&#123;line_number.2&#125;&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">        &quot;script&quot;: &#123;</span><br><span class="line">          &quot;source&quot;: &quot;&quot;&quot;</span><br><span class="line">            ctx.a1 = ctx.line_number.0;</span><br><span class="line">            ctx.a2 = ctx.line_number.1;</span><br><span class="line">            ctx.a3 = ctx.line_number.2;</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;docs&quot; : [</span><br><span class="line">    &#123; &quot;_source&quot;: &#123; &quot;line_number&quot;: &quot;1.2.3&quot;&#125; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="別名操作"><a href="#別名操作" class="headerlink" title="別名操作"></a>別名操作</h2><p>别名的快速操作:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#123;index_name&#125;/_alias/&#123;alias_name&#125;</span><br><span class="line"></span><br><span class="line">GET &#123;index_name&#125;/_alias/&#123;alias_name&#125;</span><br><span class="line"></span><br><span class="line">DELETE &#123;index_name&#125;/_alias/&#123;alias_name&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体指令操作，以及针对数据过滤：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _aliases</span><br><span class="line">&#123;</span><br><span class="line">    &quot;actions&quot;:&#123;</span><br><span class="line">        &quot;add&quot;:&#123;</span><br><span class="line">            &quot;index&quot;:&quot;&#123;index_name&#125;&quot;,</span><br><span class="line">            &quot;alias&quot;:&quot;&#123;alias_name&#125;&quot;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;range&quot;:&#123;</span><br><span class="line">                    &quot;&#123;field&#125;&quot;:&#123;</span><br><span class="line">                        &quot;gt&quot;:&quot;&#123;value&#125;&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="单节点备份恢复全过程"><a href="#单节点备份恢复全过程" class="headerlink" title="单节点备份恢复全过程"></a>单节点备份恢复全过程</h2><p>根据要求，切换到可以启动 <code>elastic</code> 的用户，在服务器的指定目录下创建文件夹，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su elastic</span><br><span class="line"></span><br><span class="line">cd /opt/elasticsearch-7.2.1</span><br><span class="line"></span><br><span class="line">mkdir repo</span><br></pre></td></tr></table></figure></p>
<p>在节点的 <code>elasticsearch.yml</code> 文件中新增如下配置项并<strong>重启</strong>,路径即为刚才所创建的文件夹的位置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path.repo: /opt/elasticsearch-7.2.1/repo</span><br></pre></td></tr></table></figure></p>
<p>进行如下测试：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT index_a/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;zhangsan&quot;</span><br><span class="line">&#125;</span><br><span class="line">PUT index_b/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;zhangsan&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 新建仓库 repo ,此时会在 /opt/elasticsearch-7.2.1/repo 下建立相应的文件夹</span><br><span class="line">PUT _snapshot/snapshot_repo</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;fs&quot;,</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;location&quot;: &quot;snapshot_repo&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#创建备份</span><br><span class="line">PUT _snapshot/snapshot_repo/index_snapshot?wait_for_completion=true</span><br><span class="line">&#123;</span><br><span class="line">  &quot;indices&quot;: &quot;index_a,index_b&quot;,</span><br><span class="line">  &quot;ignore_unavailable&quot;: true,</span><br><span class="line">  &quot;include_global_state&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">#删除</span><br><span class="line">DELETE index_a,index_b</span><br><span class="line">#恢复</span><br><span class="line">POST _snapshot/snapshot_repo/index_snapshot/_restore</span><br><span class="line">&#123;</span><br><span class="line">  &quot;indices&quot;: &quot;index_a&quot;,</span><br><span class="line">  &quot;index_settings&quot;:&#123;</span><br><span class="line">    &quot;number_of_replica&quot;: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#成功</span><br><span class="line">GET index_a/_search</span><br><span class="line">#失败</span><br><span class="line">GET index_b/_search</span><br></pre></td></tr></table></figure></p>
<h2 id="跨集群检索配置全流程"><a href="#跨集群检索配置全流程" class="headerlink" title="跨集群检索配置全流程"></a>跨集群检索配置全流程</h2><p><span style="color:red">带权限认证的集群无法之间做 <code>cross_cluster_search</code>，除非签发时用到的证书是一样的。我是将xpack关闭后做的测试</span></p>
<p>在 集群 <code>A</code> 创建 <code>index_a</code> 并插入一条数据，然后修改集群 <code>A</code> 的 <code>_cluster/settings</code>,（需要注意集群的 <code>seeds</code> 地址为 <code>transport</code> 的端口，默认为 <code>9300</code>  ，初次尝试时我没有注意到这点）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE index_a</span><br><span class="line">POST index_a/_doc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;zhangsan&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;persistent&quot;:&#123;</span><br><span class="line">        &quot;cluster&quot;:&#123;</span><br><span class="line">            &quot;remote&quot;:&#123;</span><br><span class="line">                &quot;cluster_B&quot;:&#123;</span><br><span class="line">                    &quot;seeds&quot;:[&quot;172.25.17.61:9300&quot;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在集群 <code>B</code> 创建 <code>index_b</code> 并插入一条数据,然后修改集群 <code>B</code> 的 <code>_cluster/settings</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE index_b</span><br><span class="line">POST index_b/_doc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;lisi&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;persistent&quot;:&#123;</span><br><span class="line">        &quot;cluster&quot;:&#123;</span><br><span class="line">            &quot;remote&quot;:&#123;</span><br><span class="line">                &quot;cluster_A&quot;:&#123;</span><br><span class="line">                    &quot;seeds&quot;:[&quot;172.25.17.58:9300&quot;,&quot;172.25.17.87:9300&quot;,&quot;172.25.17.142:9300&quot;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进行测试：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在集群A 查询 B的数据</span><br><span class="line">GET cluster_B:index_b/_search</span><br><span class="line"></span><br><span class="line">在集群B 查询 A 的数据</span><br><span class="line">GET cluster_A:index_a/_search</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="/images/202105/贝德维尔.jpg" alt="贝德维尔.jpg"></p>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析之LinkedList</title>
    <url>/2019/05/11/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BLinkedList/</url>
    <content><![CDATA[<p>在<code>leetcode</code>中遇到了一道设计链表的题，要求中有一点是不能使用内置的<code>LinkedList</code>库，于是在自己实现了简易版的链表之后，找到了内置的源码来做个分析。<br>可以自行选择实现单向或双向链表 <a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">原题链接</a>。<br>首先，<code>LinkedList</code>是个双向链表，每个数据结点中都有两个“指针”，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点（百科）。<br>首先，来看看<code>LinkedList</code>的<strong>基础属性</strong>：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;  <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;  <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>; <span class="comment">//节点个数</span></span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//首节点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">//尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;  <span class="comment">//初始化一个空的链表集合</span></span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  <span class="comment">//根据已有集合初始化</span></span><br><span class="line">        <span class="keyword">this</span>();  </span><br><span class="line">        addAll(c);  <span class="comment">//稍后分析addAll</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部类---节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;  </span><br><span class="line">	    E item;  <span class="comment">//节点本身</span></span><br><span class="line">	    Node&lt;E&gt; next;  <span class="comment">//前驱节点</span></span><br><span class="line">	    Node&lt;E&gt; prev;  <span class="comment">//后继节点</span></span><br><span class="line">  </span><br><span class="line">	    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;  </span><br><span class="line">	        <span class="keyword">this</span>.item = element;  </span><br><span class="line">	        <span class="keyword">this</span>.next = next;  </span><br><span class="line">	        <span class="keyword">this</span>.prev = prev;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<!--more-->
<p><strong>节点的添加</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认的add会加到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">    linkLast(e);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定位置添加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </span><br><span class="line">    checkPositionIndex(index); <span class="comment">//检查节点是否存在</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index == size)  </span><br><span class="line">        linkLast(element);  <span class="comment">//在节点尾部添加</span></span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">	    linkBefore(element, node(index));  <span class="comment">//在指定节点前添加，node(index)会查询出位于index位置的节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">    linkFirst(e);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">    linkLast(e);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1.检查节点是否存在</strong>（方法很简单，判断了下<code>size</code>和<code>index</code>）:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))  <span class="comment">//isPositionIndex</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.在节点尾部/首部添加</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在首部添加节点，此方法为私有方法，实际使用时调用addFirst</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;  <span class="comment">//将final类型的f节点指向首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);  <span class="comment">//新建节点</span></span><br><span class="line">    first = newNode;  <span class="comment">//将新节点变为首节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)  </span><br><span class="line">        last = newNode;  <span class="comment">//链表为空，此时first = last = newNode</span></span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">	    f.prev = newNode;  <span class="comment">//将新节点加入到链表中</span></span><br><span class="line">    size++;  <span class="comment">//节点数+1</span></span><br><span class="line">    modCount++; <span class="comment">//modCount表示更改次数，在遍历时才会用到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在尾部添加节点，此方法没有修饰符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;  </span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);  </span><br><span class="line">    last = newNode;  </span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)   </span><br><span class="line">        first = newNode;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">	    l.next = newNode;  </span><br><span class="line">    size++;  </span><br><span class="line">    modCount++;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>linkFirst</code>与<code>linkLast</code>类似，这里介绍简单说下<code>linkFirst</code>，首先将当前的首节点的引用赋值给f，然后新建一个<code>Node</code>节点，节点的<code>next</code>指向f，<code>prev</code>为<code>null</code>。将新节点变为首节点，同时判断f是否为空，如果f为空说明链表为空，此时新节点既为首节点也为尾节点，否则将f的<code>prev</code>指向新的节点。此时新节点就加到了链表中。<br><strong>3.在指定位置添加:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先看下node(index)如何定位到节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">  <span class="comment">//这里的移位操作size&gt;&gt;1其实就是size的一半，如果index小于size的一半，那么从前往后找，否则从后往前找，这样可以加快查找速度</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;   </span><br><span class="line">        Node&lt;E&gt; x = first;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) </span><br><span class="line">            x = x.next;  </span><br><span class="line">        <span class="keyword">return</span> x;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        Node&lt;E&gt; x = last;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)  </span><br><span class="line">            x = x.prev;  </span><br><span class="line">        <span class="keyword">return</span> x;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在指定节点前添加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;  <span class="comment">//拿到指定节点的前一个</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);  <span class="comment">//新的节点next指向succ，pre指向pred</span></span><br><span class="line">    succ.prev = newNode;  </span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)  </span><br><span class="line">        first = newNode;  <span class="comment">//pred为空的话，表示succ为first，将first替换为newNode</span></span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">	    pred.next = newNode;  <span class="comment">//否则pred的next指向newNode</span></span><br><span class="line">    size++;  </span><br><span class="line">    modCount++;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>构造方法addAll</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> addAll(size, c); <span class="comment">//传入当前size 和构造参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在指定位置index的前方，添加多个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">    checkPositionIndex(index);  </span><br><span class="line">  </span><br><span class="line">    Object[] a = c.toArray();  </span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;  <span class="comment">//需要添加的元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">  </span><br><span class="line">    Node&lt;E&gt; pred, succ;  </span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;  <span class="comment">//位置等于size，即在链表末尾添加，否则在链表中间添加</span></span><br><span class="line">        succ = <span class="keyword">null</span>;  </span><br><span class="line">        pred = last;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        succ = node(index);  <span class="comment">//index处的节点</span></span><br><span class="line">        pred = succ.prev;  <span class="comment">//index的上一个节点</span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;  </span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;  </span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);  <span class="comment">//创建新节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)  </span><br><span class="line">            first = newNode;  <span class="comment">//初始化第一个节点</span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">		    pred.next = newNode;  <span class="comment">//链接新节点</span></span><br><span class="line">        pred = newNode;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        last = pred;  <span class="comment">//在尾部插入，那么循环结束后，pred就是尾节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        pred.next = succ;  <span class="comment">//否则，需要将pred的next指向succ节点</span></span><br><span class="line">        succ.prev = pred;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    size += numNew;  <span class="comment">//修改节点个数</span></span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>节点的删除</strong><br>删除操作有多种方式，但都是基于<code>unlink</code>方法实现的，这里就简单写一种吧(偷懒ing):<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    checkElementIndex(index);  <span class="comment">//检查是否存在元素</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));  <span class="comment">//执行unlink</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unlink操作</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> E element = x.item;  <span class="comment">//需要删除的节点赋给final的element常量</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;  </span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        first = next;  <span class="comment">//需要删除的节点为first，那么删除后它next变为first</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        prev.next = next;  <span class="comment">//前后节点相连，跳过当前节点</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;  <span class="comment">//把需要删除节点的pre变为null</span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        last = prev;  <span class="comment">//需要删除的节点为last，删除后它的pre变为last</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        next.prev = prev;  <span class="comment">//前后节点相连，跳过当前节点</span></span><br><span class="line">        x.next = <span class="keyword">null</span>;  <span class="comment">//把需要删除节点的next也变为null</span></span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    x.item = <span class="keyword">null</span>;  <span class="comment">//将节点的item也变为null，帮助gc回收</span></span><br><span class="line">    size--;  <span class="comment">//节点数-1</span></span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="keyword">return</span> element;  <span class="comment">//返回element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>节点的查找</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get方法还是调用的node(index)进行定位，返回节点的item</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    checkElementIndex(index);  </span><br><span class="line">    <span class="keyword">return</span> node(index).item;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，<code>LinkedList</code>的基础方法就分析完了，其余的高级方法诸如<code>push</code>、<code>pop</code>、<code>peek</code>、<code>poll</code>等等，都是基于这些基本方法完成的。（<code>java</code>中的栈是基于<code>Vector</code>实现的，每个方法都有<code>Syncronized</code>修饰，所以在1.5之后<code>LinkedList</code>添加了用于实现无锁栈的方法）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">void</span> push(E e) &#123;  </span><br><span class="line">    addFirst(e);  </span><br><span class="line">&#125;</span><br><span class="line">public E pop() &#123;  </span><br><span class="line">    <span class="keyword">return</span> removeFirst();  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前两个为空会抛出异常，peek和poll不会</span></span><br><span class="line">public E peek() &#123;  </span><br><span class="line">    final Node&lt;E&gt; f = first;  </span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;  </span><br><span class="line">&#125;</span><br><span class="line">public E poll() &#123;  </span><br><span class="line">    final Node&lt;E&gt; f = first;  </span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>补充：</strong> 在源码中可以看到<code>transient</code>和<code>final</code>关键字的使用，这里也把两者的作用记下。  </p>
<p>   <code>transient</code>的作用：</p>
<ul>
<li>阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化时，被<code>transient</code>修饰的变量值不会被持久化和恢复。<code>transient</code>只能修饰变量，不能修饰类和方法。</li>
</ul>
<p><code>final</code>关键字的一些总结：</p>
<ul>
<li>1.对于一个变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能修改，如果是引用类型的变量，则在对其初始化之后便不能再让其指向另外一个对象。</li>
<li>2.当用<code>final</code>修饰一个类时，表明这个类不能被继承。<code>final</code>类中的所有成员方法都会隐式地指定为<code>final</code>方法。</li>
<li>3.使用<code>final</code>方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。类中所有的<code>private</code>方法都隐式地指定为<code>final</code>。在早期的<code>java</code>版本中，会将<code>final</code>方法转为内嵌调用。但如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现版本已经不需要使用<code>final</code>方法进行这些优化了）。</li>
</ul>
]]></content>
      <categories>
        <category>深入java</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>无锁队列的简单实现及ConcurrentLinkedQueue源码解析</title>
    <url>/2020/09/02/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%8F%8AConcurrentLinkedQueue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h2><p>无锁也称为 <code>LockFree</code>，其实现原理是基于 <code>CAS( compare and swap)</code>  原子操作来保证多线程下共享资源的线程安全问题。</p>
<ul>
<li><code>CAS(V,E,N)</code> 代表的是要更新的值 <code>V</code>，预期值 <code>E</code>，当且仅当要更新的值等于预期值时<code>(V=E)</code>，将 <code>V</code> 的值设为 <code>N</code>。</li>
<li><code>CAS</code> 操作会返回一个 <code>boolean</code> 值，<code>true</code> 表示交换成功，失败时进入循环，重新进行下一轮操作。</li>
</ul>
<p>无锁队列则是使用 <code>CAS</code> 来实现的，且支持并发操作的队列。在阅读源码之前，我使用 <code>Atomic</code> 包里的原子类及网上的一些参考信息编写了一个使用数组实现的简易无锁队列。</p>
<p>代码如下：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LockFreeQueue &#123;</span><br><span class="line"></span><br><span class="line">    //队列元素</span><br><span class="line">    private AtomicReferenceArray items;</span><br><span class="line">    //容量</span><br><span class="line">    private volatile int size;</span><br><span class="line">    //入队次数</span><br><span class="line">    private AtomicInteger enCount;</span><br><span class="line">    //出队次数</span><br><span class="line">    private AtomicInteger deCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LockFreeQueue(int size) &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        //new Object[size+1]，下标0当做哨兵元素，不使用，处理下标挺麻烦的</span><br><span class="line">        items = new AtomicReferenceArray(size+1);</span><br><span class="line">        enCount = new AtomicInteger(0);</span><br><span class="line">        deCount = new AtomicInteger(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入队,更改队尾，入队次数和出队次数取模，可以很容易得到当前 head 和 tail 的下标</span><br><span class="line">    public boolean add(Object obj) throws Exception &#123;</span><br><span class="line">        if (obj == null) &#123;</span><br><span class="line">            throw new Exception(&quot;元素不能为null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //新的 tail 位置</span><br><span class="line">        int newTailIndex = (enCount.get()+1) % size;</span><br><span class="line">        //用出队次数计算当前 head 位置</span><br><span class="line">        int headIndex = deCount.get() % size;</span><br><span class="line">        // tail 取的是+1后的模，两者相等时表示队列已满</span><br><span class="line">        if (newTailIndex == headIndex) &#123;</span><br><span class="line">            System.out.println(&quot;队列已满,&quot; + obj + &quot;入队失败!&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //CAS设置值</span><br><span class="line">            while (!items.compareAndSet(newTailIndex, null, obj)) &#123;</span><br><span class="line">                add(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            //入队次数+1</span><br><span class="line">            enCount.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;入队成功!&quot; + obj);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //找到队首，出队。</span><br><span class="line">    public Object poll() &#123;</span><br><span class="line">        if (enCount.get() == deCount.get()) &#123;</span><br><span class="line">            System.out.println(&quot;当前队列为空,出队失败!&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int headIndex = (deCount.get()+1) % size;</span><br><span class="line">        Object obj = items.get(headIndex);</span><br><span class="line">        if(obj!=null &amp;&amp; items.compareAndSet(headIndex,obj,null))&#123;</span><br><span class="line">            //出队次数+1</span><br><span class="line">            deCount.incrementAndGet();</span><br><span class="line">            System.out.println(&quot;出队成功!&quot; + obj);</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // cas 失败，或其余线程已出队成功，此处线程并发高会出现递归栈溢出。。。</span><br><span class="line">            return poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123;</span><br><span class="line">        StringBuffer buffer = new StringBuffer(&quot;[&quot;);</span><br><span class="line">        for(int i=1;i&lt;size;i++)&#123;</span><br><span class="line">            if(items.get(i)==null)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                buffer.append(items.get(i)).append(&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.deleteCharAt(buffer.length() - 1);</span><br><span class="line">        buffer.append(&quot;]&quot;);</span><br><span class="line">        System.out.println(&quot;当前队列为：&quot;+buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LockFreeQueue queue = new LockFreeQueue(10);</span><br><span class="line">        //弊端，数字调大后，容易出现栈溢出</span><br><span class="line">        IntStream.rangeClosed(1,20).parallel().forEach(i -&gt; &#123;</span><br><span class="line">            if (i % 2 == 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.add(i);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        queue.print();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p><code>ConcurrentLinkedQueue</code> 是 <code>jdk</code> 并发包中提供的无锁队列，它是使用单向链表来实现的，其类图结构大致如下：</p>
<p><img src="/images/20200902/ConcurrentLinkedQueue.jpg" alt="image"></p>
<p>结合源码通过分析可知使用的数据结构是单向链表，同时定义了两个 <code>volatile</code> 的原子变量 <code>head</code> 和 <code>tail</code> 用于表示队列的头部和尾部，队列初始化时，会将头部和尾部指向哨兵节点（构造函数）。下述代码展示了其相关的基本属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private transient volatile Node&lt;E&gt; head;</span><br><span class="line">private transient volatile Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line">//构造函数</span><br><span class="line">public ConcurrentLinkedQueue() &#123;</span><br><span class="line">    //初始化 head 和 tail 指向哨兵节点</span><br><span class="line">    head = tail = new Node&lt;E&gt;(null);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">//静态内部类 Node</span><br><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    volatile E item; //节点值</span><br><span class="line">    volatile Node&lt;E&gt; next;//指向下一节点</span><br><span class="line"></span><br><span class="line">    //原子操作 item</span><br><span class="line">    boolean casItem(E cmp, E val) &#123;</span><br><span class="line">        return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">    //这里的 setLazyNext 主要在更新头结点和尾节点时用到了。</span><br><span class="line">    // putOrderedObject 采用 store-store，禁止重排序，只写回主内存，不加载到线程的工作内存中</span><br><span class="line">    void lazySetNext(Node&lt;E&gt; val) &#123;</span><br><span class="line">        UNSAFE.putOrderedObject(this, nextOffset, val);</span><br><span class="line">    &#125;</span><br><span class="line">    //原子操作 next</span><br><span class="line">    boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123;</span><br><span class="line">        return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    private static final long itemOffset;</span><br><span class="line">    private static final long nextOffset;</span><br><span class="line">    </span><br><span class="line">    static&#123;</span><br><span class="line">        //...此处使用静态块初始化了 unsafe、itemOffset、nextOffset</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了内部类 <code>Node</code> 中提供的原子操作方法后，接下来看看其入队、出队等功能是如何实现的。</p>
<h3 id="1-offer-入队操作："><a href="#1-offer-入队操作：" class="headerlink" title="1.offer 入队操作："></a>1.offer 入队操作：</h3><p><strong>入队的核心是通过 <code>CAS</code> 设置修改 <code>tail.next</code> 的值，成功则加入队列，失败的线程则继续循环，直到成功。</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    //1.检查对象是否为空，null 抛出异常</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    //2.新建节点为 newNode</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    //括号里的两行只会在循环开始时执行一次。 t 和 p 都是循环内的局部变量，估计可以优化性能吧</span><br><span class="line">    for (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        //3.执行入队操作</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        //4. q 为空了，所以 p 是最后一个节点，执行插入</span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            //5.使用 cas更新尾节点为newNode</span><br><span class="line">            if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                //6. cas 更新成功，尾节点已变为 newnode，返回 true，同时判断是否更新 tail 的位置</span><br><span class="line">                // tail 是间隔一个元素进行更新的，不是每次入队都会刷新 tail.</span><br><span class="line">                if (p != t) // 跳跃更新头结点 head 的位置</span><br><span class="line">                    casTail(t, newNode);  // Failure is OK.</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            // Lost CAS race to another thread; re-read next</span><br><span class="line">        &#125;</span><br><span class="line">        //7. q 是 p 的 next 指针，两者相等说明此时为自引用状态，重新找到 head 的值。这一步判断是因 poll 引起的</span><br><span class="line">        else if (p == q)</span><br><span class="line">            //这句话是可以返回 false 的，这与 JVM 的压栈顺序有关，</span><br><span class="line">            //执行时 t 的值会先被读取压入栈底，随后读取 tail 赋给 t 将赋值结果入栈，</span><br><span class="line">            //最后取两者进行对比。因为涉及多线程操作，在入栈后赋值前若 tail 的值因其它线程发生了变化。</span><br><span class="line">            //那么取赋值后的 t 为 head ，否则 head 还是原来的 head</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        else</span><br><span class="line">            // 8.因其它线程先 cas 成功，所以需要重新找到尾节点尝试新一轮的入队</span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设一开始队列为空，初始化后第一次入队操作时，成功运行节点1、2、3的代码后其状态如下：</p>
<p><img src="/images/20200902/offer状态1.jpg" alt="image"></p>
<p>到节点 4 判断 <code>q == null</code> 时，若两个线程 A,B 并发的判断成功了，都会进入节点 5 处的代码，假设线程 A 先 进行 <code>CAS</code> 更新 <code>tail</code> 成功，将 <code>newNode</code> 加入到了队列，并且，由于 <code>p==t</code>,不会触发 <code>tail</code> 的位置更新。此时队列状态为：</p>
<p><img src="/images/20200902/offer状态2.jpg" alt="image"></p>
<p>与此对应，线程 B 也进行 <code>CAS</code> 但因 A 已经成功，所以 B 的交换会返回 <code>false</code>，进入下一轮循环，并重新运行到节点 4 的位置，此时由于 <code>q!=null</code> 且 <code>p!=q</code> 所以会运行到节点 8，将 q 赋值给 p。此时队列状态更新为：</p>
<p><img src="/images/20200902/offer状态3.jpg" alt="image"></p>
<p>线程 B 继续下一轮循环，现在找到了正确的 <code>tail</code> 为 p，运行到 4 时，判断 <code>q = p.next</code> 为空，随后进入到 5 的位置，进行 <code>CAS</code> 操作且将线程 B 的 <code>newNode</code> 加入到队列中，此时队列状态为：</p>
<p><img src="/images/20200902/offer状态4.jpg" alt="image"></p>
<p>由于 <code>p!=t</code> ，所以触发 <code>tail</code> 结点更新，队列状态变更为：</p>
<p><img src="/images/20200902/offer状态5.jpg" alt="image"></p>
<p>经上述流程后， 1-8 中除 7 以外的都已经执行过了，那么节点 7 是在什么时候执行的呢。其实 7 是在其它线程进行 <code>poll</code> 后或 <code>remove</code> 后出现的一种特殊情况才会发生，其队列状态如下：</p>
<p><img src="/images/20200902/offer状态6.jpg" alt="image"></p>
<p>此时进行 <code>offer</code> 操作运行到 4 时的队列状态为下图所示( <code>q==null</code> 为 <code>false</code>,有自引用所以不是 <code>NULL</code> ):</p>
<p><img src="/images/20200902/offer状态7.jpg" alt="image"></p>
<p>随后 7 判断到 <code>p == q</code> ,将 <code>head</code> 的值赋给了 p，下一轮循环再次运行到 4 时的队列状态变为了：</p>
<p><img src="/images/20200902/offer状态8.jpg" alt="image"></p>
<p>此时的 <code>q ==null</code> 返回 <code>true</code>，进入 5 ，若没有线程在做 <code>offer</code> 操作，则将新节点加入到队列。</p>
<p>由于 <code>p != t</code> 所以设置新节点为 <code>tail</code>，队列状态变为：</p>
<p><img src="/images/20200902/offer状态9.jpg" alt="image"></p>
<p>最后，自引用节点（自引用是在 <code>updateHead</code> 方法中产生的）会由于没有对象引用它，下一次GC时会被自动清理。</p>
<h3 id="2-poll-出队操作："><a href="#2-poll-出队操作：" class="headerlink" title="2.poll 出队操作："></a>2.poll 出队操作：</h3><p><strong>出队的核心是找到队首 <code>head</code>，并将 <code>head</code> 的值返回，并通过 <code>CAS</code> 将 <code>head</code> 设为 <code>NULL</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    //1. 标签，类似于 goto 的作用。只能用在 for、while、do while 的开始位置。</span><br><span class="line">    restartFromHead:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            //2.保存当前节点值</span><br><span class="line">            E item = p.item;</span><br><span class="line">            //3.判断 CAS</span><br><span class="line">            if (item != null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line">                //4. CAS 成功，判断是否更新 head 位置</span><br><span class="line">                if (p != h) // hop two nodes at a time</span><br><span class="line">                    updateHead(h, ((q = p.next) != null) ? q : p);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            //5. p 为最后一个节点，此时队列为空，返回 null</span><br><span class="line">            else if ((q = p.next) == null) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            //6.自关联状态，重新回到goto</span><br><span class="line">            else if (p == q)</span><br><span class="line">                continue restartFromHead;</span><br><span class="line">            //7.将下一个节点赋值给 p，重新循环。</span><br><span class="line">            else</span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的代码一共分为了 7 个部分，现在假设队列一开始为空，线程运行到节点 3 的时候，队列状态为如下：</p>
<p><img src="/images/20200902/poll状态1.jpg" alt="image"></p>
<p>此时，<code>item</code> 的值为空，且 <code>(q = p.next) == null</code> 返回 <code>true</code> ，队列为空，代码进入到节点 5 交换头结点，但由于h和p是相等的，所以不会变化，返回 <code>null</code> 值。</p>
<p>倘若当线程A运行到节点 5 时，线程 B 已经入队了一个元素。队列的状态变为了：</p>
<p><img src="/images/20200902/poll状态2.jpg" alt="image"></p>
<p>此时节点 5、6 都会判断失败，代码进入到节点 7，将 q 的值赋给了 p，并进入下一轮循环，此时队列状态更新为：</p>
<p><img src="/images/20200902/poll状态3.jpg" alt="image"></p>
<p>当代码再次运行到节点 3 的时候，队列状态为下图所示：</p>
<p><img src="/images/20200902/poll状态4.jpg" alt="image"></p>
<p>节点 4 判断 <code>item!=null</code>，且此时没有其它线程干扰的话，<code>CAS</code> 成功， 由于 <code>p!=h</code> 所以更新头结点的位置为 p，队列状态更新为：（这时候，<code>tail</code> 的状态就是上面 <code>offer</code> 操作时节点7对应的状态。）</p>
<p><img src="/images/20200902/poll状态5.jpg" alt="image"></p>
<p>对于 <code>poll</code> 操作的节点 6，也是一种并发场景，它出现在当线程 A 执行第四步，<code>CAS</code> 刚成功，但还没有更新头结点。此时线程 B 刚开始 <code>poll</code> 操作，得到 p 指向 <code>head</code>，队列状态为如下：</p>
<p><img src="/images/20200902/poll状态6.jpg" alt="image"></p>
<p>这时，线程A 更新 <code>head</code> 成功退出循环，原来的元素变成自引用，队列状态变为：</p>
<p><img src="/images/20200902/poll状态7.jpg" alt="image"></p>
<p>当线程 B 运行到 6 时，就会发生 <code>p== q</code>，跳回到循环起始位置，重新获取 <code>head</code> 出队。</p>
<h4 id="3-peek获取队首"><a href="#3-peek获取队首" class="headerlink" title="3.peek获取队首"></a>3.peek获取队首</h4><p><code>peek</code> 的功能是返回队首元素，但不出队。所以比起 <code>poll</code> 而言，本质就是少了 <code>CAS</code> 操作而已。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E peek() &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            //1.存储节点值</span><br><span class="line">            E item = p.item;</span><br><span class="line">            //2.判断节点</span><br><span class="line">            if (item != null || (q = p.next) == null) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            //3.处理自引用</span><br><span class="line">            else if (p == q)</span><br><span class="line">                continue restartFromHead;</span><br><span class="line">            else</span><br><span class="line">            //4.重新定位头结点的位置</span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于初始时，<code>head</code> 和 <code>tail</code> 指向的是哨兵节点。<code>peek</code> 进行第一次循环时得到的 <code>item</code>必定为 <code>null</code>，如果队列中没有元素，那么 2 判断成功，更新头结点，但 <code>h==p</code> 所以没有变化，返回 <code>null</code> 值。</p>
<p><img src="/images/20200902/peek1.jpg" alt="image"></p>
<p>如果队列中有元素，代码进入到 4，更新 p 的位置。下次运行到 2  时，<code>item!=null</code>，更新头结点成功，并返回真正的 <code>head</code> 值。</p>
<p><img src="/images/20200902/peek2.jpg" alt="image"></p>
<p>出现自引用时，更新头结点位置与 <code>poll</code> 的方式相同，不再说明。</p>
<h3 id="4-updateHead更新头结点"><a href="#4-updateHead更新头结点" class="headerlink" title="4.updateHead更新头结点"></a>4.updateHead更新头结点</h3><p>该方法用于交换头结点的位置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123;</span><br><span class="line">    //当 h!=p 时，且 cas 更新头节点成功，执行 lazySetNext，将 h 指向 h 自己，也就是自引用。</span><br><span class="line">    if (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>上述说到自引用的时候可能会有疑惑，其实就是因为 <code>updateHead</code> 方法中 <code>lazySetNext</code> 的原因。</strong></p>
<h3 id="5-first-取第一个元素"><a href="#5-first-取第一个元素" class="headerlink" title="5. first 取第一个元素"></a>5. first 取第一个元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node&lt;E&gt; first() &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            boolean hasItem = (p.item != null);</span><br><span class="line">            //判断是否有值，head 位置没更新的时候更新 head</span><br><span class="line">            if (hasItem || (q = p.next) == null) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                return hasItem ? p : null;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p == q)</span><br><span class="line">                continue restartFromHead;</span><br><span class="line">            else</span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-其余方法"><a href="#6-其余方法" class="headerlink" title="6.其余方法"></a>6.其余方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//获取下一个元素</span><br><span class="line">final Node&lt;E&gt; succ(Node&lt;E&gt; p) &#123;</span><br><span class="line">    Node&lt;E&gt; next = p.next;</span><br><span class="line">    //判断是否自引用？是返回 head，否则 next</span><br><span class="line">    return (p == next) ? head : next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取size大小，并发可能不准确</span><br><span class="line">public int size() &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    //从第一个元素开始，不断取next</span><br><span class="line">    for (Node&lt;E&gt; p = first(); p != null; p = succ(p))</span><br><span class="line">        if (p.item != null)</span><br><span class="line">            // 最大返回MAX_VALUE</span><br><span class="line">            if (++count == Integer.MAX_VALUE)</span><br><span class="line">                break;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//判断元素是否存在，也可能不准确</span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    if (o == null) return false;</span><br><span class="line">    for (Node&lt;E&gt; p = first(); p != null; p = succ(p)) &#123;</span><br><span class="line">        E item = p.item;</span><br><span class="line">        if (item != null &amp;&amp; o.equals(item))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//移除对象</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    // 不能为null</span><br><span class="line">    if (o != null) &#123;</span><br><span class="line">        Node&lt;E&gt; next, pred = null;</span><br><span class="line">        //从第一个节点开始遍历</span><br><span class="line">        for (Node&lt;E&gt; p = first(); p != null; pred = p, p = next) &#123;</span><br><span class="line">            boolean removed = false;</span><br><span class="line">            E item = p.item;</span><br><span class="line"> </span><br><span class="line">            if (item != null) &#123;</span><br><span class="line">                // 若不匹配，则获取next节点继续匹配</span><br><span class="line">                if (!o.equals(item)) &#123;</span><br><span class="line">                    next = succ(p);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                // 若匹配，则通过CAS操作将对应节点元素置为null</span><br><span class="line">                removed = p.casItem(item, null);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // 获取删除节点的后继节点</span><br><span class="line">            next = succ(p);</span><br><span class="line">            if (pred != null &amp;&amp; next != null) // unlink</span><br><span class="line">                //维护pred和next之间的链表关系,将被删除的节点移除队列</span><br><span class="line">                pred.casNext(p, next);</span><br><span class="line">            if (removed)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul>
<li><p><code>head/tail</code> 并非总是指向队列的头 / 尾节点，而是采用了一种 <code>hop two nodes at a time</code> 的<br>方式，每隔一个节点更新。或者在进行其他的操作的时候变相更新位置。(事实上，<code>remove</code>、<code>peek</code>、<code>first</code>、<code>poll</code>都会更新 <code>head</code> 的位置)。</p>
</li>
<li><p>由于队列有时会处于不一致状态。为此，<code>ConcurrentLinkedQueue</code> 使用 <a href="https://developer.ibm.com/zh/articles/j-lo-concurrent/" target="_blank" rel="noopener">三个不变式</a> 来维护非阻塞算法的正确性。</p>
</li>
<li><p>为了有利于垃圾收集，队列使用了特有的 <code>head</code> 更新机制；通过 <code>setLazyNext</code> 将原节点改为自引用，促进垃圾回收。</p>
</li>
</ul>
<h4 id="为什么使用-hop-的方式更新-head-和-tail"><a href="#为什么使用-hop-的方式更新-head-和-tail" class="headerlink" title="为什么使用 hop 的方式更新 head 和 tail"></a>为什么使用 hop 的方式更新 head 和 tail</h4><p>其实一直将 <code>tail</code> 节点作为队列的尾节点是可以的，但这样会导致每次入队后，都要用 <code>CAS</code> 更新 <code>tail</code>，如果能减少 <code>CAS</code>更新 <code>tail</code> 的次数，就能变相的提高入队的效率。但如果每次 <code>hop</code> 的距离过大，就会加长定位尾节点的时间，所以源码的实现里是跳了一个位置。</p>
<p>总结自《并发编程艺术》、和许多博文（orz）。</p>
]]></content>
      <categories>
        <category>深入java</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个kubernetes应用</title>
    <url>/2019/07/20/%E7%AC%AC%E4%B8%80%E4%B8%AAKubernetes%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="使用小细节"><a href="#使用小细节" class="headerlink" title="使用小细节"></a>使用小细节</h3><p>从节点上使用kubectl时，如果出现  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><del>可以使用以下命令解决：</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
<p><del>原因暂时母鸡，我试过把这句话加到环境变量，但是并没有卵用…..</del><br>（问题找到了。。将master节点的/etc/kubernetes/admin.conf拷贝到 worker节点上）执行如下即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>
<p>另外，每次集群宕机后，各节点都需要运行一遍swapoff -a ，不然无法启动。</p>
<h2 id="第一个kubernetes应用"><a href="#第一个kubernetes应用" class="headerlink" title="第一个kubernetes应用"></a>第一个kubernetes应用</h2><p>在上一篇笔记中，已经使用kubeadm这个工具搭建好了一个完整的kubernetes集群，现在就是时候来体验一下如何使用kubernetes管理容器应用了。<br><!--more--><br>首先，kubernetes是基于容器进行部署的，那么我们需要的第一个东西就是镜像。然后，我们需要根据kubernetes的规范和要求，将镜像组织为kubernetes能够认识的方式：  编写yaml文件。</p>
<p>kubernetes与Docker的不同之处就在于，kubernetes不推荐使用命令行的方式来运行容器，而是使用yaml/json的方式来运行。将容器的信息都记录在文件中，然后使用如下的语句将它运行起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl  create -f  xxx.yaml</span><br></pre></td></tr></table></figure>
<p>这样，在运行容器的同时，也记录下了run的相关信息。在需要变更时，可以有相关记录。（其实在容器编排上来说docker-compose也是这样的思路，只是kubernetes提供的功能相对来说更加的强大和全面。）比如下面这个yaml文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.16.0</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure></p>
<p>在这个文件中，metadata代表的是元数据信息，name：nginx-deployment就是为这个Deployment自定义的名称，而kind: Deployment代表的是定义多个副本的应用。replicas告诉kubernetes需要在所有节点中，保证有且仅有2个节点在同时运行。  </p>
<p>除此之外，template定义了pod的模板，声明每个创建出来的容器都带有一个标签app：nginx，使用的基础镜像为nginx:1.16.0，并且开放容器端口80。  </p>
<p>使用kubectl apply指令创建/更新这个yaml文件对应的容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure>
<p>kubectl  create 和 kubectl replace 分别对应着创建和更新，但一般不推荐，因为apply可以统一完成这两种操作。</p>
<p>接下来，可以通过kubectl get 检查运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods -l app=nginx</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-75fdccc955-vpdqm   1/1     Running   0          25s</span><br><span class="line">nginx-deployment-75fdccc955-wdfxf   1/1     Running   0          25s</span><br></pre></td></tr></table></figure></p>
<p>这个命令中，-l表示的是查找pod中label标签为app=nginx的，也就是yaml文件中所配置的那样，可以看到两个副本都已经处于running状态，表示这个Deployment所管理的Pod都处于预期状态。  </p>
<p>此外，使用kubectl describe可以查看pod的相关信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe pod nginx-deployment-75fdccc955-vpdqm</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Name:           nginx-deployment-75fdccc955-vpdqm</span><br><span class="line">Namespace:      default</span><br><span class="line">Node:           node1/192.168.110.130</span><br><span class="line">Labels:         app=nginx</span><br><span class="line">                pod-template-hash=75fdccc955</span><br><span class="line">Status:         Running</span><br><span class="line">IP:             10.244.0.54</span><br><span class="line">Controlled By:  ReplicaSet/nginx-deployment-75fdccc955</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  65s   default-scheduler  Successfully assigned default/nginx-deployment-75fdccc955-vpdqm to node1</span><br><span class="line">  Normal  Pulling    64s   kubelet, node1     Pulling image &quot;nginx:1.16.0&quot;</span><br><span class="line">  Normal  Pulled     44s   kubelet, node1     Successfully pulled image &quot;nginx:1.16.0&quot;</span><br><span class="line">  Normal  Created    44s   kubelet, node1     Created container nginx</span><br><span class="line">  Normal  Started    43s   kubelet, node1     Started container nginx</span><br></pre></td></tr></table></figure>
<p>在返回结果中，可以看到诸如name、node、labels、IP等等一系列相关信息。除此之外，还有一个特别的部分：<strong>Events</strong>。在Events中，可以看到这个Pod从分配节点到拉取镜像再到运行容器的整个流程。所以，当运行发生异常时往往可以在这里看到错误信息，帮助Debug。</p>
<p>当需要进行升级时，如从1.16.0升级到latest版本，只需要将yaml文件对应的镜像改为image:  nginx即可，然后运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">deployment.apps/nginx-deployment configured</span><br></pre></td></tr></table></figure>
<p>如果速度较快的话，可以查看到如下情况：（停止和删除原先的Pod，并重新创建的过程）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods -l app=nginx</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">NAME                                READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-deployment-75fdccc955-vpdqm   1/1     Terminating         0          31m</span><br><span class="line">nginx-deployment-75fdccc955-wdfxf   1/1     Running             0          31m</span><br><span class="line">nginx-deployment-7bffbd4747-kz8qt   0/1     ContainerCreating   0          1s</span><br><span class="line">nginx-deployment-7bffbd4747-qb9x2   1/1     Running             0          2s</span><br></pre></td></tr></table></figure>
<p>接下来，尝试为容器添加Volume数据卷映射，修改yaml内容为如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &quot;/usr/share/nginx/html&quot;</span><br><span class="line">          name: nginx-vol</span><br><span class="line">      volumes:</span><br><span class="line">      - name: nginx-vol</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /var/data</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在这个yaml中增加了一个volumeMounts的属性，它所代表的含义是将容器mountPath所指定的目录挂载到名称为nginx-vol的Volume中，同时volumes属性声明了一个名为nginx-vol的卷供容器使用，并且类型为hostPath。这样一来，宿主机的/var/data目录就和容器的mountPath目录建立了映射关系。</p>
<p>运行kubectl describe指令可以查看到映射的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">......</span><br><span class="line">Containers:</span><br><span class="line">  nginx:</span><br><span class="line">    Container ID:   docker://db553728961f2b62bb3fc48c46e2053674743d04eab21abd19528ae28ad9abde</span><br><span class="line">    Image:          nginx:1.16.0</span><br><span class="line">    Image ID:       docker-pullable://nginx@sha256:71f04b5caf2f921f4f0752b036be5a2d005f22c10e946fde6b2aa22676579d66</span><br><span class="line">    Port:           80/TCP</span><br><span class="line">    Host Port:      0/TCP</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Sat, 20 Jul 2019 13:46:26 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /usr/share/nginx/html from nginx-vol (rw)</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-6nvp9 (ro)</span><br><span class="line">......</span><br><span class="line">Volumes:</span><br><span class="line">  nginx-vol:</span><br><span class="line">    Type:          HostPath (bare host directory volume)</span><br><span class="line">    Path:          /var/data</span><br><span class="line">    HostPathType:  </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>到这里，还可以使用kubectl exec指令进入到Pod中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl exec -it nginx-deployment-7bffbd4747-kz8qt  sh</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">#  ls /usr/nginx/share/html</span><br></pre></td></tr></table></figure>
<p>最后，如果需要从集群中删除这个nginx-deployment的话，执行kubectl delete指令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete -f nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">deployment.apps &quot;nginx-deployment&quot; deleted</span><br></pre></td></tr></table></figure>
<h3 id="制作image-sign的Deployment"><a href="#制作image-sign的Deployment" class="headerlink" title="制作image-sign的Deployment"></a>制作image-sign的Deployment</h3><p>在有了上述知识后，我决定将之前在alpine镜像安装字体库使用到的image-sign制作为一个deployment。（可以使用docker pull hoppou/image-sign 从dockerhub拉取这个镜像呢，另外记得改镜像名称~）<br>编写如下yaml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: image-sign-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: image-sign</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: image-sign</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: image-sign</span><br><span class="line">        image: image-sign</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9466</span><br></pre></td></tr></table></figure>
<p>由于镜像功能极为简单，yaml的内容也很清晰，只需要将端口打开即可，运行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f image-sign-deployment.yaml </span><br><span class="line">...</span><br><span class="line">deployment.apps/image-sign-deployment created</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod -l app=image-sign</span><br><span class="line">NAME                                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">image-sign-deployment-59948dd446-8n8l7   1/1     Running   0          16s</span><br><span class="line">image-sign-deployment-59948dd446-fsbdj   1/1     Running   0          16s</span><br></pre></td></tr></table></figure>
<p>查看其中一个pod的相关属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe pod image-sign-deployment-59948dd446-8n8l7</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Node:           node2/192.168.110.131</span><br><span class="line"></span><br><span class="line">Status:         Running</span><br><span class="line">IP:             10.244.1.40</span><br><span class="line"></span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  108s  default-scheduler  Successfully assigned default/image-sign-deployment-59948dd446-8n8l7 to node2</span><br><span class="line">  Normal  Pulled     107s  kubelet, node2     Container image &quot;image-sign&quot; already present on machine</span><br><span class="line">  Normal  Created    107s  kubelet, node2     Created container image-sign</span><br><span class="line">  Normal  Started    106s  kubelet, node2     Started container image-sign</span><br></pre></td></tr></table></figure>
<p>可以看到IP信息为10.244.1.40，接下来使用postman进行测试：<br><img src="/images/image-sign-test.png" alt="image"></p>
<h2 id="大功告成！！！ヽ-・∀・-ノ"><a href="#大功告成！！！ヽ-・∀・-ノ" class="headerlink" title="大功告成！！！ヽ(・∀・)ノ"></a>大功告成！！！ヽ(・∀・)ノ</h2><h3 id="Tips补充"><a href="#Tips补充" class="headerlink" title="Tips补充"></a>Tips补充</h3><p>在kubernetes中拉取镜像有如下三种策略，可以通过imagePullPolicy进行设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Never                          ---- 从不拉取，只使用已有镜像</span><br><span class="line">Always                         ---- 总是拉取 </span><br><span class="line">IfNotPresent                   ---- 当本地不存在时拉取</span><br></pre></td></tr></table></figure>
<p>目前版本的kubernetes默认使用的是IfNotPresent，但在没有标明镜像的tag时，如 image: nginx 这种写法会采用Always的方式进行拉取。</p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2019/04/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h3><p>线程池是并发场景中比较常见的运用，几乎所有的异步或并发执行任务的程序都可以使用线程池。在开发中使用线程池能带来以下好处。</p>
<ol>
<li><strong>降低资源消耗</strong>。重复利用已创建的线程，降低线程创建和销毁造成的消耗。  </li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不用等待线程的创建，直接执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，不会无限制地创建。不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。<a id="more"></a>
<h3 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h3>线程池的创建依赖于 <code>ThreadPoolExecutor</code>，它的构造函数如下所示：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize, <span class="comment">//核心线程数量</span></span><br><span class="line">             int maximumPoolSize, <span class="comment">//最大线程数</span></span><br><span class="line">             long keepAliveTime, <span class="comment">//超时时间,超出核心线程数量以外的线程空余存活时间</span></span><br><span class="line">             TimeUnit unit, <span class="comment">//存活时间单位</span></span><br><span class="line">             BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">//保存执行任务的队列</span></span><br><span class="line">           ThreadFactory threadFactory,<span class="comment">//创建新线程使用的工厂</span></span><br><span class="line">RejectedExecutionHandler handler <span class="comment">//当任务无法执行的时候的处理方式</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">    threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>创建线程池所需要的参数:</p>
<ol>
<li><code>corePoolSize</code> (核心线程数量): 当提交一个任务到线程池中，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行任务也会创建新的线程，直到池中的线程数达到 <code>corePoolSize</code> 的大小就不再创建。</li>
<li><code>workQueue</code> (工作/任务队列)：用于保存等待执行的任务的阻塞队列。</li>
<li><code>maximumPoolSize</code> (最大线程数): 线程池所允许创建的最大线程数量，如果工作队列满了，并且已创建的的线程数小于最大线程数，此时线程池会临时创建新的线程执行任务。</li>
<li><code>keepAliveTime</code>（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间，超过时间会被回收。</li>
<li><code>unit</code>: 线程保持活动时间的单位。</li>
<li><code>threadFactory</code>: 用于设置创建线程的工厂。</li>
<li><code>handler</code> (饱和处理器)：当工作队列为有界队列，并且池中的线程数量已经达到了最大线程数，此时新提交的任务就会由 <code>handler</code> 进行饱和处理，抛出异常。</li>
</ol>
<p>当提交一个新任务到线程池中，线程池的处理流程如下：</p>
<ol>
<li>判断线程是否已经达到核心线程数，如果当前池中线程数少于核心线程数，创建一个新线程，否则进入下一个流程。</li>
<li>判断工作队列是否已满，如果未满，则将任务放入队列中，如果队列已满，则进行下一个流程。</li>
<li>判断当前池中线程数是否已达到最大线程数，如果未达到，则创建新的线程并执行任务，如果已达到最大线程数，则任务会被拒绝。</li>
<li>当其他的线程执行完任务时，会进入空闲状态，如果队列中有任务，会取出来执行，当队列为空之后，超过空闲存活时间的队列会被回收。<br>流程图：<br><img src="/images/2019-04-23.png" alt="Alt"><br><img src="/images/2019-04-23-1.png" alt="Alt"></li>
</ol>
<p><strong>execute方法流程分析</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">void</span> execute(Runnable command) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    int c = ctl.get();  </span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<span class="comment">//1.当前池中线程比核心数少，新建一个线程执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        c = ctl.get();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">//2.核心池已满，但任务队列未满，添加到队列中  </span></span><br><span class="line">        int recheck = ctl.get();  </span><br><span class="line">        <span class="comment">//任务成功添加到队列以后，再次检查是否需要添加新的线程，因为已存在的线程可能被销毁了</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))  </span><br><span class="line">            reject(command); <span class="comment">//如果线程池处于非运行状态，并且把当前的任务从任务队列中移除成功，则拒绝该任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)  </span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);<span class="comment">//如果之前的线程已被销毁完，新建一个线程</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))  <span class="comment">//3.核心池已满，队列已满，试着创建一个新线程</span></span><br><span class="line">        reject(command);  <span class="comment">//如果创建新线程失败了，说明线程池被关闭或者线程池完全满了，拒绝任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="submit和execute的区别"><a href="#submit和execute的区别" class="headerlink" title="submit和execute的区别"></a>submit和execute的区别</h3><p>向一个线程池提交任务，可以使用 <code>submit</code> 和 <code>execute</code>，这两者有什么区别呢？</p>
<ul>
<li><p><code>execute</code> 只能接受 <code>Runnable</code> 类型的任务，<code>execute</code> 没有返回值</p>
</li>
<li><p><code>submit</code> 不管是 <code>Runnable</code> 还是 <code>Callable</code> 类型的任务都可以接受，但是 <strong>Runnable返回值均为void</strong>，所以使用 <code>Future</code> 的 <code>get()</code> 获得的还是 <code>null</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>深入java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义分词器</title>
    <url>/2021/05/22/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E8%AF%8D%E5%99%A8/</url>
    <content><![CDATA[<h2 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h2><p>分词器是对一串语句进行词语分割处理的组件，它由三个部分组成：</p>
<ul>
<li><code>char_filter</code>（针对原始文本处理，如去掉某些符号、处理 <code>html</code> 等）</li>
<li><code>tokenizer</code> 按照规则，将上一步处理后的语句切分为单词</li>
<li><code>token filter</code> 将切分后的单词进行加工（如转为小写、去除停用词增加同义词等等）</li>
</ul>
<p>分词的流程也是严格按照 <code>char_filter</code> ——&gt; <code>tokenizer</code>——&gt; <code>filter</code> 这样的顺序进行的。。</p>
<h3 id="1-让-king’s-和-kings-有相同评分"><a href="#1-让-king’s-和-kings-有相同评分" class="headerlink" title="1.让 king’s 和 kings 有相同评分"></a>1.让 king’s 和 kings 有相同评分</h3><a id="more"></a>
<p>方式一：通过 <code>char_filter</code> 过滤掉 ‘ 符号<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE my_index</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;analysis&quot;:&#123;</span><br><span class="line">            &quot;analyzer&quot;:&#123;</span><br><span class="line">               &quot;my_custom_analyzer&quot;:&#123;</span><br><span class="line">                   &quot;type&quot;:&quot;custom&quot;,</span><br><span class="line">                   &quot;char_filter&quot;:&quot;my_char_filter&quot;,</span><br><span class="line">                   &quot;tokenizer&quot;:&quot;standard&quot;</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;char_filter&quot;:&#123;</span><br><span class="line">                &quot;my_char_filter&quot;:&#123;</span><br><span class="line">                    &quot;type&quot;:&quot;mapping&quot;,</span><br><span class="line">                    &quot;mappings&quot;:[</span><br><span class="line">                    &quot;&apos; =&gt; &quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;analyzer&quot;:&quot;my_custom_analyzer&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;king&apos;s&quot;</span><br><span class="line">&#125;</span><br><span class="line">POST my_index/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;kings&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;king&apos;s&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;kings&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方式二：使用同义词 <code>synonym token filter</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE my_index</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;analysis&quot;:&#123;</span><br><span class="line">            &quot;analyzer&quot;:&#123;</span><br><span class="line">               &quot;my_custom_analyzer&quot;:&#123;</span><br><span class="line">                   &quot;type&quot;:&quot;custom&quot;,</span><br><span class="line">                   &quot;filter&quot;:&quot;my_token_filter&quot;,</span><br><span class="line">                   &quot;tokenizer&quot;:&quot;standard&quot;</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;my_token_filter&quot;:&#123;</span><br><span class="line">                    &quot;type&quot;:&quot;synonym&quot;,</span><br><span class="line">                    &quot;synonyms&quot;:[</span><br><span class="line">                      &quot;king&apos;s =&gt; kings&quot;</span><br><span class="line">                      ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;analyzer&quot;:&quot;my_custom_analyzer&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;king&apos;s&quot;</span><br><span class="line">&#125;</span><br><span class="line">POST my_index/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;kings&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;king&apos;s&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;kings&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-dog-amp-cat-与-dog-and-cat-的-match-phrase-查询得分相同"><a href="#2-dog-amp-cat-与-dog-and-cat-的-match-phrase-查询得分相同" class="headerlink" title="2. dog &amp; cat 与 dog and cat 的 match_phrase 查询得分相同"></a>2. dog &amp; cat 与 dog and cat 的 match_phrase 查询得分相同</h3><p>其实这个与上面的思路是类似的，要么使用 <code>char_filter</code> 将 <code>&amp;</code> 映射为 <code>and</code>；要么直接设置为同义词。</p>
<p><code>char_filter</code> 映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE my_index</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;analysis&quot;:&#123;</span><br><span class="line">            &quot;analyzer&quot;:&#123;</span><br><span class="line">               &quot;my_custom_analyzer&quot;:&#123;</span><br><span class="line">                   &quot;type&quot;:&quot;custom&quot;,</span><br><span class="line">                   &quot;char_filter&quot;:&quot;my_char_filter&quot;,</span><br><span class="line">                   &quot;tokenizer&quot;:&quot;standard&quot;</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;char_filter&quot;:&#123;</span><br><span class="line">                &quot;my_char_filter&quot;:&#123;</span><br><span class="line">                    &quot;type&quot;:&quot;mapping&quot;,</span><br><span class="line">                    &quot;mappings&quot;:[</span><br><span class="line">                    &quot;&amp; =&gt; and&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;analyzer&quot;:&quot;my_custom_analyzer&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;dog &amp; cat&quot;</span><br><span class="line">&#125;</span><br><span class="line">POST my_index/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;dog and cat&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;dog &amp; cat&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;dog and cat&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同义词:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE my_index</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;analysis&quot;:&#123;</span><br><span class="line">            &quot;analyzer&quot;:&#123;</span><br><span class="line">               &quot;my_custom_analyzer&quot;:&#123;</span><br><span class="line">                   &quot;type&quot;:&quot;custom&quot;,</span><br><span class="line">                   &quot;filter&quot;:&quot;my_token_filter&quot;,</span><br><span class="line">                   &quot;tokenizer&quot;:&quot;standard&quot;</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;my_token_filter&quot;:&#123;</span><br><span class="line">                    &quot;type&quot;:&quot;synonym&quot;,</span><br><span class="line">                    &quot;synonyms&quot;:[</span><br><span class="line">                      &quot;dog &amp; cat =&gt; dog and cat&quot;</span><br><span class="line">                      ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;analyzer&quot;:&quot;my_custom_analyzer&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;dog &amp; cat&quot;</span><br><span class="line">&#125;</span><br><span class="line">POST my_index/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;dog and cat&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;dog &amp; cat&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;dog and cat&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-给-oa-、oA-、OA、Oa，dingding-设置查询得分相同"><a href="#3-给-oa-、oA-、OA、Oa，dingding-设置查询得分相同" class="headerlink" title="3. 给 oa 、oA 、OA、Oa，dingding 设置查询得分相同"></a>3. 给 oa 、oA 、OA、Oa，dingding 设置查询得分相同</h3><p>还是考察同义词的使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE my_index</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;analysis&quot;:&#123;</span><br><span class="line">            &quot;analyzer&quot;:&#123;</span><br><span class="line">               &quot;my_custom_analyzer&quot;:&#123;</span><br><span class="line">                   &quot;type&quot;:&quot;custom&quot;,</span><br><span class="line">                   &quot;filter&quot;:&quot;my_token_filter&quot;,</span><br><span class="line">                   &quot;tokenizer&quot;:&quot;standard&quot;</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;my_token_filter&quot;:&#123;</span><br><span class="line">                    &quot;type&quot;:&quot;synonym&quot;,</span><br><span class="line">                    &quot;synonyms&quot;:[</span><br><span class="line">                      &quot;oa,oA,OA,Oa,dingding&quot;</span><br><span class="line">                      ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;analyzer&quot;:&quot;my_custom_analyzer&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;dog &amp; cat&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-去除无用字符"><a href="#4-去除无用字符" class="headerlink" title="4.去除无用字符"></a>4.去除无用字符</h3><p>这是我实际遇到的一个问题，应用中采用的是外部分词器，<code>ES</code> 只存储拆分好的 <code>token</code> ,但分词接口返回的目前是个字符串，格式类似于 “ [‘张三’,’李四’,’新冠肺炎’,’感染者’]” 这样的。分词只取中文且不再此基础上进行分割。所以采用了如下方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE my_index</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;analysis&quot;:&#123;</span><br><span class="line">            &quot;analyzer&quot;:&#123;</span><br><span class="line">                &quot;my_custom_analyzer&quot;:&#123;</span><br><span class="line">                    &quot;type&quot;:&quot;custom&quot;,</span><br><span class="line">                    &quot;char_filter&quot;:&quot;my_char_filter&quot;,</span><br><span class="line">                    &quot;tokenizer&quot;:&quot;my_tokenizer&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;tokenizer&quot;:&#123;</span><br><span class="line">              &quot;my_tokenizer&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;pattern&quot;,</span><br><span class="line">                &quot;pattern&quot;:&quot;,&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;char_filter&quot;:&#123;</span><br><span class="line">                &quot;my_char_filter&quot;:&#123;</span><br><span class="line">                    &quot;type&quot;:&quot;mapping&quot;,</span><br><span class="line">                    &quot;mappings&quot;:[</span><br><span class="line">                    &quot;[ =&gt; &quot;,</span><br><span class="line">                    &quot;] =&gt; &quot;,</span><br><span class="line">                    &quot;&apos; =&gt; &quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;analyzer&quot;:&quot;my_custom_analyzer&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;my_custom_analyzer&quot;,</span><br><span class="line">  &quot;text&quot;: &quot; [&apos;张三&apos;,&apos;李四&apos;,&apos;新冠肺炎&apos;,&apos;感染者&apos;]&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-限制中文分词长度，单个的字不需要"><a href="#5-限制中文分词长度，单个的字不需要" class="headerlink" title="5.限制中文分词长度，单个的字不需要"></a>5.限制中文分词长度，单个的字不需要</h3><p>解决方式如下，但需要谨慎使用，会引起查询精准度问题，如果分词本身只能分词单个词，使用该过滤器后，将会查询不到结果集。</p>
<p>对比验证两个分词器的结果即可！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE my_index</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;analysis&quot;:&#123;</span><br><span class="line">            &quot;analyzer&quot;:&#123;</span><br><span class="line">                &quot;my_custom_analyzer&quot;:&#123;</span><br><span class="line">                    &quot;type&quot;:&quot;custom&quot;,</span><br><span class="line">                    &quot;tokenizer&quot;:&quot;ik_max_word&quot;,</span><br><span class="line">                    &quot;filter&quot;:&quot;my_filter&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">              &quot;my_filter&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;length&quot;,</span><br><span class="line">                &quot;min&quot;:&quot;2&quot;,</span><br><span class="line">                &quot;max&quot;:&quot;2&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;analyzer&quot;:&quot;my_custom_analyzer&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;my_custom_analyzer&quot;,</span><br><span class="line">  &quot;text&quot;: &quot; 我在人民广场吃炸鸡，喝啤酒，好生快乐&quot;</span><br><span class="line">&#125;</span><br><span class="line">GET my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;: &quot; 我在人民广场吃炸鸡，喝啤酒，好生快乐&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/202105/保罗-班扬.jpg" alt="保罗-班扬.jpg"></p>
]]></content>
      <categories>
        <category>学习打卡</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>认证题目记录</title>
    <url>/2021/06/20/%E8%AE%A4%E8%AF%81%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>微屁恩选的是迷雾通，下午两点考的，延迟忽高忽低期间在台中和新加坡节点切换了一次，掉线了 <code>3</code> 次。。。好在重连都挺快的。共 <code>10</code> 题，分为三个集群，<code>cluster1</code> 为三节点，<code>cluster2</code>、<code>cluster3</code> 为单节点：</p>
<p>集群中的每个机器都是使用 <code>elastic</code> 用户登录，不需要密码。不需要担心权限，启动配置等问题。<a id="more"></a></p>
<ol>
<li><p>集群 <code>cluster1</code> （未启动，<code>node1 node2 node3</code>）上有两个索引 <code>logs_new</code> 和 <code>logs_old</code> 。（我查看了索引的属性，都为 <code>3</code> 个主分片，<code>1</code> 个副本）。要求启动集群，并且在不删除索引的情况下达到以下要求：</p>
<ul>
<li><p><code>logs_new</code> 的分片只分布在 <code>node1</code> 上。</p>
</li>
<li><p><code>logs_old</code> 的分片分布在 <code>node2</code>，<code>node3</code> 上。</p>
</li>
<li><p>保持集群状态为 <code>green</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT logs_new/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;number_of_replicas&quot;: 0,</span><br><span class="line">  &quot;index.routing.allocation.require._name&quot;:&quot;node1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT logs_old/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;index.routing.allocation.exclued._name&quot;:&quot;node1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>cluster2</code> 上有索引 <code>movie_data</code> ，搜索（ <code>title</code> 字段） <code>waynes</code> 和 <code>wayne&#39;s</code> 的结果不同（），要求将 <code>movie_data</code> 的数据 <code>reIndex</code> 到 新索引上，并满足以下要求：</p>
<ul>
<li><p>新索引名为  <code>task2</code></p>
</li>
<li><p>搜索 （<code>title</code> 字段） <code>waynes</code> 和 <code>wayne&#39;s</code> 的相关性得分相同。样例说明中还提到了 <code>kings</code> 和 <code>king‘s</code> 等带有撇号的单词。所以这里我认为只能使用 <code>char_filter</code> 来进行映射。<code>synonym</code> 不太符合题意</p>
</li>
<li><p><code>task2</code> 的字段属性需要和 <code>movie_data</code> 保持一致（具体属性记不清，使用 <code>GET movie_data/_mapping</code> 将属性抄过来即可。只需给 <code>title</code> 字段添加上自己定义的分词器即可）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT task2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;number_of_replicas&quot;: 0,</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;analysis&quot;: &#123;</span><br><span class="line">      &quot;analyzer&quot;: &#123;</span><br><span class="line">        &quot;my_custom_analyzer&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;custom&quot;,</span><br><span class="line">          &quot;char_filter&quot;: &quot;my_char_filter&quot;,</span><br><span class="line">          &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">          &quot;filter&quot;: [</span><br><span class="line">            &quot;lowercase&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;char_filter&quot;: &#123;</span><br><span class="line">        &quot;my_char_filter&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;mapping&quot;,</span><br><span class="line">          &quot;mappings&quot;: [</span><br><span class="line">            &quot;&apos; =&gt; &quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;my_custom_analyzer&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>cluster2</code> 上 的 <code>nested</code> 查询，给了一个数组字段，要求创建索引 <code>task3</code>，同样的数据，搜索时不应该返回结果，只提供 <code>json</code> 。</p>
</li>
<li><code>inspections multi_match</code> 。检索 某个索引的 <code>3</code> 个字段，要求其中一个的算分 <code>boost</code> 为 <code>2</code> 。得分为三个字段的和（<code>most_fields</code>），只提供 <code>json</code></li>
<li><code>update_by_query</code>，字段为 <code>4</code> 个字段的拼接，题目没有说加空格。但是展示的案例中是有空格的。</li>
<li><code>dynamic_template</code> 将 <code>x_</code> 开头的映射为 <code>integer</code> ，<code>string</code> 类型的映射为 <code>keyword</code> 。</li>
<li>聚合，地震那题，但是改动了下，要求返回每个月的最大震级和最大深度，一个 <code>date_histogram</code> ，子聚合两个 <code>max</code> 就搞定了，只提供 <code>json</code></li>
<li>备份与恢复，在 <code>cluster2</code> 上指定的目录下创建备份。按照给定的仓库名、备份名称进行创建。只要求备份 <code>movie_data</code> 索引</li>
<li>集群 <code>RBAC</code> ，在 <code>cluster3</code> 上配置，<code>elastic</code> 和 <code>kibana</code> 的用户密码都为 <code>password</code>。创建用户 <code>susan</code>，<code>Full_name</code> 为 <code>Susan</code>，邮箱为 <a href="mailto:**certification@elastic.co" target="_blank" rel="noopener">**certification@elastic.co</a>**，给 <code>susan</code> 赋予 <code>kibana_user</code> 的权限。（做这题的时候很奇怪。。我配好之后，用 <code>elastic</code> 登录进去，发现每次不到 <code>2</code> 分钟就会自动退出。我加用户还没点确定，登录状态就已经失效了。。。）</li>
<li>普通查询，对 <code>movie_data</code> 进行 <code>match_phrase</code> 查询， 指定字段高亮 + 排序</li>
</ol>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>走近分布式协调服务--zookeeper</title>
    <url>/2019/11/03/%E8%B5%B0%E8%BF%91%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1--zookeeper/</url>
    <content><![CDATA[<h3 id="分布式环境的特点"><a href="#分布式环境的特点" class="headerlink" title="分布式环境的特点"></a>分布式环境的特点</h3><ul>
<li>并发性，程序运行过程中，并发性操作是很常见的。比如同一个分布式系统中的多个节点，同时访问一个共享资源、数据库等。</li>
<li>分布性</li>
<li>无序性</li>
</ul>
<h3 id="分布式环境下面临的问题"><a href="#分布式环境下面临的问题" class="headerlink" title="分布式环境下面临的问题"></a>分布式环境下面临的问题</h3><p><strong>网络通信</strong><br>网络本身的不可靠性，因此会涉及到一些网络通信问题。  <a id="more"></a></p>
<p><strong>分区容错</strong><br>当网络发生异常导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式架构的所有节点，只有部分节点能够正常通信。</p>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>C一致性：所有节点上的数据时刻保持一致。</p>
<p>A可用性：每次请求都能收到响应，不管结果成功或失败。</p>
<p>P分区容错性。<a href="https://note.youdao.com/" target="_blank" rel="noopener">cap介绍</a></p>
<p>由于这三个指标不可能同时做到,在分区容错性是必须的情况下，只能选择取舍CP或AP其中一种。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(CAP理论仅适用于原子读写的Nosql场景，不适用于数据库系统？</span><br><span class="line">因为如果出现更新失败导致数据丢失的情况，无法恢复)</span><br></pre></td></tr></table></figure>
<p><code>zookeeper</code>是CP理论的一种典型。</p>
<p><img src="/images/zookeeper/cap.png" alt="image"></p>
<h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p><code>ebay</code>提出的<code>BASE</code>理论，放宽了对事务的<code>ACID</code>要求。保证基本可用。软状态。保证数据的最终一致性。  (兼顾可用性和一致性)</p>
<p><code>Basically available</code> ：基本可用。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1～2秒。</p>
<p><code>soft-state</code>： 软状态。即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<p><code>Eventually Consistent</code>：最终一致性。</p>
<h3 id="zookeeper是什么"><a href="#zookeeper是什么" class="headerlink" title="zookeeper是什么"></a>zookeeper是什么</h3><p><code>zookeeper</code>是一个开源的分布式协调服务，是由雅虎创建的，基于<code>google chubby</code>。 是分布式数据一致性的一种解决方案。 </p>
<h3 id="zookeeper能做什么"><a href="#zookeeper能做什么" class="headerlink" title="zookeeper能做什么"></a>zookeeper能做什么</h3><p>数据的发布/订阅（配置中心:<code>disconf</code>）  、 负载均衡（<code>dubbo</code>利用了<code>zookeeper</code>机制实现负载均衡） 、命名服务、<br><code>master</code>选举(<code>kafka</code>、<code>hadoop</code>、<code>hbase</code>)、分布式队列、分布式锁。</p>
<ul>
<li>顺序一致性：从同一个客户端发起的事务请求，最终会严格按照顺序被应用到<code>zookeeper</code>中</li>
<li>原子性：所有的事务请求的处理结果在整个集群中的所有机器上的应用情况是一致的，也就是说，要么整个集群中的所有机器都成功应用了某一事务、要么全都不应用。</li>
<li>可靠性：一旦服务器成功应用了某一个事务数据，并且对客户端做了响应，那么这个数据在整个集群中一定是同步并且保留下来的。</li>
<li>实时性：一旦一个事务被成功应用，客户端就能够立即从服务器端读取到事务变更后的最新数据状态；（<code>zookeeper</code>仅仅保证在一定时间内，近实时）</li>
</ul>
<h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p><code>zookeeper</code>的数据模型和文件系统类似，每一个节点称为：<code>znode</code>.  是<code>zookeeper</code>中的最小数据单元。每一个<code>znode</code>上都可以保存数据和挂载子节点。从而构成一个层次化的属性结构。  </p>
<p>节点特性  </p>
<ul>
<li>持久化节点 ：节点创建后会一直存在<code>zookeeper</code>服务器上，直到主动删除。</li>
<li>持久化有序节点：每个节点都会为它的一级子节点维护一个顺序。</li>
<li>临时节点 ：临时节点的生命周期和客户端的会话保持一致。当客户端会话失效，该节点自动清理。</li>
<li>临时有序节点：在临时节点上多勒一个顺序性特性。</li>
</ul>
<h3 id="zookeeper集群"><a href="#zookeeper集群" class="headerlink" title="zookeeper集群"></a>zookeeper集群</h3><p><code>zookeeper</code>集群, 包含三种角色: <code>leader</code> / <code>follower</code> /<code>observer</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在datadir添加一个myid，配置server.myid=ip:port1:port2</span><br><span class="line">#添加observer节点的时候需要在zoo.cfg中增加peerType=observer</span><br><span class="line"></span><br><span class="line">server.0=192.168.11.128:2888:3888</span><br><span class="line">server.1=192.168.11.129:2888:3888</span><br><span class="line">server.2=192.168.11.130:2888:3888</span><br><span class="line">server.3=192.168.11.131:2888:3888:observer</span><br></pre></td></tr></table></figure>
<p>其中，3888用于<code>leader</code>选举。2888为节点间通信端口。</p>
<p><code>observer</code>节点比较特殊，用于提升<code>zookeeper</code>集群的扩展性。因为随着连接的<code>client</code>增多，<code>server</code>的集群也必须扩大，而zk集群选举需要半数以上机器投票通过，代价较大。<code>observer</code>不参与投票只接收投票结果。可以做到在不影响写性能的情况下去扩展zk。</p>
<h3 id="zookeeper配置文件"><a href="#zookeeper配置文件" class="headerlink" title="zookeeper配置文件"></a>zookeeper配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime=2000  zookeeper中最小的时间单位长度 （ms）</span><br><span class="line"></span><br><span class="line">initLimit=10  follower节点启动后与leader节点完成数据同步的时间</span><br><span class="line"></span><br><span class="line">syncLimit=5 leader节点和follower节点进行心跳检测的最大延时时间</span><br><span class="line"></span><br><span class="line">dataDir=/tmp/zookeeper  表示zookeeper服务器存储快照文件的目录</span><br><span class="line"></span><br><span class="line">dataLogDir 表示配置 zookeeper事务日志的存储路径，默认指定在dataDir目录下</span><br><span class="line"></span><br><span class="line">clientPort 表示客户端和服务端建立连接的端口号： 2181</span><br></pre></td></tr></table></figure>
<h3 id="zookeeper的客户端使用"><a href="#zookeeper的客户端使用" class="headerlink" title="zookeeper的客户端使用"></a>zookeeper的客户端使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用help查看命令</span><br><span class="line">  </span><br><span class="line">1. create [-s] [-e] path data acl</span><br><span class="line">-s 表示节点是否有序</span><br><span class="line">-e 表示是否为临时节点</span><br><span class="line">默认情况下，是持久化节点，且无序</span><br><span class="line"></span><br><span class="line">2. get path [watch]</span><br><span class="line">获得指定 path的信息</span><br><span class="line"></span><br><span class="line">3.set path data [version]</span><br><span class="line">修改节点 path对应的data</span><br><span class="line"></span><br><span class="line">4.delete path [version]</span><br><span class="line">删除节点</span><br><span class="line"></span><br><span class="line">5.deleteall path </span><br><span class="line">delete不能删除有子节点的节点。deleteall可以(rmr命令已过时)。</span><br></pre></td></tr></table></figure>
<p><strong>Watcher</strong></p>
<p><strong>zookeeper提供了分布式数据发布/订阅</strong>,<code>zookeeper</code>允许客户端向服务器注册一个<code>watcher</code>监听。当服务器端的节点触发指定事件的时候会触发<code>watcher</code>。服务端会向客户端发送一个事件通知</p>
<p><strong>watcher的通知是一次性，一旦触发一次通知后，该watcher就失效</strong>.</p>
<p><strong>ACL</strong></p>
<p><code>zookeeper</code>提供控制节点访问权限的功能，用于有效的保证<code>zookeeper</code>中数据的安全性。避免误操作而导致系统出现重大事故。<br>CREATE/READ/WRITE/DELETE/ADMIN</p>
<p><code>ZooKeeper</code> 的权限管理通过<code>Server</code>、<code>Client</code> 两端协调完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) Server端</span><br><span class="line"></span><br><span class="line">一个ZooKeeper 的节点存储两部分内容：数据和状态，状态中包含ACL 信息。创建一个znode 会产生一个ACL 列表，列表中每个ACL 包括：</span><br><span class="line">① 权限perms</span><br><span class="line">② 验证模式schema</span><br><span class="line">③ 具体内容expression：Ids</span><br><span class="line">例如，当scheme=&quot;digest&quot; 时， Ids 为用户名密码， 即&quot;root ：J0sTy9BCUKubtK1y8pkbL7qoxSw&quot;。ZooKeeper 提供了如下几种验证模式：</span><br><span class="line"></span><br><span class="line">① Digest： Client 端由用户名和密码验证，譬如user:pwd</span><br><span class="line"></span><br><span class="line">② Host： Client 端由主机名验证，譬如localhost</span><br><span class="line"></span><br><span class="line">③ Ip：Client 端由IP 地址验证，譬如172.2.0.0/24</span><br><span class="line"></span><br><span class="line">④ World ：固定用户为anyone，为所有Client 端开放权限</span><br><span class="line"></span><br><span class="line">当会话建立的时候，客户端将会进行自我验证。</span><br><span class="line"></span><br><span class="line">权限许可集合如下：</span><br><span class="line"></span><br><span class="line">① Create 允许对子节点Create 操作</span><br><span class="line"></span><br><span class="line">② Read 允许对本节点GetChildren 和GetData 操作</span><br><span class="line"></span><br><span class="line">③ Write 允许对本节点SetData 操作</span><br><span class="line"></span><br><span class="line">④ Delete 允许对子节点Delete 操作</span><br><span class="line"></span><br><span class="line">⑤ Admin 允许对本节点setAcl 操作</span><br></pre></td></tr></table></figure>
<h3 id="javaapi"><a href="#javaapi" class="headerlink" title="javaapi"></a>javaapi</h3><ul>
<li>原生api</li>
<li>zkclient</li>
<li>curator</li>
</ul>
<p><strong>api的使用细节之后详细记录</strong></p>
<h3 id="实现数据发布订阅-配置中心"><a href="#实现数据发布订阅-配置中心" class="headerlink" title="实现数据发布订阅/ 配置中心"></a>实现数据发布订阅/ 配置中心</h3><p>实现配置信息的集中式管理和数据的动态更新</p>
<p>实现配置中心有两种模式：<code>push</code> 、<code>pull</code>。(文件的推和拉)</p>
<p><code>zookeeper</code>采用的是推拉相结合的方式。 客户端向服务器端注册自己需要关注的节点。一旦节点数据发生变化，那么服务器端就会向客户端发送<code>watcher</code>事件通知。客户端收到通知后，主动到服务器端获取更新后的数据。<br><img src="/images/zookeeper/zk1.png" alt="image"></p>
<p>适用情况特征：</p>
<ol>
<li>数据量比较小</li>
<li>数据内容在运行时会发生动态变更</li>
<li>集群中的各个机器共享配置</li>
</ol>
<h3 id="实现集群管理"><a href="#实现集群管理" class="headerlink" title="实现集群管理"></a>实现集群管理</h3><p>实现集群管理，首先所有服务器在启动时向<code>zookeeper</code>中指定节点下，注册自己(创建临时节点)。基于临时节点和<code>watcher</code>机制的特性，当有节点创建成功时，会发送一个通知节点上线。节点意外宕机时，也会发出通知。<br><img src="/images/zookeeper/zk2.png" alt="image"></p>
<h3 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h3><p>分布式锁的原理也是同样，当服务想要获取锁时，在<code>zookeeper</code>中有指定的持久节点，需要获取锁的线程需要到改节点下去创建临时有序节点，这样在zk中，节点创建成功，并且在所有子节点中排序为最小的那个线程成功获得锁。没有拿到锁的线程改为监控比自己节点小1的节点，当任务执行完毕，临时节点会被删除，此时触发watcher机制。通知下一个线程获取锁。</p>
<p>实现独占锁的机制也类似，所有节点都去创建子节点，创建成功者获得锁，其余等待。<br><img src="/images/zookeeper/zk3.png" alt="image"></p>
<h3 id="实现分布式队列"><a href="#实现分布式队列" class="headerlink" title="实现分布式队列"></a>实现分布式队列</h3><p>分布式队列可以在zk中维护一个持久节点，节点下存一个<code>data</code>值为队列的容纳数量。当程序入队时，在该节点下创建子节点，当子节点个数达到父节点下的<code>data</code>设置个数时，表示队列满。无节点时表示队列空。每当出队时删除对应的节点。</p>
<p><img src="/images/zookeeper/zk4.png" alt="image"></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
</search>
