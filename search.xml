<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker-alpine镜像安装字体库]]></title>
    <url>%2F2019%2F07%2F07%2Fdocker-alpine%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[记录下前不久在制作镜像时踩的一个坑。（镜像的主要功能是，发送一个图片地址和中文名称。然后将微软雅黑字体作为签字写到图片上并返回。） openjdk与oraclejdk为了减小镜像的大小，我使用了alpine镜像。开始我的dockerfile如下：12345FROM java:8-alpineUSER rootRUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeCOPY target/image-sign.jar image-sign.jarENTRYPOINT ["java","-jar","image-sign.jar"] 使用docker build时候成功的制作了镜像。诶？好像看起来没什么问题啊？docker run启动容器。然后访问接口：空指针？程序不是好好的么。怎么放到镜像就出现这个问题了。仔细一查，发现是因为openjdk的原因,openjdk是开源的，在oracle接手之后，两者的内容已经有些区别了。From java:8-alpine这一句，下载的是openjdk8，而我需要的是oraclejdk8.于是换成了FROM anapsix/alpine-java之后就ok了 linux字体库的锅修改为oraclejdk后，镜像能够正常运行了，但是,我转入的中文却不能正常显示:此时在网上翻阅到的是说缺少字体。但linux下是没有微软雅黑、宋体这些字体的。但我按照他们的方式却怎么也安装不成功,最后找到的解决办法如下：1.将windows下的字体找到，复制出来。宋体为simsun.ttc,需要改后缀名为ttf，微软雅黑为msyf.tff。2.编辑dockerfile为如下即可：12345678910FROM anapsix/alpine-javaRUN echo "http://mirror.math.princeton.edu/pub/alpinelinux/v3.8/main" &gt; /etc/apk/repositories \ &amp;&amp; echo "http://mirror.math.princeton.edu/pub/alpinelinux/v3.8/community" &gt;&gt; /etc/apk/repositories \ &amp;&amp; apk add ttf-dejavu fontconfig \ &amp;&amp; rm -rf /var/cache/apk/* \ &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \ &amp;&amp; echo "Asia/Shanghai" &gt; /etc/timezone COPY target/image-sign.jar image-sign.jarCOPY ttf/* /usr/share/fonts/ENTRYPOINT ["java","-jar","image-sign.jar"] 这里做下解释，apk是alpine系统的安装工具，类似centos的yum与ubuntu系统的apt-get，前两句echo是更改apk安装的镜像地址，不清楚是资源的问题还是啥，在我没有改这个的时候。一直安装不成功。具体可见github的这个issues：apk WARNING Ignoring APKINDEX No such file or director 当然，这个办法也是在issue里找到的= =，github还是解决问题的好地方啊~，之后的apk add ttf-dejavu fontconfig是为容器安装字体库，同时删除安装包(减小镜像大小)。COPY ttf/* /usr/share/fonts/ 将从windows下拿到的字体文件放入docker镜像内，问题解决~]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式笔记(一)]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%AC%94%E8%AE%B0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[从单机应用war包，到多机部署产生的问题：1.session跨域 session sticky session replication session 集中存储（redis等） cookie 逆向思维，由客户端来存储 2.请求转发，如何平均的请求到每一台机器上(负载均衡) Apache Nginx （http负载均衡支持很好） haproxy （tcp/ip界的老牌负载均衡器） lvs (不支持虚拟化) 由数据库读写瓶颈锁带来的，从单体数据库到读写分离产生的问题 数据库读写分离如何操作（读写分离配置） 读与写之间如何同步 （同步不及时？一致性与可用性） 数据库操作如何路由，什么操作用读库，什么操作用写库（mycat） 数据量过大的情况，如何实现高效率搜索搜索引擎也带来一个问题，如何进行数据同步？数据增量？全量同步？集群健康？ Elasticsearch solr lucene 持续性大量访问，数据库无法承受带来的问题使用缓存(redis、memcache)，降低数据库的直接大量访问，缓存集群（缓存的雪崩、击穿、穿透、数据不一致）限流、降级、熔断（高可用的保护措施） 数据库瓶颈的再延伸——数据库集群的使用 mysql的pxc集群（高可用，强一致性），replication集群 随异步处理，解耦，削峰而产生的—-&gt;消息队列 rabbitmq kafka activemq rocketmq 前后端分离，静态文件—CDN服务器的使用 应用拆分——&gt;微服务 服务注册 负载均衡 RPC远程调用 配置中心 路由规则 链路追踪]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码分析之LinkedList]]></title>
    <url>%2F2019%2F05%2F11%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BLinkedList%2F</url>
    <content type="text"><![CDATA[在leetcode中遇到了一道设计链表的题，要求中有一点是不能使用内置的LinkedList库，于是在自己实现了简易版的链表之后，找到了内置的源码来做个分析。 可以自行选择实现单向或双向链表 原题链接。首先，LinkedList是个双向链表，每个数据结点中都有两个“指针”，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点（从百度百科找来的废话orz）。首先，来看看LinkedList的基础属性：12345678910111213141516171819202122232425public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; transient int size = 0; //节点个数 transient Node&lt;E&gt; first; //首节点 transient Node&lt;E&gt; last; //尾节点 public LinkedList() &#123; //初始化一个空的链表集合 &#125; public LinkedList(Collection&lt;? extends E&gt; c) &#123; //根据已有集合初始化 this(); addAll(c); //稍后分析addAll &#125; //内部类---节点 private static class Node&lt;E&gt; &#123; E item; //节点本身 Node&lt;E&gt; next; //前驱节点 Node&lt;E&gt; prev; //后继节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; &#125; 节点的添加1234567891011121314151617181920//默认的add会加到尾部public boolean add(E e) &#123; linkLast(e); return true; &#125;//指定位置添加public void add(int index, E element) &#123; checkPositionIndex(index); //检查节点是否存在 if (index == size) linkLast(element); //在节点尾部添加 else linkBefore(element, node(index)); //在指定节点前添加，node(index)会查询出位于index位置的节点&#125;public void addFirst(E e) &#123; linkFirst(e); &#125;public void addLast(E e) &#123; linkLast(e); &#125; 1.检查节点是否存在（方法很简单，判断了下size和index）:1234567private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) //isPositionIndex throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125;private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size; &#125; 2.在节点尾部/首部添加：12345678910111213141516171819202122232425//在首部添加节点，此方法为私有方法，实际使用时调用addFirstprivate void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; //将final类型的f节点指向首节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //新建节点 first = newNode; //将新节点变为首节点 if (f == null) last = newNode; //链表为空，此时first = last = newNode else f.prev = newNode; //将新节点加入到链表中 size++; //节点数+1 modCount++; //modCount表示更改次数，在遍历时才会用到&#125;//在尾部添加节点，此方法没有修饰符void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; linkFirst与linkLast类似，这里介绍简单说下linkFirst，首先将当前的首节点的引用赋值给f，然后新建一个Node节点，节点的next指向f，prev为null。将新节点变为首节点，同时判断f是否为空，如果f为空说明链表为空，此时新节点既为首节点也为尾节点，否则将f的prev指向新的节点。此时新节点就加到了链表中。3.在指定位置添加:123456789101112131415161718192021222324252627//先看下node(index)如何定位到节点Node&lt;E&gt; node(int index) &#123; //这里的移位操作size&gt;&gt;1其实就是size的一半，如果index小于size的一半，那么从前往后找，否则从后往前找，这样可以加快查找速度 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125;//在指定节点前添加void linkBefore(E e, Node&lt;E&gt; succ) &#123; final Node&lt;E&gt; pred = succ.prev; //拿到指定节点的前一个 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); //新的节点next指向succ，pre指向pred succ.prev = newNode; if (pred == null) first = newNode; //pred为空的话，表示succ为first，将first替换为newNode else pred.next = newNode; //否则pred的next指向newNode size++; modCount++; &#125; 构造方法addAll123456789101112131415161718192021222324252627282930313233343536373839404142public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); //传入当前size 和构造参数&#125;//在指定位置index的前方，添加多个节点public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; //需要添加的元素个数 if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; //位置等于size，即在链表末尾添加，否则在链表中间添加 succ = null; pred = last; &#125; else &#123; succ = node(index); //index处的节点 pred = succ.prev; //index的上一个节点 &#125; for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); //创建新节点 if (pred == null) first = newNode; //初始化第一个节点 else pred.next = newNode; //链接新节点 pred = newNode; &#125; if (succ == null) &#123; last = pred; //在尾部插入，那么循环结束后，pred就是尾节点 &#125; else &#123; pred.next = succ; //否则，需要将pred的next指向succ节点 succ.prev = pred; &#125; size += numNew; //修改节点个数 modCount++; return true; &#125; 节点的删除删除操作有多种方式，但都是基于unlink方法实现的，这里就简单写一种吧(偷懒ing):123456789101112131415161718192021222324252627282930public E remove(int index) &#123; checkElementIndex(index); //检查是否存在元素 return unlink(node(index)); //执行unlink&#125;//unlink操作E unlink(Node&lt;E&gt; x) &#123; final E element = x.item; //需要删除的节点赋给final的element常量 final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; //需要删除的节点为first，那么删除后它next变为first &#125; else &#123; prev.next = next; //前后节点相连，跳过当前节点 x.prev = null; //把需要删除节点的pre变为null &#125; if (next == null) &#123; last = prev; //需要删除的节点为last，删除后它的pre变为last &#125; else &#123; next.prev = prev; //前后节点相连，跳过当前节点 x.next = null; //把需要删除节点的next也变为null &#125; x.item = null; //将节点的item也变为null，帮助gc回收 size--; //节点数-1 modCount++; return element; //返回element&#125; 节点的查找12345//get方法还是调用的node(index)进行定位，返回节点的itempublic E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; 到这里，LinkedList的基础方法就分析完了，其余的高级方法诸如push、pop、peek、poll等等，都是基于这些基本方法完成的。（java中的栈是基于Vector实现的，每个方法都有Syncronized修饰，所以在1.5之后LinkedList添加了用于实现无锁栈的方法）123456789101112131415public void push(E e) &#123; addFirst(e); &#125;public E pop() &#123; return removeFirst(); &#125;//前两个为空会抛出异常，peek和poll不会public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125;public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); &#125; 补充： 在源码中可以看到transient和final关键字的使用，这里也把两者的作用记下。 transient的作用： 阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。 final关键字的一些总结： 1.对于一个变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能修改，如果是引用类型的变量，则在对其初始化之后便不能再让其指向另外一个对象。 2.当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会隐式地指定为final方法。 3.使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。类中所有的private方法都隐式地指定为final。在早期的java版本中，会将final方法转为内嵌调用。但如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现版本已经不需要使用final方法进行这些优化了）。 膜拜画师大大]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的live2d配置]]></title>
    <url>%2F2019%2F04%2F27%2F%E6%88%91%E7%9A%84live2d%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[给hexo加上live2d只能说是自己作为死宅的本能反应吧= =，在别人的网站上看过之后总是觉得羨ましい（羡慕的起码要死三次），然后到处找文章想给自己也加上，本来很简单的事情还用了大半天(I very vegetables) orz，这次把步骤写上来。也算做个备份吧，指不定那天忘了呢。 hexo的官方插件hexo的官方有提供名为hexo-helper-live2d的插件使用如下安装命令就可以安装 npm install –save hexo-helper-live2d 随后在Hexo的_config.yml文件中添加如下配置(据说是可以配在主题的_config.yml中的，但是我没试过呢orz).示例: 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko //启用的模型目录 display: position: right width: 150 height: 300 mobile: show: true 这样一个默认的模型就配好了，默认是这样的: 添加互动：默认的模型只有很简单的动画，在别人网站里看到的都是能互动对话的(再次羡慕的要死)，经过查阅找到了大佬的教程把萌萌哒的看板娘抱回家。 (到这里需要把之前配置文件中的live2d.enable修改为false)根据步骤来，jquery在主题中是已经存在的直接跳过，将项目下载下来，将autoload.js、 live2d.min.js、waifu-tips.js、waifu-tips.json、waifu.css这几个文件放入到next主题中/source/js/src目录下，也可以将json和css文件放到对于的目录下，但是需要改动下autoload中的路径，我这里偷懒直接放到一起了orz &lt;script src=&quot;/js/src/autoload.js&quot;&gt;&lt;/script&gt; 将上面这句放入到主题的/layout/_layout.swing中body标签的末尾，autoload.js的内容如下：123456789101112131415161718192021222324252627282930//开始加斜杠和不加是完全不同的路径,这里改为了我放置的相对路径const live2d_path = "/js/src/";//const live2d_path = "./";$("&lt;link&gt;").attr(&#123;href: live2d_path + "waifu.css", rel: "stylesheet", type: "text/css"&#125;).appendTo("head");//waifu.css的绝对路径$.ajax(&#123; url: live2d_path + "live2d.min.js", dataType: "script", cache: true, async: false&#125;);//live2d.min.js的绝对路径$.ajax(&#123; url: live2d_path + "waifu-tips.js", dataType: "script", cache: true, async: false&#125;);//waifu-tips.js的绝对路径//初始化看板娘，会自动加载指定目录下的waifu-tips.json$(window).on("load", function() &#123; initWidget(live2d_path + "waifu-tips.json", "https://live2d.fghrsh.net/api");&#125;);//initWidget第一个参数为waifu-tips.json的绝对路径//第二个参数为api地址（无需修改）//api后端可自行搭建，参考https://github.com/fghrsh/live2d_api 然后打开waifu-tips.js，在方法initWidget中将下面这句话移到方法的最前面，这样可以在关闭live2d后，刷新时重新加载。 localStorage.removeItem(&quot;waifu-display&quot;); 添加拖动上述操作完成之后确发现一个问题，模型不能拖动？？？了解到模型是在canvas中绘制的，于是编写了如下的拖动方法(放在了waifu-tips.js中)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 绘制图片坐标 var X=0; var Y=0;// js部分 var divObj=document.getElementById("waifu"); var moveFlag=false;//区别moueseup与click的标志 var clickFlag=false;// 拖拽函数 divObj.onmousedown=function(e)&#123; moveFlag=true; clickFlag=true; var clickEvent=window.event||e; var mwidth=clickEvent.clientX-divObj.offsetLeft; var mheight=clickEvent.clientY-divObj.offsetTop; document.onmousemove=function(e)&#123; clickFlag=false; var moveEvent=window.event||e; if(moveFlag)&#123; divObj.style.left=moveEvent.clientX-mwidth+"px"; divObj.style.top=moveEvent.clientY-mheight+"px";//// 将鼠标坐标传给Canvas中的图像 X=moveEvent.clientX-mwidth; Y=moveEvent.clientY-mheight;//// 下面四个条件为限制div以及图像的活动边界 if(moveEvent.clientX&lt;=mwidth)&#123; divObj.style.left=0+"px"; X=0; &#125; if(parseInt(divObj.style.left)+divObj.offsetWidth &gt;=innerWidth)&#123; divObj.style.left=innerWidth - divObj.offsetWidth+"px"; X=innerWidth - divObj.offsetWidth; &#125; if(moveEvent.clientY&lt;=mheight)&#123; divObj.style.top=0+"px"; Y=0; &#125; if(parseInt(divObj.style.top)+divObj.offsetHeight&gt;=innerHeight)&#123; divObj.style.top=innerHeight-divObj.offsetHeight+"px"; Y=innerHeight-divObj.offsetHeight; &#125; divObj.onmouseup=function()&#123; moveFlag=false; &#125; &#125; &#125; &#125;; tips： 在waifu-tips.js中waifu-tool里有几个写好的模块，可以自定义添加或删除，每个span对应一个功能initmodel方法里有默认的加载模型，可以将随机更换注释掉，选择喜欢的固定模型waifu-tips.json中包含了触发条件（选择器的事件）和触发时显示的文字，也可以自定义 我巴美如画]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>另一个次元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2019%2F04%2F22%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[为什么要使用线程池线程池是并发场景中比较常见的运用，几乎所有的异步或并发执行任务的程序都可以使用线程池。在开发中使用线程池能带来以下好处。 降低资源消耗。重复利用已创建的线程，降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不用等待线程的创建，直接执行。 提高线程的可管理性。线程是稀缺资源，不会无限制地创建。不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 线程池的工作原理线程池的创建依赖于ThreadPoolExecutor，它的构造函数如下所示：1234567891011public ThreadPoolExecutor(int corePoolSize, //核心线程数量 int maximumPoolSize, //最大线程数 long keepAliveTime, //超时时间,超出核心线程数量以外的线程空余存活时间 TimeUnit unit, //存活时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //保存执行任务的队列 ThreadFactory threadFactory,//创建新线程使用的工厂RejectedExecutionHandler handler //当任务无法执行的时候的处理方式) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);&#125; 创建线程池所需要的参数: corePoolSize(核心线程数量): 当提交一个任务到线程池中，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行任务也会创建新的线程，直到池中的线程数达到corePoolSize的大小就不再创建。 workQueue(工作/任务队列)：用于保存等待执行的任务的阻塞队列。 maximumPoolSize(最大线程数): 线程池所允许创建的最大线程数量，如果工作队列满了，并且已创建的的线程数小于最大线程数，此时线程池会临时创建新的线程执行任务。 keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间，超过时间会被回收。 unit: 线程保持活动时间的单位。 threadFactory: 用于设置创建线程的工厂。 handler(饱和处理器)：当工作队列为有界队列，并且池中的线程数量已经达到了最大线程数，此时新提交的任务就会由handler进行饱和处理，抛出异常。 当提交一个新任务到线程池中，线程池的处理流程如下： 判断线程是否已经达到核心线程数，如果当前池中线程数少于核心线程数，创建一个新线程，否则进入下一个流程。 判断工作队列是否已满，如果未满，则将任务放入队列中，如果队列已满，则进行下一个流程。 判断当前池中线程数是否已达到最大线程数，如果未达到，则创建新的线程并执行任务，如果已达到最大线程数，则任务会被拒绝。 当其他的线程执行完任务时，会进入空闲状态，如果队列中有任务，会取出来执行，当队列为空之后，超过空闲存活时间的队列会被回收。流程图： execute方法流程分析1234567891011121314151617181920public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123;//1.当前池中线程比核心数少，新建一个线程执行任务 if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;//2.核心池已满，但任务队列未满，添加到队列中 int recheck = ctl.get(); //任务成功添加到队列以后，再次检查是否需要添加新的线程，因为已存在的线程可能被销毁了 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //如果线程池处于非运行状态，并且把当前的任务从任务队列中移除成功，则拒绝该任务 else if (workerCountOf(recheck) == 0) addWorker(null, false);//如果之前的线程已被销毁完，新建一个线程 &#125; else if (!addWorker(command, false)) //3.核心池已满，队列已满，试着创建一个新线程 reject(command); //如果创建新线程失败了，说明线程池被关闭或者线程池完全满了，拒绝任务&#125; submit和execute的区别向一个线程池提交任务，可以使用submit和execute，这两者有什么区别呢？ execute只能接受Runnable类型的任务，execute没有返回值 submit不管是Runnable还是Callable类型的任务都可以接受，但是Runnable返回值均为void，所以使用Future的get()获得的还是null 不得不说- -，记录这篇文章的时候。满脑子都是当初在滴p科技面试时没答上来的尴尬(2333),也算是巩固了一遍知识吧~~放上我的老婆= =]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql下获取某月的每一天]]></title>
    <url>%2F2019%2F04%2F22%2Fmysql%E4%B8%8B%E8%8E%B7%E5%8F%96%E6%9F%90%E6%9C%88%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[记得以前自己写数据统计接口时，遇到一个根据选择的月份，查询出每天的数据的要求，由于每个月份的天数不同，不能按照固定天数来查。经过查阅之后找到了如下的方式： 使用union和日期函数构造一个左表12345678910111213SELECT ADDDATE(y.first, x.d - 1) as dd FROM (SELECT 1 AS d UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9 UNION ALL SELECT 10 UNION ALL SELECT 11 UNION ALL SELECT 12 UNION ALL SELECT 13 UNION ALL SELECT 14 UNION ALL SELECT 15 UNION ALL SELECT 16 UNION ALL SELECT 17 UNION ALL SELECT 18 UNION ALL SELECT 19 UNION ALL SELECT 20 UNION ALL SELECT 21 UNION ALL SELECT 22 UNION ALL SELECT 23 UNION ALL SELECT 24 UNION ALL SELECT 25 UNION ALL SELECT 26 UNION ALL SELECT 27 UNION ALL SELECT 28 UNION ALL SELECT 29 UNION ALL SELECT 30 UNION ALL SELECT 31 ) x, (SELECT CONCAT("2019-02",'-01') as FIRST, DAY(LAST_DAY(STR_TO_DATE("2019-02",'%Y-%m'))) AS last) y WHERE x.d &lt;= y.last 结果如下:之后只需将上面的结果集与需要的结果左连接，进行聚合就拿到结果啦~近期准备慢慢的把有道云里的笔记搬上来占个位= =]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式---单例模式]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F---%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式简单介绍单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类成为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 模式结构图 单例模式需要注意事项1.单例类的构造函数私有2.提供一个自身的静态私有成员变量3.提供一个公有的静态工厂方法 单例模式实例这里模拟实现一个居民身份证唯一的单例场景。123456789101112131415161718192021222324// 单例类如下public class IdCardNo &#123; private static IdCardNo instance = null; private String no; private IdCardNo() &#123; &#125; public static IdCardNo getInstance() &#123; if (instance == null) &#123; instance = new IdCardNo(); instance.setNo("No5000011113333"); &#125; return instance; &#125; public String getNo() &#123; return no; &#125; private void setNo(String no) &#123; this.no = no; &#125; 单例的多种写法上述场景中使用的是懒汉式写法，单例模式还有如下的几种写法饿汉式：1234567891011public class EagerSingleton &#123; private static EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123; &#125; public static EagerSingleton getInstance() &#123; return instance; &#125; &#125; 饿汉式的写法可以保证线程安全，但从资源利用率角度来考虑，比懒汉式写法稍差。但懒汉式存在线程安全问题，所以接下来考虑多个线程同时首次引用单例的访问限制问题。双重检测的单例：123456789101112131415161718public class Singleton &#123; //volatile禁止指令重排序，保证可见性 private static volatile Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 双重检测虽然解决了多线程的访问限制问题，但这个写法看起来着实不美观。那么我们还有没有别的写法呢？答案是有的。基于枚举的方式：12345678910111213public enum SingletonEnum &#123; INSTANCE; private Singleton instance = null; private SingletonEnum() &#123; instance = new Singleton(); &#125; public Singleton getInstance() &#123; return instance; &#125; &#125; 单元素的枚举类可以保证单例的线程安全、序列化，除单元素枚举外，还有使用java内部类实现的方式。基于内部类实现单例：1234567891011121314151617181920212223242526272829303132public class Singleton implements Serializable &#123; private Singleton() &#123; &#125; private static class SingletonHandler &#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonHandler.instance; &#125; private Object readResolve()&#123; System.out.println("read resolve"); return SingletonHandler.instance; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; Singleton instance = Singleton.getInstance(); File file = new File("ser.out"); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(instance); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); Singleton oIstance = (Singleton)ois.readObject(); ois.close(); System.out.println(oIstance == instance); &#125; &#125; 使用静态内部类的优点是：外部类加载时并不需要立即加载内部类，即当Singletonle被加载时，并不需要去加载SingletonHandler，只有当getInstance()方法第一次被调用时，才会去初始化SingletonHandler,同时初始化该类的静态变量instance,在确保线程安全的同时也延迟了单例的实例化. 总结一个类模板，在整个系统中只允许产生一个实例叫做单例。单例有多种写法：懒汉式、饿汉式、双重检查、枚举、内部类。 饿汉式不管用不用先创建出来，保证线程安全。 懒汉式延迟加载，有效利用资源不保证线程安全。 双重检测方式保证了懒汉式的线程安全问题。 单元素枚举可以同时保证线程安全和序列化。 内部类使用了jvm的类加载机制来保证线程安全和懒加载。 序列化和反序列化保证单例需要重写类的readResolve()方法]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我来了，我的博客]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%88%91%E6%9D%A5%E4%BA%86%EF%BC%8C%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[很久之前，在学习github的使用时就有了搭建这个个人博客的想法，虽说按照教程，早早地就已经搭建好了这个博客， 但是随着毕业季、入职工作等一系列的事情，也没有好好的静下心来整理。现如今工作也稳定下来了，一年多的时间不长不短，也是时候总结一下自己了。从小到大没有写日志习惯的我，估计写出来的东西，也只有自己能看看吧（笑），权当做给自己做个笔记，记录些工作中和生活中的小事吧。现在，第一步，先给我的hexo换个主题吧~ 第一次用markdown，语法还是挺奇怪的，不太习惯（雾）]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>开始</tag>
      </tags>
  </entry>
</search>
